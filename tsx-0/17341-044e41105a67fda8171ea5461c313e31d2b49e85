{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{extractBody,mixinBody,cloneBody,bodyUnusable}=require(\"./body\");const{Headers,fill:fillHeaders,HeadersList,setHeadersGuard,getHeadersGuard,setHeadersList,getHeadersList}=require(\"./headers\");const{FinalizationRegistry}=require(\"./dispatcher-weakref\")();const util=require(\"../../core/util\");const nodeUtil=require(\"node:util\");const{isValidHTTPToken,sameOrigin,environmentSettingsObject}=require(\"./util\");const{forbiddenMethodsSet,corsSafeListedMethodsSet,referrerPolicy,requestRedirect,requestMode,requestCredentials,requestCache,requestDuplex}=require(\"./constants\");const{kEnumerableProperty,normalizedMethodRecordsBase,normalizedMethodRecords}=util;const{kHeaders,kSignal,kState,kDispatcher}=require(\"./symbols\");const{webidl}=require(\"./webidl\");const{URLSerializer}=require(\"./data-url\");const{kConstruct}=require(\"../../core/symbols\");const assert=require(\"node:assert\");const{getMaxListeners,setMaxListeners,getEventListeners,defaultMaxListeners}=require(\"node:events\");const kAbortController=Symbol(\"abortController\");const requestFinalizer=new FinalizationRegistry(({signal,abort})=>{signal.removeEventListener(\"abort\",abort)});const dependentControllerMap=new WeakMap;function buildAbort(acRef){return abort;function abort(){const ac=acRef.deref();if(ac!==void 0){requestFinalizer.unregister(abort);this.removeEventListener(\"abort\",abort);ac.abort(this.reason);const controllerList=dependentControllerMap.get(ac.signal);if(controllerList!==void 0){if(controllerList.size!==0){for(const ref of controllerList){const ctrl=ref.deref();if(ctrl!==void 0){ctrl.abort(this.reason)}}controllerList.clear()}dependentControllerMap.delete(ac.signal)}}}__name(abort,\"abort\")}__name(buildAbort,\"buildAbort\");let patchMethodWarning=false;class Request{static{__name(this,\"Request\")}constructor(input,init={}){webidl.util.markAsUncloneable(this);if(input===kConstruct){return}const prefix=\"Request constructor\";webidl.argumentLengthCheck(arguments,1,prefix);input=webidl.converters.RequestInfo(input,prefix,\"input\");init=webidl.converters.RequestInit(init,prefix,\"init\");let request=null;let fallbackMode=null;const baseUrl=environmentSettingsObject.settingsObject.baseUrl;let signal=null;if(typeof input===\"string\"){this[kDispatcher]=init.dispatcher;let parsedURL;try{parsedURL=new URL(input,baseUrl)}catch(err){throw new TypeError(\"Failed to parse URL from \"+input,{cause:err})}if(parsedURL.username||parsedURL.password){throw new TypeError(\"Request cannot be constructed from a URL that includes credentials: \"+input)}request=makeRequest({urlList:[parsedURL]});fallbackMode=\"cors\"}else{this[kDispatcher]=init.dispatcher||input[kDispatcher];assert(input instanceof Request);request=input[kState];signal=input[kSignal]}const origin=environmentSettingsObject.settingsObject.origin;let window=\"client\";if(request.window?.constructor?.name===\"EnvironmentSettingsObject\"&&sameOrigin(request.window,origin)){window=request.window}if(init.window!=null){throw new TypeError(`'window' option '${window}' must be null`)}if(\"window\"in init){window=\"no-window\"}request=makeRequest({method:request.method,headersList:request.headersList,unsafeRequest:request.unsafeRequest,client:environmentSettingsObject.settingsObject,window,priority:request.priority,origin:request.origin,referrer:request.referrer,referrerPolicy:request.referrerPolicy,mode:request.mode,credentials:request.credentials,cache:request.cache,redirect:request.redirect,integrity:request.integrity,keepalive:request.keepalive,reloadNavigation:request.reloadNavigation,historyNavigation:request.historyNavigation,urlList:[...request.urlList]});const initHasKey=Object.keys(init).length!==0;if(initHasKey){if(request.mode===\"navigate\"){request.mode=\"same-origin\"}request.reloadNavigation=false;request.historyNavigation=false;request.origin=\"client\";request.referrer=\"client\";request.referrerPolicy=\"\";request.url=request.urlList[request.urlList.length-1];request.urlList=[request.url]}if(init.referrer!==void 0){const referrer=init.referrer;if(referrer===\"\"){request.referrer=\"no-referrer\"}else{let parsedReferrer;try{parsedReferrer=new URL(referrer,baseUrl)}catch(err){throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`,{cause:err})}if(parsedReferrer.protocol===\"about:\"&&parsedReferrer.hostname===\"client\"||origin&&!sameOrigin(parsedReferrer,environmentSettingsObject.settingsObject.baseUrl)){request.referrer=\"client\"}else{request.referrer=parsedReferrer}}}if(init.referrerPolicy!==void 0){request.referrerPolicy=init.referrerPolicy}let mode;if(init.mode!==void 0){mode=init.mode}else{mode=fallbackMode}if(mode===\"navigate\"){throw webidl.errors.exception({header:\"Request constructor\",message:\"invalid request mode navigate.\"})}if(mode!=null){request.mode=mode}if(init.credentials!==void 0){request.credentials=init.credentials}if(init.cache!==void 0){request.cache=init.cache}if(request.cache===\"only-if-cached\"&&request.mode!==\"same-origin\"){throw new TypeError(\"'only-if-cached' can be set only with 'same-origin' mode\")}if(init.redirect!==void 0){request.redirect=init.redirect}if(init.integrity!=null){request.integrity=String(init.integrity)}if(init.keepalive!==void 0){request.keepalive=Boolean(init.keepalive)}if(init.method!==void 0){let method=init.method;const mayBeNormalized=normalizedMethodRecords[method];if(mayBeNormalized!==void 0){request.method=mayBeNormalized}else{if(!isValidHTTPToken(method)){throw new TypeError(`'${method}' is not a valid HTTP method.`)}const upperCase=method.toUpperCase();if(forbiddenMethodsSet.has(upperCase)){throw new TypeError(`'${method}' HTTP method is unsupported.`)}method=normalizedMethodRecordsBase[upperCase]??method;request.method=method}if(!patchMethodWarning&&request.method===\"patch\"){process.emitWarning(\"Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.\",{code:\"UNDICI-FETCH-patch\"});patchMethodWarning=true}}if(init.signal!==void 0){signal=init.signal}this[kState]=request;const ac=new AbortController;this[kSignal]=ac.signal;if(signal!=null){if(!signal||typeof signal.aborted!==\"boolean\"||typeof signal.addEventListener!==\"function\"){throw new TypeError(\"Failed to construct 'Request': member signal is not of type AbortSignal.\")}if(signal.aborted){ac.abort(signal.reason)}else{this[kAbortController]=ac;const acRef=new WeakRef(ac);const abort=buildAbort(acRef);try{if(typeof getMaxListeners===\"function\"&&getMaxListeners(signal)===defaultMaxListeners){setMaxListeners(1500,signal)}else if(getEventListeners(signal,\"abort\").length>=defaultMaxListeners){setMaxListeners(1500,signal)}}catch{}util.addAbortListener(signal,abort);requestFinalizer.register(ac,{signal,abort},abort)}}this[kHeaders]=new Headers(kConstruct);setHeadersList(this[kHeaders],request.headersList);setHeadersGuard(this[kHeaders],\"request\");if(mode===\"no-cors\"){if(!corsSafeListedMethodsSet.has(request.method)){throw new TypeError(`'${request.method} is unsupported in no-cors mode.`)}setHeadersGuard(this[kHeaders],\"request-no-cors\")}if(initHasKey){const headersList=getHeadersList(this[kHeaders]);const headers=init.headers!==void 0?init.headers:new HeadersList(headersList);headersList.clear();if(headers instanceof HeadersList){for(const{name,value}of headers.rawValues()){headersList.append(name,value,false)}headersList.cookies=headers.cookies}else{fillHeaders(this[kHeaders],headers)}}const inputBody=input instanceof Request?input[kState].body:null;if((init.body!=null||inputBody!=null)&&(request.method===\"GET\"||request.method===\"HEAD\")){throw new TypeError(\"Request with GET/HEAD method cannot have body.\")}let initBody=null;if(init.body!=null){const[extractedBody,contentType]=extractBody(init.body,request.keepalive);initBody=extractedBody;if(contentType&&!getHeadersList(this[kHeaders]).contains(\"content-type\",true)){this[kHeaders].append(\"content-type\",contentType)}}const inputOrInitBody=initBody??inputBody;if(inputOrInitBody!=null&&inputOrInitBody.source==null){if(initBody!=null&&init.duplex==null){throw new TypeError(\"RequestInit: duplex option is required when sending a body.\")}if(request.mode!==\"same-origin\"&&request.mode!==\"cors\"){throw new TypeError('If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"')}request.useCORSPreflightFlag=true}let finalBody=inputOrInitBody;if(initBody==null&&inputBody!=null){if(bodyUnusable(input)){throw new TypeError(\"Cannot construct a Request with a Request object that has already been used.\")}const identityTransform=new TransformStream;inputBody.stream.pipeThrough(identityTransform);finalBody={source:inputBody.source,length:inputBody.length,stream:identityTransform.readable}}this[kState].body=finalBody}get method(){webidl.brandCheck(this,Request);return this[kState].method}get url(){webidl.brandCheck(this,Request);return URLSerializer(this[kState].url)}get headers(){webidl.brandCheck(this,Request);return this[kHeaders]}get destination(){webidl.brandCheck(this,Request);return this[kState].destination}get referrer(){webidl.brandCheck(this,Request);if(this[kState].referrer===\"no-referrer\"){return\"\"}if(this[kState].referrer===\"client\"){return\"about:client\"}return this[kState].referrer.toString()}get referrerPolicy(){webidl.brandCheck(this,Request);return this[kState].referrerPolicy}get mode(){webidl.brandCheck(this,Request);return this[kState].mode}get credentials(){return this[kState].credentials}get cache(){webidl.brandCheck(this,Request);return this[kState].cache}get redirect(){webidl.brandCheck(this,Request);return this[kState].redirect}get integrity(){webidl.brandCheck(this,Request);return this[kState].integrity}get keepalive(){webidl.brandCheck(this,Request);return this[kState].keepalive}get isReloadNavigation(){webidl.brandCheck(this,Request);return this[kState].reloadNavigation}get isHistoryNavigation(){webidl.brandCheck(this,Request);return this[kState].historyNavigation}get signal(){webidl.brandCheck(this,Request);return this[kSignal]}get body(){webidl.brandCheck(this,Request);return this[kState].body?this[kState].body.stream:null}get bodyUsed(){webidl.brandCheck(this,Request);return!!this[kState].body&&util.isDisturbed(this[kState].body.stream)}get duplex(){webidl.brandCheck(this,Request);return\"half\"}clone(){webidl.brandCheck(this,Request);if(bodyUnusable(this)){throw new TypeError(\"unusable\")}const clonedRequest=cloneRequest(this[kState]);const ac=new AbortController;if(this.signal.aborted){ac.abort(this.signal.reason)}else{let list=dependentControllerMap.get(this.signal);if(list===void 0){list=new Set;dependentControllerMap.set(this.signal,list)}const acRef=new WeakRef(ac);list.add(acRef);util.addAbortListener(ac.signal,buildAbort(acRef))}return fromInnerRequest(clonedRequest,ac.signal,getHeadersGuard(this[kHeaders]))}[nodeUtil.inspect.custom](depth,options){if(options.depth===null){options.depth=2}options.colors??=true;const properties={method:this.method,url:this.url,headers:this.headers,destination:this.destination,referrer:this.referrer,referrerPolicy:this.referrerPolicy,mode:this.mode,credentials:this.credentials,cache:this.cache,redirect:this.redirect,integrity:this.integrity,keepalive:this.keepalive,isReloadNavigation:this.isReloadNavigation,isHistoryNavigation:this.isHistoryNavigation,signal:this.signal};return`Request ${nodeUtil.formatWithOptions(options,properties)}`}}mixinBody(Request);function makeRequest(init){return{method:init.method??\"GET\",localURLsOnly:init.localURLsOnly??false,unsafeRequest:init.unsafeRequest??false,body:init.body??null,client:init.client??null,reservedClient:init.reservedClient??null,replacesClientId:init.replacesClientId??\"\",window:init.window??\"client\",keepalive:init.keepalive??false,serviceWorkers:init.serviceWorkers??\"all\",initiator:init.initiator??\"\",destination:init.destination??\"\",priority:init.priority??null,origin:init.origin??\"client\",policyContainer:init.policyContainer??\"client\",referrer:init.referrer??\"client\",referrerPolicy:init.referrerPolicy??\"\",mode:init.mode??\"no-cors\",useCORSPreflightFlag:init.useCORSPreflightFlag??false,credentials:init.credentials??\"same-origin\",useCredentials:init.useCredentials??false,cache:init.cache??\"default\",redirect:init.redirect??\"follow\",integrity:init.integrity??\"\",cryptoGraphicsNonceMetadata:init.cryptoGraphicsNonceMetadata??\"\",parserMetadata:init.parserMetadata??\"\",reloadNavigation:init.reloadNavigation??false,historyNavigation:init.historyNavigation??false,userActivation:init.userActivation??false,taintedOrigin:init.taintedOrigin??false,redirectCount:init.redirectCount??0,responseTainting:init.responseTainting??\"basic\",preventNoCacheCacheControlHeaderModification:init.preventNoCacheCacheControlHeaderModification??false,done:init.done??false,timingAllowFailed:init.timingAllowFailed??false,urlList:init.urlList,url:init.urlList[0],headersList:init.headersList?new HeadersList(init.headersList):new HeadersList}}__name(makeRequest,\"makeRequest\");function cloneRequest(request){const newRequest=makeRequest({...request,body:null});if(request.body!=null){newRequest.body=cloneBody(newRequest,request.body)}return newRequest}__name(cloneRequest,\"cloneRequest\");function fromInnerRequest(innerRequest,signal,guard){const request=new Request(kConstruct);request[kState]=innerRequest;request[kSignal]=signal;request[kHeaders]=new Headers(kConstruct);setHeadersList(request[kHeaders],innerRequest.headersList);setHeadersGuard(request[kHeaders],guard);return request}__name(fromInnerRequest,\"fromInnerRequest\");Object.defineProperties(Request.prototype,{method:kEnumerableProperty,url:kEnumerableProperty,headers:kEnumerableProperty,redirect:kEnumerableProperty,clone:kEnumerableProperty,signal:kEnumerableProperty,duplex:kEnumerableProperty,destination:kEnumerableProperty,body:kEnumerableProperty,bodyUsed:kEnumerableProperty,isHistoryNavigation:kEnumerableProperty,isReloadNavigation:kEnumerableProperty,keepalive:kEnumerableProperty,integrity:kEnumerableProperty,cache:kEnumerableProperty,credentials:kEnumerableProperty,attribute:kEnumerableProperty,referrerPolicy:kEnumerableProperty,referrer:kEnumerableProperty,mode:kEnumerableProperty,[Symbol.toStringTag]:{value:\"Request\",configurable:true}});webidl.converters.Request=webidl.interfaceConverter(Request);webidl.converters.RequestInfo=function(V,prefix,argument){if(typeof V===\"string\"){return webidl.converters.USVString(V,prefix,argument)}if(V instanceof Request){return webidl.converters.Request(V,prefix,argument)}return webidl.converters.USVString(V,prefix,argument)};webidl.converters.AbortSignal=webidl.interfaceConverter(AbortSignal);webidl.converters.RequestInit=webidl.dictionaryConverter([{key:\"method\",converter:webidl.converters.ByteString},{key:\"headers\",converter:webidl.converters.HeadersInit},{key:\"body\",converter:webidl.nullableConverter(webidl.converters.BodyInit)},{key:\"referrer\",converter:webidl.converters.USVString},{key:\"referrerPolicy\",converter:webidl.converters.DOMString,allowedValues:referrerPolicy},{key:\"mode\",converter:webidl.converters.DOMString,allowedValues:requestMode},{key:\"credentials\",converter:webidl.converters.DOMString,allowedValues:requestCredentials},{key:\"cache\",converter:webidl.converters.DOMString,allowedValues:requestCache},{key:\"redirect\",converter:webidl.converters.DOMString,allowedValues:requestRedirect},{key:\"integrity\",converter:webidl.converters.DOMString},{key:\"keepalive\",converter:webidl.converters.boolean},{key:\"signal\",converter:webidl.nullableConverter(signal=>webidl.converters.AbortSignal(signal,\"RequestInit\",\"signal\",{strict:false}))},{key:\"window\",converter:webidl.converters.any},{key:\"duplex\",converter:webidl.converters.DOMString,allowedValues:requestDuplex},{key:\"dispatcher\",converter:webidl.converters.any}]);module.exports={Request,makeRequest,fromInnerRequest,cloneRequest};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/fetch/request.js"],"sourcesContent":["/* globals AbortController */\n\n'use strict'\n\nconst { extractBody, mixinBody, cloneBody, bodyUnusable } = require('./body')\nconst { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = require('./headers')\nconst { FinalizationRegistry } = require('./dispatcher-weakref')()\nconst util = require('../../core/util')\nconst nodeUtil = require('node:util')\nconst {\n  isValidHTTPToken,\n  sameOrigin,\n  environmentSettingsObject\n} = require('./util')\nconst {\n  forbiddenMethodsSet,\n  corsSafeListedMethodsSet,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  requestDuplex\n} = require('./constants')\nconst { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util\nconst { kHeaders, kSignal, kState, kDispatcher } = require('./symbols')\nconst { webidl } = require('./webidl')\nconst { URLSerializer } = require('./data-url')\nconst { kConstruct } = require('../../core/symbols')\nconst assert = require('node:assert')\nconst { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require('node:events')\n\nconst kAbortController = Symbol('abortController')\n\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {\n  signal.removeEventListener('abort', abort)\n})\n\nconst dependentControllerMap = new WeakMap()\n\nfunction buildAbort (acRef) {\n  return abort\n\n  function abort () {\n    const ac = acRef.deref()\n    if (ac !== undefined) {\n      // Currently, there is a problem with FinalizationRegistry.\n      // https://github.com/nodejs/node/issues/49344\n      // https://github.com/nodejs/node/issues/47748\n      // In the case of abort, the first step is to unregister from it.\n      // If the controller can refer to it, it is still registered.\n      // It will be removed in the future.\n      requestFinalizer.unregister(abort)\n\n      // Unsubscribe a listener.\n      // FinalizationRegistry will no longer be called, so this must be done.\n      this.removeEventListener('abort', abort)\n\n      ac.abort(this.reason)\n\n      const controllerList = dependentControllerMap.get(ac.signal)\n\n      if (controllerList !== undefined) {\n        if (controllerList.size !== 0) {\n          for (const ref of controllerList) {\n            const ctrl = ref.deref()\n            if (ctrl !== undefined) {\n              ctrl.abort(this.reason)\n            }\n          }\n          controllerList.clear()\n        }\n        dependentControllerMap.delete(ac.signal)\n      }\n    }\n  }\n}\n\nlet patchMethodWarning = false\n\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n  // https://fetch.spec.whatwg.org/#dom-request\n  constructor (input, init = {}) {\n    webidl.util.markAsUncloneable(this)\n    if (input === kConstruct) {\n      return\n    }\n\n    const prefix = 'Request constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    input = webidl.converters.RequestInfo(input, prefix, 'input')\n    init = webidl.converters.RequestInit(init, prefix, 'init')\n\n    // 1. Let request be null.\n    let request = null\n\n    // 2. Let fallbackMode be null.\n    let fallbackMode = null\n\n    // 3. Let baseURL be this’s relevant settings object’s API base URL.\n    const baseUrl = environmentSettingsObject.settingsObject.baseUrl\n\n    // 4. Let signal be null.\n    let signal = null\n\n    // 5. If input is a string, then:\n    if (typeof input === 'string') {\n      this[kDispatcher] = init.dispatcher\n\n      // 1. Let parsedURL be the result of parsing input with baseURL.\n      // 2. If parsedURL is failure, then throw a TypeError.\n      let parsedURL\n      try {\n        parsedURL = new URL(input, baseUrl)\n      } catch (err) {\n        throw new TypeError('Failed to parse URL from ' + input, { cause: err })\n      }\n\n      // 3. If parsedURL includes credentials, then throw a TypeError.\n      if (parsedURL.username || parsedURL.password) {\n        throw new TypeError(\n          'Request cannot be constructed from a URL that includes credentials: ' +\n            input\n        )\n      }\n\n      // 4. Set request to a new request whose URL is parsedURL.\n      request = makeRequest({ urlList: [parsedURL] })\n\n      // 5. Set fallbackMode to \"cors\".\n      fallbackMode = 'cors'\n    } else {\n      this[kDispatcher] = init.dispatcher || input[kDispatcher]\n\n      // 6. Otherwise:\n\n      // 7. Assert: input is a Request object.\n      assert(input instanceof Request)\n\n      // 8. Set request to input’s request.\n      request = input[kState]\n\n      // 9. Set signal to input’s signal.\n      signal = input[kSignal]\n    }\n\n    // 7. Let origin be this’s relevant settings object’s origin.\n    const origin = environmentSettingsObject.settingsObject.origin\n\n    // 8. Let window be \"client\".\n    let window = 'client'\n\n    // 9. If request’s window is an environment settings object and its origin\n    // is same origin with origin, then set window to request’s window.\n    if (\n      request.window?.constructor?.name === 'EnvironmentSettingsObject' &&\n      sameOrigin(request.window, origin)\n    ) {\n      window = request.window\n    }\n\n    // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n    if (init.window != null) {\n      throw new TypeError(`'window' option '${window}' must be null`)\n    }\n\n    // 11. If init[\"window\"] exists, then set window to \"no-window\".\n    if ('window' in init) {\n      window = 'no-window'\n    }\n\n    // 12. Set request to a new request with the following properties:\n    request = makeRequest({\n      // URL request’s URL.\n      // undici implementation note: this is set as the first item in request's urlList in makeRequest\n      // method request’s method.\n      method: request.method,\n      // header list A copy of request’s header list.\n      // undici implementation note: headersList is cloned in makeRequest\n      headersList: request.headersList,\n      // unsafe-request flag Set.\n      unsafeRequest: request.unsafeRequest,\n      // client This’s relevant settings object.\n      client: environmentSettingsObject.settingsObject,\n      // window window.\n      window,\n      // priority request’s priority.\n      priority: request.priority,\n      // origin request’s origin. The propagation of the origin is only significant for navigation requests\n      // being handled by a service worker. In this scenario a request can have an origin that is different\n      // from the current client.\n      origin: request.origin,\n      // referrer request’s referrer.\n      referrer: request.referrer,\n      // referrer policy request’s referrer policy.\n      referrerPolicy: request.referrerPolicy,\n      // mode request’s mode.\n      mode: request.mode,\n      // credentials mode request’s credentials mode.\n      credentials: request.credentials,\n      // cache mode request’s cache mode.\n      cache: request.cache,\n      // redirect mode request’s redirect mode.\n      redirect: request.redirect,\n      // integrity metadata request’s integrity metadata.\n      integrity: request.integrity,\n      // keepalive request’s keepalive.\n      keepalive: request.keepalive,\n      // reload-navigation flag request’s reload-navigation flag.\n      reloadNavigation: request.reloadNavigation,\n      // history-navigation flag request’s history-navigation flag.\n      historyNavigation: request.historyNavigation,\n      // URL list A clone of request’s URL list.\n      urlList: [...request.urlList]\n    })\n\n    const initHasKey = Object.keys(init).length !== 0\n\n    // 13. If init is not empty, then:\n    if (initHasKey) {\n      // 1. If request’s mode is \"navigate\", then set it to \"same-origin\".\n      if (request.mode === 'navigate') {\n        request.mode = 'same-origin'\n      }\n\n      // 2. Unset request’s reload-navigation flag.\n      request.reloadNavigation = false\n\n      // 3. Unset request’s history-navigation flag.\n      request.historyNavigation = false\n\n      // 4. Set request’s origin to \"client\".\n      request.origin = 'client'\n\n      // 5. Set request’s referrer to \"client\"\n      request.referrer = 'client'\n\n      // 6. Set request’s referrer policy to the empty string.\n      request.referrerPolicy = ''\n\n      // 7. Set request’s URL to request’s current URL.\n      request.url = request.urlList[request.urlList.length - 1]\n\n      // 8. Set request’s URL list to « request’s URL ».\n      request.urlList = [request.url]\n    }\n\n    // 14. If init[\"referrer\"] exists, then:\n    if (init.referrer !== undefined) {\n      // 1. Let referrer be init[\"referrer\"].\n      const referrer = init.referrer\n\n      // 2. If referrer is the empty string, then set request’s referrer to \"no-referrer\".\n      if (referrer === '') {\n        request.referrer = 'no-referrer'\n      } else {\n        // 1. Let parsedReferrer be the result of parsing referrer with\n        // baseURL.\n        // 2. If parsedReferrer is failure, then throw a TypeError.\n        let parsedReferrer\n        try {\n          parsedReferrer = new URL(referrer, baseUrl)\n        } catch (err) {\n          throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`, { cause: err })\n        }\n\n        // 3. If one of the following is true\n        // - parsedReferrer’s scheme is \"about\" and path is the string \"client\"\n        // - parsedReferrer’s origin is not same origin with origin\n        // then set request’s referrer to \"client\".\n        if (\n          (parsedReferrer.protocol === 'about:' && parsedReferrer.hostname === 'client') ||\n          (origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl))\n        ) {\n          request.referrer = 'client'\n        } else {\n          // 4. Otherwise, set request’s referrer to parsedReferrer.\n          request.referrer = parsedReferrer\n        }\n      }\n    }\n\n    // 15. If init[\"referrerPolicy\"] exists, then set request’s referrer policy\n    // to it.\n    if (init.referrerPolicy !== undefined) {\n      request.referrerPolicy = init.referrerPolicy\n    }\n\n    // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n    let mode\n    if (init.mode !== undefined) {\n      mode = init.mode\n    } else {\n      mode = fallbackMode\n    }\n\n    // 17. If mode is \"navigate\", then throw a TypeError.\n    if (mode === 'navigate') {\n      throw webidl.errors.exception({\n        header: 'Request constructor',\n        message: 'invalid request mode navigate.'\n      })\n    }\n\n    // 18. If mode is non-null, set request’s mode to mode.\n    if (mode != null) {\n      request.mode = mode\n    }\n\n    // 19. If init[\"credentials\"] exists, then set request’s credentials mode\n    // to it.\n    if (init.credentials !== undefined) {\n      request.credentials = init.credentials\n    }\n\n    // 18. If init[\"cache\"] exists, then set request’s cache mode to it.\n    if (init.cache !== undefined) {\n      request.cache = init.cache\n    }\n\n    // 21. If request’s cache mode is \"only-if-cached\" and request’s mode is\n    // not \"same-origin\", then throw a TypeError.\n    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n      throw new TypeError(\n        \"'only-if-cached' can be set only with 'same-origin' mode\"\n      )\n    }\n\n    // 22. If init[\"redirect\"] exists, then set request’s redirect mode to it.\n    if (init.redirect !== undefined) {\n      request.redirect = init.redirect\n    }\n\n    // 23. If init[\"integrity\"] exists, then set request’s integrity metadata to it.\n    if (init.integrity != null) {\n      request.integrity = String(init.integrity)\n    }\n\n    // 24. If init[\"keepalive\"] exists, then set request’s keepalive to it.\n    if (init.keepalive !== undefined) {\n      request.keepalive = Boolean(init.keepalive)\n    }\n\n    // 25. If init[\"method\"] exists, then:\n    if (init.method !== undefined) {\n      // 1. Let method be init[\"method\"].\n      let method = init.method\n\n      const mayBeNormalized = normalizedMethodRecords[method]\n\n      if (mayBeNormalized !== undefined) {\n        // Note: Bypass validation DELETE, GET, HEAD, OPTIONS, POST, PUT, PATCH and these lowercase ones\n        request.method = mayBeNormalized\n      } else {\n        // 2. If method is not a method or method is a forbidden method, then\n        // throw a TypeError.\n        if (!isValidHTTPToken(method)) {\n          throw new TypeError(`'${method}' is not a valid HTTP method.`)\n        }\n\n        const upperCase = method.toUpperCase()\n\n        if (forbiddenMethodsSet.has(upperCase)) {\n          throw new TypeError(`'${method}' HTTP method is unsupported.`)\n        }\n\n        // 3. Normalize method.\n        // https://fetch.spec.whatwg.org/#concept-method-normalize\n        // Note: must be in uppercase\n        method = normalizedMethodRecordsBase[upperCase] ?? method\n\n        // 4. Set request’s method to method.\n        request.method = method\n      }\n\n      if (!patchMethodWarning && request.method === 'patch') {\n        process.emitWarning('Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.', {\n          code: 'UNDICI-FETCH-patch'\n        })\n\n        patchMethodWarning = true\n      }\n    }\n\n    // 26. If init[\"signal\"] exists, then set signal to it.\n    if (init.signal !== undefined) {\n      signal = init.signal\n    }\n\n    // 27. Set this’s request to request.\n    this[kState] = request\n\n    // 28. Set this’s signal to a new AbortSignal object with this’s relevant\n    // Realm.\n    // TODO: could this be simplified with AbortSignal.any\n    // (https://dom.spec.whatwg.org/#dom-abortsignal-any)\n    const ac = new AbortController()\n    this[kSignal] = ac.signal\n\n    // 29. If signal is not null, then make this’s signal follow signal.\n    if (signal != null) {\n      if (\n        !signal ||\n        typeof signal.aborted !== 'boolean' ||\n        typeof signal.addEventListener !== 'function'\n      ) {\n        throw new TypeError(\n          \"Failed to construct 'Request': member signal is not of type AbortSignal.\"\n        )\n      }\n\n      if (signal.aborted) {\n        ac.abort(signal.reason)\n      } else {\n        // Keep a strong ref to ac while request object\n        // is alive. This is needed to prevent AbortController\n        // from being prematurely garbage collected.\n        // See, https://github.com/nodejs/undici/issues/1926.\n        this[kAbortController] = ac\n\n        const acRef = new WeakRef(ac)\n        const abort = buildAbort(acRef)\n\n        // Third-party AbortControllers may not work with these.\n        // See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.\n        try {\n          // If the max amount of listeners is equal to the default, increase it\n          // This is only available in node >= v19.9.0\n          if (typeof getMaxListeners === 'function' && getMaxListeners(signal) === defaultMaxListeners) {\n            setMaxListeners(1500, signal)\n          } else if (getEventListeners(signal, 'abort').length >= defaultMaxListeners) {\n            setMaxListeners(1500, signal)\n          }\n        } catch {}\n\n        util.addAbortListener(signal, abort)\n        // The third argument must be a registry key to be unregistered.\n        // Without it, you cannot unregister.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n        // abort is used as the unregister key. (because it is unique)\n        requestFinalizer.register(ac, { signal, abort }, abort)\n      }\n    }\n\n    // 30. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is request’s header list and guard is\n    // \"request\".\n    this[kHeaders] = new Headers(kConstruct)\n    setHeadersList(this[kHeaders], request.headersList)\n    setHeadersGuard(this[kHeaders], 'request')\n\n    // 31. If this’s request’s mode is \"no-cors\", then:\n    if (mode === 'no-cors') {\n      // 1. If this’s request’s method is not a CORS-safelisted method,\n      // then throw a TypeError.\n      if (!corsSafeListedMethodsSet.has(request.method)) {\n        throw new TypeError(\n          `'${request.method} is unsupported in no-cors mode.`\n        )\n      }\n\n      // 2. Set this’s headers’s guard to \"request-no-cors\".\n      setHeadersGuard(this[kHeaders], 'request-no-cors')\n    }\n\n    // 32. If init is not empty, then:\n    if (initHasKey) {\n      /** @type {HeadersList} */\n      const headersList = getHeadersList(this[kHeaders])\n      // 1. Let headers be a copy of this’s headers and its associated header\n      // list.\n      // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n      const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList)\n\n      // 3. Empty this’s headers’s header list.\n      headersList.clear()\n\n      // 4. If headers is a Headers object, then for each header in its header\n      // list, append header’s name/header’s value to this’s headers.\n      if (headers instanceof HeadersList) {\n        for (const { name, value } of headers.rawValues()) {\n          headersList.append(name, value, false)\n        }\n        // Note: Copy the `set-cookie` meta-data.\n        headersList.cookies = headers.cookies\n      } else {\n        // 5. Otherwise, fill this’s headers with headers.\n        fillHeaders(this[kHeaders], headers)\n      }\n    }\n\n    // 33. Let inputBody be input’s request’s body if input is a Request\n    // object; otherwise null.\n    const inputBody = input instanceof Request ? input[kState].body : null\n\n    // 34. If either init[\"body\"] exists and is non-null or inputBody is\n    // non-null, and request’s method is `GET` or `HEAD`, then throw a\n    // TypeError.\n    if (\n      (init.body != null || inputBody != null) &&\n      (request.method === 'GET' || request.method === 'HEAD')\n    ) {\n      throw new TypeError('Request with GET/HEAD method cannot have body.')\n    }\n\n    // 35. Let initBody be null.\n    let initBody = null\n\n    // 36. If init[\"body\"] exists and is non-null, then:\n    if (init.body != null) {\n      // 1. Let Content-Type be null.\n      // 2. Set initBody and Content-Type to the result of extracting\n      // init[\"body\"], with keepalive set to request’s keepalive.\n      const [extractedBody, contentType] = extractBody(\n        init.body,\n        request.keepalive\n      )\n      initBody = extractedBody\n\n      // 3, If Content-Type is non-null and this’s headers’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n      // this’s headers.\n      if (contentType && !getHeadersList(this[kHeaders]).contains('content-type', true)) {\n        this[kHeaders].append('content-type', contentType)\n      }\n    }\n\n    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n    // inputBody.\n    const inputOrInitBody = initBody ?? inputBody\n\n    // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is\n    // null, then:\n    if (inputOrInitBody != null && inputOrInitBody.source == null) {\n      // 1. If initBody is non-null and init[\"duplex\"] does not exist,\n      //    then throw a TypeError.\n      if (initBody != null && init.duplex == null) {\n        throw new TypeError('RequestInit: duplex option is required when sending a body.')\n      }\n\n      // 2. If this’s request’s mode is neither \"same-origin\" nor \"cors\",\n      // then throw a TypeError.\n      if (request.mode !== 'same-origin' && request.mode !== 'cors') {\n        throw new TypeError(\n          'If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"'\n        )\n      }\n\n      // 3. Set this’s request’s use-CORS-preflight flag.\n      request.useCORSPreflightFlag = true\n    }\n\n    // 39. Let finalBody be inputOrInitBody.\n    let finalBody = inputOrInitBody\n\n    // 40. If initBody is null and inputBody is non-null, then:\n    if (initBody == null && inputBody != null) {\n      // 1. If input is unusable, then throw a TypeError.\n      if (bodyUnusable(input)) {\n        throw new TypeError(\n          'Cannot construct a Request with a Request object that has already been used.'\n        )\n      }\n\n      // 2. Set finalBody to the result of creating a proxy for inputBody.\n      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n      const identityTransform = new TransformStream()\n      inputBody.stream.pipeThrough(identityTransform)\n      finalBody = {\n        source: inputBody.source,\n        length: inputBody.length,\n        stream: identityTransform.readable\n      }\n    }\n\n    // 41. Set this’s request’s body to finalBody.\n    this[kState].body = finalBody\n  }\n\n  // Returns request’s HTTP method, which is \"GET\" by default.\n  get method () {\n    webidl.brandCheck(this, Request)\n\n    // The method getter steps are to return this’s request’s method.\n    return this[kState].method\n  }\n\n  // Returns the URL of request as a string.\n  get url () {\n    webidl.brandCheck(this, Request)\n\n    // The url getter steps are to return this’s request’s URL, serialized.\n    return URLSerializer(this[kState].url)\n  }\n\n  // Returns a Headers object consisting of the headers associated with request.\n  // Note that headers added in the network layer by the user agent will not\n  // be accounted for in this object, e.g., the \"Host\" header.\n  get headers () {\n    webidl.brandCheck(this, Request)\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  // Returns the kind of resource requested by request, e.g., \"document\"\n  // or \"script\".\n  get destination () {\n    webidl.brandCheck(this, Request)\n\n    // The destination getter are to return this’s request’s destination.\n    return this[kState].destination\n  }\n\n  // Returns the referrer of request. Its value can be a same-origin URL if\n  // explicitly set in init, the empty string to indicate no referrer, and\n  // \"about:client\" when defaulting to the global’s default. This is used\n  // during fetching to determine the value of the `Referer` header of the\n  // request being made.\n  get referrer () {\n    webidl.brandCheck(this, Request)\n\n    // 1. If this’s request’s referrer is \"no-referrer\", then return the\n    // empty string.\n    if (this[kState].referrer === 'no-referrer') {\n      return ''\n    }\n\n    // 2. If this’s request’s referrer is \"client\", then return\n    // \"about:client\".\n    if (this[kState].referrer === 'client') {\n      return 'about:client'\n    }\n\n    // Return this’s request’s referrer, serialized.\n    return this[kState].referrer.toString()\n  }\n\n  // Returns the referrer policy associated with request.\n  // This is used during fetching to compute the value of the request’s\n  // referrer.\n  get referrerPolicy () {\n    webidl.brandCheck(this, Request)\n\n    // The referrerPolicy getter steps are to return this’s request’s referrer policy.\n    return this[kState].referrerPolicy\n  }\n\n  // Returns the mode associated with request, which is a string indicating\n  // whether the request will use CORS, or will be restricted to same-origin\n  // URLs.\n  get mode () {\n    webidl.brandCheck(this, Request)\n\n    // The mode getter steps are to return this’s request’s mode.\n    return this[kState].mode\n  }\n\n  // Returns the credentials mode associated with request,\n  // which is a string indicating whether credentials will be sent with the\n  // request always, never, or only when sent to a same-origin URL.\n  get credentials () {\n    // The credentials getter steps are to return this’s request’s credentials mode.\n    return this[kState].credentials\n  }\n\n  // Returns the cache mode associated with request,\n  // which is a string indicating how the request will\n  // interact with the browser’s cache when fetching.\n  get cache () {\n    webidl.brandCheck(this, Request)\n\n    // The cache getter steps are to return this’s request’s cache mode.\n    return this[kState].cache\n  }\n\n  // Returns the redirect mode associated with request,\n  // which is a string indicating how redirects for the\n  // request will be handled during fetching. A request\n  // will follow redirects by default.\n  get redirect () {\n    webidl.brandCheck(this, Request)\n\n    // The redirect getter steps are to return this’s request’s redirect mode.\n    return this[kState].redirect\n  }\n\n  // Returns request’s subresource integrity metadata, which is a\n  // cryptographic hash of the resource being fetched. Its value\n  // consists of multiple hashes separated by whitespace. [SRI]\n  get integrity () {\n    webidl.brandCheck(this, Request)\n\n    // The integrity getter steps are to return this’s request’s integrity\n    // metadata.\n    return this[kState].integrity\n  }\n\n  // Returns a boolean indicating whether or not request can outlive the\n  // global in which it was created.\n  get keepalive () {\n    webidl.brandCheck(this, Request)\n\n    // The keepalive getter steps are to return this’s request’s keepalive.\n    return this[kState].keepalive\n  }\n\n  // Returns a boolean indicating whether or not request is for a reload\n  // navigation.\n  get isReloadNavigation () {\n    webidl.brandCheck(this, Request)\n\n    // The isReloadNavigation getter steps are to return true if this’s\n    // request’s reload-navigation flag is set; otherwise false.\n    return this[kState].reloadNavigation\n  }\n\n  // Returns a boolean indicating whether or not request is for a history\n  // navigation (a.k.a. back-forward navigation).\n  get isHistoryNavigation () {\n    webidl.brandCheck(this, Request)\n\n    // The isHistoryNavigation getter steps are to return true if this’s request’s\n    // history-navigation flag is set; otherwise false.\n    return this[kState].historyNavigation\n  }\n\n  // Returns the signal associated with request, which is an AbortSignal\n  // object indicating whether or not request has been aborted, and its\n  // abort event handler.\n  get signal () {\n    webidl.brandCheck(this, Request)\n\n    // The signal getter steps are to return this’s signal.\n    return this[kSignal]\n  }\n\n  get body () {\n    webidl.brandCheck(this, Request)\n\n    return this[kState].body ? this[kState].body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Request)\n\n    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)\n  }\n\n  get duplex () {\n    webidl.brandCheck(this, Request)\n\n    return 'half'\n  }\n\n  // Returns a clone of request.\n  clone () {\n    webidl.brandCheck(this, Request)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (bodyUnusable(this)) {\n      throw new TypeError('unusable')\n    }\n\n    // 2. Let clonedRequest be the result of cloning this’s request.\n    const clonedRequest = cloneRequest(this[kState])\n\n    // 3. Let clonedRequestObject be the result of creating a Request object,\n    // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.\n    // 4. Make clonedRequestObject’s signal follow this’s signal.\n    const ac = new AbortController()\n    if (this.signal.aborted) {\n      ac.abort(this.signal.reason)\n    } else {\n      let list = dependentControllerMap.get(this.signal)\n      if (list === undefined) {\n        list = new Set()\n        dependentControllerMap.set(this.signal, list)\n      }\n      const acRef = new WeakRef(ac)\n      list.add(acRef)\n      util.addAbortListener(\n        ac.signal,\n        buildAbort(acRef)\n      )\n    }\n\n    // 4. Return clonedRequestObject.\n    return fromInnerRequest(clonedRequest, ac.signal, getHeadersGuard(this[kHeaders]))\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    if (options.depth === null) {\n      options.depth = 2\n    }\n\n    options.colors ??= true\n\n    const properties = {\n      method: this.method,\n      url: this.url,\n      headers: this.headers,\n      destination: this.destination,\n      referrer: this.referrer,\n      referrerPolicy: this.referrerPolicy,\n      mode: this.mode,\n      credentials: this.credentials,\n      cache: this.cache,\n      redirect: this.redirect,\n      integrity: this.integrity,\n      keepalive: this.keepalive,\n      isReloadNavigation: this.isReloadNavigation,\n      isHistoryNavigation: this.isHistoryNavigation,\n      signal: this.signal\n    }\n\n    return `Request ${nodeUtil.formatWithOptions(options, properties)}`\n  }\n}\n\nmixinBody(Request)\n\n// https://fetch.spec.whatwg.org/#requests\nfunction makeRequest (init) {\n  return {\n    method: init.method ?? 'GET',\n    localURLsOnly: init.localURLsOnly ?? false,\n    unsafeRequest: init.unsafeRequest ?? false,\n    body: init.body ?? null,\n    client: init.client ?? null,\n    reservedClient: init.reservedClient ?? null,\n    replacesClientId: init.replacesClientId ?? '',\n    window: init.window ?? 'client',\n    keepalive: init.keepalive ?? false,\n    serviceWorkers: init.serviceWorkers ?? 'all',\n    initiator: init.initiator ?? '',\n    destination: init.destination ?? '',\n    priority: init.priority ?? null,\n    origin: init.origin ?? 'client',\n    policyContainer: init.policyContainer ?? 'client',\n    referrer: init.referrer ?? 'client',\n    referrerPolicy: init.referrerPolicy ?? '',\n    mode: init.mode ?? 'no-cors',\n    useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,\n    credentials: init.credentials ?? 'same-origin',\n    useCredentials: init.useCredentials ?? false,\n    cache: init.cache ?? 'default',\n    redirect: init.redirect ?? 'follow',\n    integrity: init.integrity ?? '',\n    cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? '',\n    parserMetadata: init.parserMetadata ?? '',\n    reloadNavigation: init.reloadNavigation ?? false,\n    historyNavigation: init.historyNavigation ?? false,\n    userActivation: init.userActivation ?? false,\n    taintedOrigin: init.taintedOrigin ?? false,\n    redirectCount: init.redirectCount ?? 0,\n    responseTainting: init.responseTainting ?? 'basic',\n    preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,\n    done: init.done ?? false,\n    timingAllowFailed: init.timingAllowFailed ?? false,\n    urlList: init.urlList,\n    url: init.urlList[0],\n    headersList: init.headersList\n      ? new HeadersList(init.headersList)\n      : new HeadersList()\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest (request) {\n  // To clone a request request, run these steps:\n\n  // 1. Let newRequest be a copy of request, except for its body.\n  const newRequest = makeRequest({ ...request, body: null })\n\n  // 2. If request’s body is non-null, set newRequest’s body to the\n  // result of cloning request’s body.\n  if (request.body != null) {\n    newRequest.body = cloneBody(newRequest, request.body)\n  }\n\n  // 3. Return newRequest.\n  return newRequest\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#request-create\n * @param {any} innerRequest\n * @param {AbortSignal} signal\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Request}\n */\nfunction fromInnerRequest (innerRequest, signal, guard) {\n  const request = new Request(kConstruct)\n  request[kState] = innerRequest\n  request[kSignal] = signal\n  request[kHeaders] = new Headers(kConstruct)\n  setHeadersList(request[kHeaders], innerRequest.headersList)\n  setHeadersGuard(request[kHeaders], guard)\n  return request\n}\n\nObject.defineProperties(Request.prototype, {\n  method: kEnumerableProperty,\n  url: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  signal: kEnumerableProperty,\n  duplex: kEnumerableProperty,\n  destination: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  isHistoryNavigation: kEnumerableProperty,\n  isReloadNavigation: kEnumerableProperty,\n  keepalive: kEnumerableProperty,\n  integrity: kEnumerableProperty,\n  cache: kEnumerableProperty,\n  credentials: kEnumerableProperty,\n  attribute: kEnumerableProperty,\n  referrerPolicy: kEnumerableProperty,\n  referrer: kEnumerableProperty,\n  mode: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Request',\n    configurable: true\n  }\n})\n\nwebidl.converters.Request = webidl.interfaceConverter(\n  Request\n)\n\n// https://fetch.spec.whatwg.org/#requestinfo\nwebidl.converters.RequestInfo = function (V, prefix, argument) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V, prefix, argument)\n  }\n\n  if (V instanceof Request) {\n    return webidl.converters.Request(V, prefix, argument)\n  }\n\n  return webidl.converters.USVString(V, prefix, argument)\n}\n\nwebidl.converters.AbortSignal = webidl.interfaceConverter(\n  AbortSignal\n)\n\n// https://fetch.spec.whatwg.org/#requestinit\nwebidl.converters.RequestInit = webidl.dictionaryConverter([\n  {\n    key: 'method',\n    converter: webidl.converters.ByteString\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  },\n  {\n    key: 'body',\n    converter: webidl.nullableConverter(\n      webidl.converters.BodyInit\n    )\n  },\n  {\n    key: 'referrer',\n    converter: webidl.converters.USVString\n  },\n  {\n    key: 'referrerPolicy',\n    converter: webidl.converters.DOMString,\n    // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n    allowedValues: referrerPolicy\n  },\n  {\n    key: 'mode',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#concept-request-mode\n    allowedValues: requestMode\n  },\n  {\n    key: 'credentials',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestcredentials\n    allowedValues: requestCredentials\n  },\n  {\n    key: 'cache',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestcache\n    allowedValues: requestCache\n  },\n  {\n    key: 'redirect',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestredirect\n    allowedValues: requestRedirect\n  },\n  {\n    key: 'integrity',\n    converter: webidl.converters.DOMString\n  },\n  {\n    key: 'keepalive',\n    converter: webidl.converters.boolean\n  },\n  {\n    key: 'signal',\n    converter: webidl.nullableConverter(\n      (signal) => webidl.converters.AbortSignal(\n        signal,\n        'RequestInit',\n        'signal',\n        { strict: false }\n      )\n    )\n  },\n  {\n    key: 'window',\n    converter: webidl.converters.any\n  },\n  {\n    key: 'duplex',\n    converter: webidl.converters.DOMString,\n    allowedValues: requestDuplex\n  },\n  {\n    key: 'dispatcher', // undici specific option\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = { Request, makeRequest, fromInnerRequest, cloneRequest }\n"]}}