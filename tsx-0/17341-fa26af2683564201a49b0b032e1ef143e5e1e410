{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{wellknownHeaderNames,headerNameLowerCasedRecord}=require(\"./constants\");class TstNode{static{__name(this,\"TstNode\")}value=null;left=null;middle=null;right=null;code;constructor(key,value,index){if(index===void 0||index>=key.length){throw new TypeError(\"Unreachable\")}const code=this.code=key.charCodeAt(index);if(code>127){throw new TypeError(\"key must be ascii string\")}if(key.length!==++index){this.middle=new TstNode(key,value,index)}else{this.value=value}}add(key,value){const length=key.length;if(length===0){throw new TypeError(\"Unreachable\")}let index=0;let node=this;while(true){const code=key.charCodeAt(index);if(code>127){throw new TypeError(\"key must be ascii string\")}if(node.code===code){if(length===++index){node.value=value;break}else if(node.middle!==null){node=node.middle}else{node.middle=new TstNode(key,value,index);break}}else if(node.code<code){if(node.left!==null){node=node.left}else{node.left=new TstNode(key,value,index);break}}else if(node.right!==null){node=node.right}else{node.right=new TstNode(key,value,index);break}}}search(key){const keylength=key.length;let index=0;let node=this;while(node!==null&&index<keylength){let code=key[index];if(code<=90&&code>=65){code|=32}while(node!==null){if(code===node.code){if(keylength===++index){return node}node=node.middle;break}node=node.code<code?node.left:node.right}}return null}}class TernarySearchTree{static{__name(this,\"TernarySearchTree\")}node=null;insert(key,value){if(this.node===null){this.node=new TstNode(key,value,0)}else{this.node.add(key,value)}}lookup(key){return this.node?.search(key)?.value??null}}const tree=new TernarySearchTree;for(let i=0;i<wellknownHeaderNames.length;++i){const key=headerNameLowerCasedRecord[wellknownHeaderNames[i]];tree.insert(key,key)}module.exports={TernarySearchTree,tree};\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAEA,KAAM,CACJ,qBACA,0BACF,EAAI,QAAQ,aAAa,EAEzB,MAAM,OAAQ,CAPd,MAOc,wBAEZ,MAAQ,KAER,KAAO,KAEP,OAAS,KAET,MAAQ,KAER,KAMA,YAAa,IAAK,MAAO,MAAO,CAC9B,GAAI,QAAU,QAAa,OAAS,IAAI,OAAQ,CAC9C,MAAM,IAAI,UAAU,aAAa,CACnC,CACA,MAAM,KAAO,KAAK,KAAO,IAAI,WAAW,KAAK,EAE7C,GAAI,KAAO,IAAM,CACf,MAAM,IAAI,UAAU,0BAA0B,CAChD,CACA,GAAI,IAAI,SAAW,EAAE,MAAO,CAC1B,KAAK,OAAS,IAAI,QAAQ,IAAK,MAAO,KAAK,CAC7C,KAAO,CACL,KAAK,MAAQ,KACf,CACF,CAMA,IAAK,IAAK,MAAO,CACf,MAAM,OAAS,IAAI,OACnB,GAAI,SAAW,EAAG,CAChB,MAAM,IAAI,UAAU,aAAa,CACnC,CACA,IAAI,MAAQ,EACZ,IAAI,KAAO,KACX,MAAO,KAAM,CACX,MAAM,KAAO,IAAI,WAAW,KAAK,EAEjC,GAAI,KAAO,IAAM,CACf,MAAM,IAAI,UAAU,0BAA0B,CAChD,CACA,GAAI,KAAK,OAAS,KAAM,CACtB,GAAI,SAAW,EAAE,MAAO,CACtB,KAAK,MAAQ,MACb,KACF,SAAW,KAAK,SAAW,KAAM,CAC/B,KAAO,KAAK,MACd,KAAO,CACL,KAAK,OAAS,IAAI,QAAQ,IAAK,MAAO,KAAK,EAC3C,KACF,CACF,SAAW,KAAK,KAAO,KAAM,CAC3B,GAAI,KAAK,OAAS,KAAM,CACtB,KAAO,KAAK,IACd,KAAO,CACL,KAAK,KAAO,IAAI,QAAQ,IAAK,MAAO,KAAK,EACzC,KACF,CACF,SAAW,KAAK,QAAU,KAAM,CAC9B,KAAO,KAAK,KACd,KAAO,CACL,KAAK,MAAQ,IAAI,QAAQ,IAAK,MAAO,KAAK,EAC1C,KACF,CACF,CACF,CAMA,OAAQ,IAAK,CACX,MAAM,UAAY,IAAI,OACtB,IAAI,MAAQ,EACZ,IAAI,KAAO,KACX,MAAO,OAAS,MAAQ,MAAQ,UAAW,CACzC,IAAI,KAAO,IAAI,KAAK,EAKpB,GAAI,MAAQ,IAAQ,MAAQ,GAAM,CAEhC,MAAQ,EACV,CACA,MAAO,OAAS,KAAM,CACpB,GAAI,OAAS,KAAK,KAAM,CACtB,GAAI,YAAc,EAAE,MAAO,CAEzB,OAAO,IACT,CACA,KAAO,KAAK,OACZ,KACF,CACA,KAAO,KAAK,KAAO,KAAO,KAAK,KAAO,KAAK,KAC7C,CACF,CACA,OAAO,IACT,CACF,CAEA,MAAM,iBAAkB,CApHxB,MAoHwB,kCAEtB,KAAO,KAMP,OAAQ,IAAK,MAAO,CAClB,GAAI,KAAK,OAAS,KAAM,CACtB,KAAK,KAAO,IAAI,QAAQ,IAAK,MAAO,CAAC,CACvC,KAAO,CACL,KAAK,KAAK,IAAI,IAAK,KAAK,CAC1B,CACF,CAMA,OAAQ,IAAK,CACX,OAAO,KAAK,MAAM,OAAO,GAAG,GAAG,OAAS,IAC1C,CACF,CAEA,MAAM,KAAO,IAAI,kBAEjB,QAAS,EAAI,EAAG,EAAI,qBAAqB,OAAQ,EAAE,EAAG,CACpD,MAAM,IAAM,2BAA2B,qBAAqB,CAAC,CAAC,EAC9D,KAAK,OAAO,IAAK,GAAG,CACtB,CAEA,OAAO,QAAU,CACf,kBACA,IACF","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/core/tree.js"],"sourcesContent":["'use strict'\n\nconst {\n  wellknownHeaderNames,\n  headerNameLowerCasedRecord\n} = require('./constants')\n\nclass TstNode {\n  /** @type {any} */\n  value = null\n  /** @type {null | TstNode} */\n  left = null\n  /** @type {null | TstNode} */\n  middle = null\n  /** @type {null | TstNode} */\n  right = null\n  /** @type {number} */\n  code\n  /**\n   * @param {string} key\n   * @param {any} value\n   * @param {number} index\n   */\n  constructor (key, value, index) {\n    if (index === undefined || index >= key.length) {\n      throw new TypeError('Unreachable')\n    }\n    const code = this.code = key.charCodeAt(index)\n    // check code is ascii string\n    if (code > 0x7F) {\n      throw new TypeError('key must be ascii string')\n    }\n    if (key.length !== ++index) {\n      this.middle = new TstNode(key, value, index)\n    } else {\n      this.value = value\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   */\n  add (key, value) {\n    const length = key.length\n    if (length === 0) {\n      throw new TypeError('Unreachable')\n    }\n    let index = 0\n    let node = this\n    while (true) {\n      const code = key.charCodeAt(index)\n      // check code is ascii string\n      if (code > 0x7F) {\n        throw new TypeError('key must be ascii string')\n      }\n      if (node.code === code) {\n        if (length === ++index) {\n          node.value = value\n          break\n        } else if (node.middle !== null) {\n          node = node.middle\n        } else {\n          node.middle = new TstNode(key, value, index)\n          break\n        }\n      } else if (node.code < code) {\n        if (node.left !== null) {\n          node = node.left\n        } else {\n          node.left = new TstNode(key, value, index)\n          break\n        }\n      } else if (node.right !== null) {\n        node = node.right\n      } else {\n        node.right = new TstNode(key, value, index)\n        break\n      }\n    }\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @return {TstNode | null}\n   */\n  search (key) {\n    const keylength = key.length\n    let index = 0\n    let node = this\n    while (node !== null && index < keylength) {\n      let code = key[index]\n      // A-Z\n      // First check if it is bigger than 0x5a.\n      // Lowercase letters have higher char codes than uppercase ones.\n      // Also we assume that headers will mostly contain lowercase characters.\n      if (code <= 0x5a && code >= 0x41) {\n        // Lowercase for uppercase.\n        code |= 32\n      }\n      while (node !== null) {\n        if (code === node.code) {\n          if (keylength === ++index) {\n            // Returns Node since it is the last key.\n            return node\n          }\n          node = node.middle\n          break\n        }\n        node = node.code < code ? node.left : node.right\n      }\n    }\n    return null\n  }\n}\n\nclass TernarySearchTree {\n  /** @type {TstNode | null} */\n  node = null\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   * */\n  insert (key, value) {\n    if (this.node === null) {\n      this.node = new TstNode(key, value, 0)\n    } else {\n      this.node.add(key, value)\n    }\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @return {any}\n   */\n  lookup (key) {\n    return this.node?.search(key)?.value ?? null\n  }\n}\n\nconst tree = new TernarySearchTree()\n\nfor (let i = 0; i < wellknownHeaderNames.length; ++i) {\n  const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]]\n  tree.insert(key, key)\n}\n\nmodule.exports = {\n  TernarySearchTree,\n  tree\n}\n"]}}