{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const assert=require(\"node:assert\");const encoder=new TextEncoder;const HTTP_TOKEN_CODEPOINTS=/^[!#$%&'*+\\-.^_|~A-Za-z0-9]+$/;const HTTP_WHITESPACE_REGEX=/[\\u000A\\u000D\\u0009\\u0020]/;const ASCII_WHITESPACE_REPLACE_REGEX=/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g;const HTTP_QUOTED_STRING_TOKENS=/^[\\u0009\\u0020-\\u007E\\u0080-\\u00FF]+$/;function dataURLProcessor(dataURL){assert(dataURL.protocol===\"data:\");let input=URLSerializer(dataURL,true);input=input.slice(5);const position={position:0};let mimeType=collectASequenceOfCodePointsFast(\",\",input,position);const mimeTypeLength=mimeType.length;mimeType=removeASCIIWhitespace(mimeType,true,true);if(position.position>=input.length){return\"failure\"}position.position++;const encodedBody=input.slice(mimeTypeLength+1);let body=stringPercentDecode(encodedBody);if(/;(\\u0020){0,}base64$/i.test(mimeType)){const stringBody=isomorphicDecode(body);body=forgivingBase64(stringBody);if(body===\"failure\"){return\"failure\"}mimeType=mimeType.slice(0,-6);mimeType=mimeType.replace(/(\\u0020)+$/,\"\");mimeType=mimeType.slice(0,-1)}if(mimeType.startsWith(\";\")){mimeType=\"text/plain\"+mimeType}let mimeTypeRecord=parseMIMEType(mimeType);if(mimeTypeRecord===\"failure\"){mimeTypeRecord=parseMIMEType(\"text/plain;charset=US-ASCII\")}return{mimeType:mimeTypeRecord,body}}__name(dataURLProcessor,\"dataURLProcessor\");function URLSerializer(url,excludeFragment=false){if(!excludeFragment){return url.href}const href=url.href;const hashLength=url.hash.length;const serialized=hashLength===0?href:href.substring(0,href.length-hashLength);if(!hashLength&&href.endsWith(\"#\")){return serialized.slice(0,-1)}return serialized}__name(URLSerializer,\"URLSerializer\");function collectASequenceOfCodePoints(condition,input,position){let result=\"\";while(position.position<input.length&&condition(input[position.position])){result+=input[position.position];position.position++}return result}__name(collectASequenceOfCodePoints,\"collectASequenceOfCodePoints\");function collectASequenceOfCodePointsFast(char,input,position){const idx=input.indexOf(char,position.position);const start=position.position;if(idx===-1){position.position=input.length;return input.slice(start)}position.position=idx;return input.slice(start,position.position)}__name(collectASequenceOfCodePointsFast,\"collectASequenceOfCodePointsFast\");function stringPercentDecode(input){const bytes=encoder.encode(input);return percentDecode(bytes)}__name(stringPercentDecode,\"stringPercentDecode\");function isHexCharByte(byte){return byte>=48&&byte<=57||byte>=65&&byte<=70||byte>=97&&byte<=102}__name(isHexCharByte,\"isHexCharByte\");function hexByteToNumber(byte){return byte>=48&&byte<=57?byte-48:(byte&223)-55}__name(hexByteToNumber,\"hexByteToNumber\");function percentDecode(input){const length=input.length;const output=new Uint8Array(length);let j=0;for(let i=0;i<length;++i){const byte=input[i];if(byte!==37){output[j++]=byte}else if(byte===37&&!(isHexCharByte(input[i+1])&&isHexCharByte(input[i+2]))){output[j++]=37}else{output[j++]=hexByteToNumber(input[i+1])<<4|hexByteToNumber(input[i+2]);i+=2}}return length===j?output:output.subarray(0,j)}__name(percentDecode,\"percentDecode\");function parseMIMEType(input){input=removeHTTPWhitespace(input,true,true);const position={position:0};const type=collectASequenceOfCodePointsFast(\"/\",input,position);if(type.length===0||!HTTP_TOKEN_CODEPOINTS.test(type)){return\"failure\"}if(position.position>input.length){return\"failure\"}position.position++;let subtype=collectASequenceOfCodePointsFast(\";\",input,position);subtype=removeHTTPWhitespace(subtype,false,true);if(subtype.length===0||!HTTP_TOKEN_CODEPOINTS.test(subtype)){return\"failure\"}const typeLowercase=type.toLowerCase();const subtypeLowercase=subtype.toLowerCase();const mimeType={type:typeLowercase,subtype:subtypeLowercase,parameters:new Map,essence:`${typeLowercase}/${subtypeLowercase}`};while(position.position<input.length){position.position++;collectASequenceOfCodePoints(char=>HTTP_WHITESPACE_REGEX.test(char),input,position);let parameterName=collectASequenceOfCodePoints(char=>char!==\";\"&&char!==\"=\",input,position);parameterName=parameterName.toLowerCase();if(position.position<input.length){if(input[position.position]===\";\"){continue}position.position++}if(position.position>input.length){break}let parameterValue=null;if(input[position.position]==='\"'){parameterValue=collectAnHTTPQuotedString(input,position,true);collectASequenceOfCodePointsFast(\";\",input,position)}else{parameterValue=collectASequenceOfCodePointsFast(\";\",input,position);parameterValue=removeHTTPWhitespace(parameterValue,false,true);if(parameterValue.length===0){continue}}if(parameterName.length!==0&&HTTP_TOKEN_CODEPOINTS.test(parameterName)&&(parameterValue.length===0||HTTP_QUOTED_STRING_TOKENS.test(parameterValue))&&!mimeType.parameters.has(parameterName)){mimeType.parameters.set(parameterName,parameterValue)}}return mimeType}__name(parseMIMEType,\"parseMIMEType\");function forgivingBase64(data){data=data.replace(ASCII_WHITESPACE_REPLACE_REGEX,\"\");let dataLength=data.length;if(dataLength%4===0){if(data.charCodeAt(dataLength-1)===61){--dataLength;if(data.charCodeAt(dataLength-1)===61){--dataLength}}}if(dataLength%4===1){return\"failure\"}if(/[^+/0-9A-Za-z]/.test(data.length===dataLength?data:data.substring(0,dataLength))){return\"failure\"}const buffer=Buffer.from(data,\"base64\");return new Uint8Array(buffer.buffer,buffer.byteOffset,buffer.byteLength)}__name(forgivingBase64,\"forgivingBase64\");function collectAnHTTPQuotedString(input,position,extractValue){const positionStart=position.position;let value=\"\";assert(input[position.position]==='\"');position.position++;while(true){value+=collectASequenceOfCodePoints(char=>char!=='\"'&&char!==\"\\\\\",input,position);if(position.position>=input.length){break}const quoteOrBackslash=input[position.position];position.position++;if(quoteOrBackslash===\"\\\\\"){if(position.position>=input.length){value+=\"\\\\\";break}value+=input[position.position];position.position++}else{assert(quoteOrBackslash==='\"');break}}if(extractValue){return value}return input.slice(positionStart,position.position)}__name(collectAnHTTPQuotedString,\"collectAnHTTPQuotedString\");function serializeAMimeType(mimeType){assert(mimeType!==\"failure\");const{parameters,essence}=mimeType;let serialization=essence;for(let[name,value]of parameters.entries()){serialization+=\";\";serialization+=name;serialization+=\"=\";if(!HTTP_TOKEN_CODEPOINTS.test(value)){value=value.replace(/(\\\\|\")/g,\"\\\\$1\");value='\"'+value;value+='\"'}serialization+=value}return serialization}__name(serializeAMimeType,\"serializeAMimeType\");function isHTTPWhiteSpace(char){return char===13||char===10||char===9||char===32}__name(isHTTPWhiteSpace,\"isHTTPWhiteSpace\");function removeHTTPWhitespace(str,leading=true,trailing=true){return removeChars(str,leading,trailing,isHTTPWhiteSpace)}__name(removeHTTPWhitespace,\"removeHTTPWhitespace\");function isASCIIWhitespace(char){return char===13||char===10||char===9||char===12||char===32}__name(isASCIIWhitespace,\"isASCIIWhitespace\");function removeASCIIWhitespace(str,leading=true,trailing=true){return removeChars(str,leading,trailing,isASCIIWhitespace)}__name(removeASCIIWhitespace,\"removeASCIIWhitespace\");function removeChars(str,leading,trailing,predicate){let lead=0;let trail=str.length-1;if(leading){while(lead<str.length&&predicate(str.charCodeAt(lead)))lead++}if(trailing){while(trail>0&&predicate(str.charCodeAt(trail)))trail--}return lead===0&&trail===str.length-1?str:str.slice(lead,trail+1)}__name(removeChars,\"removeChars\");function isomorphicDecode(input){const length=input.length;if((2<<15)-1>length){return String.fromCharCode.apply(null,input)}let result=\"\";let i=0;let addition=(2<<15)-1;while(i<length){if(i+addition>length){addition=length-i}result+=String.fromCharCode.apply(null,input.subarray(i,i+=addition))}return result}__name(isomorphicDecode,\"isomorphicDecode\");function minimizeSupportedMimeType(mimeType){switch(mimeType.essence){case\"application/ecmascript\":case\"application/javascript\":case\"application/x-ecmascript\":case\"application/x-javascript\":case\"text/ecmascript\":case\"text/javascript\":case\"text/javascript1.0\":case\"text/javascript1.1\":case\"text/javascript1.2\":case\"text/javascript1.3\":case\"text/javascript1.4\":case\"text/javascript1.5\":case\"text/jscript\":case\"text/livescript\":case\"text/x-ecmascript\":case\"text/x-javascript\":return\"text/javascript\";case\"application/json\":case\"text/json\":return\"application/json\";case\"image/svg+xml\":return\"image/svg+xml\";case\"text/xml\":case\"application/xml\":return\"application/xml\"}if(mimeType.subtype.endsWith(\"+json\")){return\"application/json\"}if(mimeType.subtype.endsWith(\"+xml\")){return\"application/xml\"}return\"\"}__name(minimizeSupportedMimeType,\"minimizeSupportedMimeType\");module.exports={dataURLProcessor,URLSerializer,collectASequenceOfCodePoints,collectASequenceOfCodePointsFast,stringPercentDecode,parseMIMEType,collectAnHTTPQuotedString,serializeAMimeType,removeChars,removeHTTPWhitespace,minimizeSupportedMimeType,HTTP_TOKEN_CODEPOINTS,isomorphicDecode};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/fetch/data-url.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\n\nconst encoder = new TextEncoder()\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */\nconst HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\\-.^_|~A-Za-z0-9]+$/\nconst HTTP_WHITESPACE_REGEX = /[\\u000A\\u000D\\u0009\\u0020]/ // eslint-disable-line\nconst ASCII_WHITESPACE_REPLACE_REGEX = /[\\u0009\\u000A\\u000C\\u000D\\u0020]/g // eslint-disable-line\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */\nconst HTTP_QUOTED_STRING_TOKENS = /^[\\u0009\\u0020-\\u007E\\u0080-\\u00FF]+$/ // eslint-disable-line\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor (dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:')\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true)\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5)\n\n  // 4. Let position point at the start of input.\n  const position = { position: 0 }\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePointsFast(\n    ',',\n    input,\n    position\n  )\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length\n  mimeType = removeASCIIWhitespace(mimeType, true, true)\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 8. Advance position by 1.\n  position.position++\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1)\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  let body = stringPercentDecode(encodedBody)\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = isomorphicDecode(body)\n\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody)\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure'\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6)\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '')\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1)\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType)\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return { mimeType: mimeTypeRecord, body }\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer (url, excludeFragment = false) {\n  if (!excludeFragment) {\n    return url.href\n  }\n\n  const href = url.href\n  const hashLength = url.hash.length\n\n  const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength)\n\n  if (!hashLength && href.endsWith('#')) {\n    return serialized.slice(0, -1)\n  }\n\n  return serialized\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints (condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''\n\n  // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]\n\n    // 2. Advance position by 1.\n    position.position++\n  }\n\n  // 3. Return result.\n  return result\n}\n\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePointsFast (char, input, position) {\n  const idx = input.indexOf(char, position.position)\n  const start = position.position\n\n  if (idx === -1) {\n    position.position = input.length\n    return input.slice(start)\n  }\n\n  position.position = idx\n  return input.slice(start, position.position)\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode (input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input)\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes)\n}\n\n/**\n * @param {number} byte\n */\nfunction isHexCharByte (byte) {\n  // 0-9 A-F a-f\n  return (byte >= 0x30 && byte <= 0x39) || (byte >= 0x41 && byte <= 0x46) || (byte >= 0x61 && byte <= 0x66)\n}\n\n/**\n * @param {number} byte\n */\nfunction hexByteToNumber (byte) {\n  return (\n    // 0-9\n    byte >= 0x30 && byte <= 0x39\n      ? (byte - 48)\n    // Convert to uppercase\n    // ((byte & 0xDF) - 65) + 10\n      : ((byte & 0xDF) - 55)\n  )\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode (input) {\n  const length = input.length\n  // 1. Let output be an empty byte sequence.\n  /** @type {Uint8Array} */\n  const output = new Uint8Array(length)\n  let j = 0\n  // 2. For each byte byte in input:\n  for (let i = 0; i < length; ++i) {\n    const byte = input[i]\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output[j++] = byte\n\n    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    } else if (\n      byte === 0x25 &&\n      !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))\n    ) {\n      output[j++] = 0x25\n\n    // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      // 2. Append a byte whose value is bytePoint to output.\n      output[j++] = (hexByteToNumber(input[i + 1]) << 4) | hexByteToNumber(input[i + 2])\n\n      // 3. Skip the next two bytes in input.\n      i += 2\n    }\n  }\n\n  // 3. Return output.\n  return length === j ? output : output.subarray(0, j)\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType (input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = removeHTTPWhitespace(input, true, true)\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePointsFast(\n    '/',\n    input,\n    position\n  )\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n    return 'failure'\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position > input.length) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePointsFast(\n    ';',\n    input,\n    position\n  )\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = removeHTTPWhitespace(subtype, false, true)\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n    return 'failure'\n  }\n\n  const typeLowercase = type.toLowerCase()\n  const subtypeLowercase = subtype.toLowerCase()\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: typeLowercase,\n    subtype: subtypeLowercase,\n    /** @type {Map<string, string>} */\n    parameters: new Map(),\n    // https://mimesniff.spec.whatwg.org/#mime-type-essence\n    essence: `${typeLowercase}/${subtypeLowercase}`\n  }\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n      // https://fetch.spec.whatwg.org/#http-whitespace\n      char => HTTP_WHITESPACE_REGEX.test(char),\n      input,\n      position\n    )\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(\n      (char) => char !== ';' && char !== '=',\n      input,\n      position\n    )\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase()\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position > input.length) {\n      break\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true)\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n    // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      parameterValue = removeHTTPWhitespace(parameterValue, false, true)\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n    if (\n      parameterName.length !== 0 &&\n      HTTP_TOKEN_CODEPOINTS.test(parameterName) &&\n      (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&\n      !mimeType.parameters.has(parameterName)\n    ) {\n      mimeType.parameters.set(parameterName, parameterValue)\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64 (data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, '')  // eslint-disable-line\n\n  let dataLength = data.length\n  // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n  if (dataLength % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    if (data.charCodeAt(dataLength - 1) === 0x003D) {\n      --dataLength\n      if (data.charCodeAt(dataLength - 1) === 0x003D) {\n        --dataLength\n      }\n    }\n  }\n\n  // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (dataLength % 4 === 1) {\n    return 'failure'\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {\n    return 'failure'\n  }\n\n  const buffer = Buffer.from(data, 'base64')\n  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\nfunction collectAnHTTPQuotedString (input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position\n\n  // 2. Let value be the empty string.\n  let value = ''\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"')\n\n  // 4. Advance position by 1.\n  position.position++\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== '\\\\',\n      input,\n      position\n    )\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position]\n\n    // 4. Advance position by 1.\n    position.position++\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\'\n        break\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position]\n\n      // 3. Advance position by 1.\n      position.position++\n\n    // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"')\n\n      // 2. Break.\n      break\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position)\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType (mimeType) {\n  assert(mimeType !== 'failure')\n  const { parameters, essence } = mimeType\n\n  // 1. Let serialization be the concatenation of mimeType’s\n  //    type, U+002F (/), and mimeType’s subtype.\n  let serialization = essence\n\n  // 2. For each name → value of mimeType’s parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';'\n\n    // 2. Append name to serialization.\n    serialization += name\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '='\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n      // 1. Precede each occurrence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1')\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"'\n    }\n\n    // 5. Append value to serialization.\n    serialization += value\n  }\n\n  // 3. Return serialization.\n  return serialization\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {number} char\n */\nfunction isHTTPWhiteSpace (char) {\n  // \"\\r\\n\\t \"\n  return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x020\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */\nfunction removeHTTPWhitespace (str, leading = true, trailing = true) {\n  return removeChars(str, leading, trailing, isHTTPWhiteSpace)\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {number} char\n */\nfunction isASCIIWhitespace (char) {\n  // \"\\r\\n\\t\\f \"\n  return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x00c || char === 0x020\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */\nfunction removeASCIIWhitespace (str, leading = true, trailing = true) {\n  return removeChars(str, leading, trailing, isASCIIWhitespace)\n}\n\n/**\n * @param {string} str\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns\n */\nfunction removeChars (str, leading, trailing, predicate) {\n  let lead = 0\n  let trail = str.length - 1\n\n  if (leading) {\n    while (lead < str.length && predicate(str.charCodeAt(lead))) lead++\n  }\n\n  if (trailing) {\n    while (trail > 0 && predicate(str.charCodeAt(trail))) trail--\n  }\n\n  return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1)\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {Uint8Array} input\n * @returns {string}\n */\nfunction isomorphicDecode (input) {\n  // 1. To isomorphic decode a byte sequence input, return a string whose code point\n  //    length is equal to input’s length and whose code points have the same values\n  //    as the values of input’s bytes, in the same order.\n  const length = input.length\n  if ((2 << 15) - 1 > length) {\n    return String.fromCharCode.apply(null, input)\n  }\n  let result = ''; let i = 0\n  let addition = (2 << 15) - 1\n  while (i < length) {\n    if (i + addition > length) {\n      addition = length - i\n    }\n    result += String.fromCharCode.apply(null, input.subarray(i, i += addition))\n  }\n  return result\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#minimize-a-supported-mime-type\n * @param {Exclude<ReturnType<typeof parseMIMEType>, 'failure'>} mimeType\n */\nfunction minimizeSupportedMimeType (mimeType) {\n  switch (mimeType.essence) {\n    case 'application/ecmascript':\n    case 'application/javascript':\n    case 'application/x-ecmascript':\n    case 'application/x-javascript':\n    case 'text/ecmascript':\n    case 'text/javascript':\n    case 'text/javascript1.0':\n    case 'text/javascript1.1':\n    case 'text/javascript1.2':\n    case 'text/javascript1.3':\n    case 'text/javascript1.4':\n    case 'text/javascript1.5':\n    case 'text/jscript':\n    case 'text/livescript':\n    case 'text/x-ecmascript':\n    case 'text/x-javascript':\n      // 1. If mimeType is a JavaScript MIME type, then return \"text/javascript\".\n      return 'text/javascript'\n    case 'application/json':\n    case 'text/json':\n      // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n      return 'application/json'\n    case 'image/svg+xml':\n      // 3. If mimeType’s essence is \"image/svg+xml\", then return \"image/svg+xml\".\n      return 'image/svg+xml'\n    case 'text/xml':\n    case 'application/xml':\n      // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n      return 'application/xml'\n  }\n\n  // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n  if (mimeType.subtype.endsWith('+json')) {\n    return 'application/json'\n  }\n\n  // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n  if (mimeType.subtype.endsWith('+xml')) {\n    return 'application/xml'\n  }\n\n  // 5. If mimeType is supported by the user agent, then return mimeType’s essence.\n  // Technically, node doesn't support any mimetypes.\n\n  // 6. Return the empty string.\n  return ''\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  collectASequenceOfCodePointsFast,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType,\n  removeChars,\n  removeHTTPWhitespace,\n  minimizeSupportedMimeType,\n  HTTP_TOKEN_CODEPOINTS,\n  isomorphicDecode\n}\n"]}}