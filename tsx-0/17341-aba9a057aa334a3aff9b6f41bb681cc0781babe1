{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});exports.ParserStream=void 0;const node_stream_1=require(\"node:stream\");const parse5_1=require(\"parse5\");class ParserStream extends node_stream_1.Writable{static{__name(this,\"ParserStream\")}static getFragmentStream(fragmentContext,options){const parser=parse5_1.Parser.getFragmentParser(fragmentContext,options);const stream=new ParserStream(options,parser);return stream}get document(){return this.parser.document}getFragment(){return this.parser.getFragment()}constructor(options,parser=new parse5_1.Parser(options)){super({decodeStrings:false});this.parser=parser;this.lastChunkWritten=false;this.writeCallback=void 0;this.pendingHtmlInsertions=[];const resume=__name(()=>{for(let i=this.pendingHtmlInsertions.length-1;i>=0;i--){this.parser.tokenizer.insertHtmlAtCurrentPos(this.pendingHtmlInsertions[i])}this.pendingHtmlInsertions.length=0;this.parser.tokenizer.resume(this.writeCallback)},\"resume\");const documentWrite=__name(html=>{if(!this.parser.stopped){this.pendingHtmlInsertions.push(html)}},\"documentWrite\");const scriptHandler=__name(scriptElement=>{if(this.listenerCount(\"script\")>0){this.parser.tokenizer.pause();this.emit(\"script\",scriptElement,documentWrite,resume)}},\"scriptHandler\");this.parser.scriptHandler=scriptHandler}_write(chunk,_encoding,callback){if(typeof chunk!==\"string\"){throw new TypeError(\"Parser can work only with string streams.\")}this.writeCallback=callback;this.parser.tokenizer.write(chunk,this.lastChunkWritten,this.writeCallback)}end(chunk,encoding,callback){this.lastChunkWritten=true;super.end(chunk||\"\",encoding,callback)}}exports.ParserStream=ParserStream;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CAAE,MAAO,IAAK,CAAC,EAC5D,QAAQ,aAAe,OACvB,MAAM,cAAgB,QAAQ,aAAa,EAC3C,MAAM,SAAW,QAAQ,QAAQ,EA0BjC,MAAM,qBAAqB,cAAc,QAAS,CA9BlD,MA8BkD,6BAC9C,OAAO,kBAAkB,gBAAiB,QAAS,CAC/C,MAAM,OAAS,SAAS,OAAO,kBAAkB,gBAAiB,OAAO,EACzE,MAAM,OAAS,IAAI,aAAa,QAAS,MAAM,EAC/C,OAAO,MACX,CAEA,IAAI,UAAW,CACX,OAAO,KAAK,OAAO,QACvB,CACA,aAAc,CACV,OAAO,KAAK,OAAO,YAAY,CACnC,CAIA,YAAY,QAAS,OAAS,IAAI,SAAS,OAAO,OAAO,EAAG,CACxD,MAAM,CAAE,cAAe,KAAM,CAAC,EAC9B,KAAK,OAAS,OACd,KAAK,iBAAmB,MACxB,KAAK,cAAgB,OACrB,KAAK,sBAAwB,CAAC,EAC9B,MAAM,OAAS,WAAM,CACjB,QAAS,EAAI,KAAK,sBAAsB,OAAS,EAAG,GAAK,EAAG,IAAK,CAC7D,KAAK,OAAO,UAAU,uBAAuB,KAAK,sBAAsB,CAAC,CAAC,CAC9E,CACA,KAAK,sBAAsB,OAAS,EAEpC,KAAK,OAAO,UAAU,OAAO,KAAK,aAAa,CACnD,EAPe,UAQf,MAAM,cAAgB,OAAC,MAAS,CAC5B,GAAI,CAAC,KAAK,OAAO,QAAS,CACtB,KAAK,sBAAsB,KAAK,IAAI,CACxC,CACJ,EAJsB,iBAKtB,MAAM,cAAgB,OAAC,eAAkB,CACrC,GAAI,KAAK,cAAc,QAAQ,EAAI,EAAG,CAClC,KAAK,OAAO,UAAU,MAAM,EAC5B,KAAK,KAAK,SAAU,cAAe,cAAe,MAAM,CAC5D,CACJ,EALsB,iBAMtB,KAAK,OAAO,cAAgB,aAChC,CAEA,OAAO,MAAO,UAAW,SAAU,CAC/B,GAAI,OAAO,QAAU,SAAU,CAC3B,MAAM,IAAI,UAAU,2CAA2C,CACnE,CACA,KAAK,cAAgB,SACrB,KAAK,OAAO,UAAU,MAAM,MAAO,KAAK,iBAAkB,KAAK,aAAa,CAChF,CAGA,IAAI,MAAO,SAAU,SAAU,CAC3B,KAAK,iBAAmB,KACxB,MAAM,IAAI,OAAS,GAAI,SAAU,QAAQ,CAC7C,CACJ,CACA,QAAQ,aAAe","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/parse5-parser-stream@7.1.2/node_modules/parse5-parser-stream/dist/cjs/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParserStream = void 0;\nconst node_stream_1 = require(\"node:stream\");\nconst parse5_1 = require(\"parse5\");\n/* eslint-disable unicorn/consistent-function-scoping -- The rule seems to be broken here. */\n/**\n * Streaming HTML parser with scripting support.\n * A [writable stream](https://nodejs.org/api/stream.html#stream_class_stream_writable).\n *\n * @example\n *\n * ```js\n * const ParserStream = require('parse5-parser-stream');\n * const http = require('http');\n * const { finished } = require('node:stream');\n *\n * // Fetch the page content and obtain it's <head> node\n * http.get('http://inikulin.github.io/parse5/', res => {\n *     const parser = new ParserStream();\n *\n *     finished(parser, () => {\n *         console.log(parser.document.childNodes[1].childNodes[0].tagName); //> 'head'\n *     });\n *\n *     res.pipe(parser);\n * });\n * ```\n *\n */\nclass ParserStream extends node_stream_1.Writable {\n    static getFragmentStream(fragmentContext, options) {\n        const parser = parse5_1.Parser.getFragmentParser(fragmentContext, options);\n        const stream = new ParserStream(options, parser);\n        return stream;\n    }\n    /** The resulting document node. */\n    get document() {\n        return this.parser.document;\n    }\n    getFragment() {\n        return this.parser.getFragment();\n    }\n    /**\n     * @param options Parsing options.\n     */\n    constructor(options, parser = new parse5_1.Parser(options)) {\n        super({ decodeStrings: false });\n        this.parser = parser;\n        this.lastChunkWritten = false;\n        this.writeCallback = undefined;\n        this.pendingHtmlInsertions = [];\n        const resume = () => {\n            for (let i = this.pendingHtmlInsertions.length - 1; i >= 0; i--) {\n                this.parser.tokenizer.insertHtmlAtCurrentPos(this.pendingHtmlInsertions[i]);\n            }\n            this.pendingHtmlInsertions.length = 0;\n            //NOTE: keep parsing if we don't wait for the next input chunk\n            this.parser.tokenizer.resume(this.writeCallback);\n        };\n        const documentWrite = (html) => {\n            if (!this.parser.stopped) {\n                this.pendingHtmlInsertions.push(html);\n            }\n        };\n        const scriptHandler = (scriptElement) => {\n            if (this.listenerCount('script') > 0) {\n                this.parser.tokenizer.pause();\n                this.emit('script', scriptElement, documentWrite, resume);\n            }\n        };\n        this.parser.scriptHandler = scriptHandler;\n    }\n    //WritableStream implementation\n    _write(chunk, _encoding, callback) {\n        if (typeof chunk !== 'string') {\n            throw new TypeError('Parser can work only with string streams.');\n        }\n        this.writeCallback = callback;\n        this.parser.tokenizer.write(chunk, this.lastChunkWritten, this.writeCallback);\n    }\n    // TODO [engine:node@>=16]: Due to issues with Node < 16, we are overriding `end` instead of `_final`.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(chunk, encoding, callback) {\n        this.lastChunkWritten = true;\n        super.end(chunk || '', encoding, callback);\n    }\n}\nexports.ParserStream = ParserStream;\n//# sourceMappingURL=index.js.map"]}}