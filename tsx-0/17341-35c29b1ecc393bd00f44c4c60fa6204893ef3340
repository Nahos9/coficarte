{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{BalancedPoolMissingUpstreamError,InvalidArgumentError}=require(\"../core/errors\");const{PoolBase,kClients,kNeedDrain,kAddClient,kRemoveClient,kGetDispatcher}=require(\"./pool-base\");const Pool=require(\"./pool\");const{kUrl,kInterceptors}=require(\"../core/symbols\");const{parseOrigin}=require(\"../core/util\");const kFactory=Symbol(\"factory\");const kOptions=Symbol(\"options\");const kGreatestCommonDivisor=Symbol(\"kGreatestCommonDivisor\");const kCurrentWeight=Symbol(\"kCurrentWeight\");const kIndex=Symbol(\"kIndex\");const kWeight=Symbol(\"kWeight\");const kMaxWeightPerServer=Symbol(\"kMaxWeightPerServer\");const kErrorPenalty=Symbol(\"kErrorPenalty\");function getGreatestCommonDivisor(a,b){if(a===0)return b;while(b!==0){const t=b;b=a%b;a=t}return a}__name(getGreatestCommonDivisor,\"getGreatestCommonDivisor\");function defaultFactory(origin,opts){return new Pool(origin,opts)}__name(defaultFactory,\"defaultFactory\");class BalancedPool extends PoolBase{static{__name(this,\"BalancedPool\")}constructor(upstreams=[],{factory=defaultFactory,...opts}={}){super();this[kOptions]=opts;this[kIndex]=-1;this[kCurrentWeight]=0;this[kMaxWeightPerServer]=this[kOptions].maxWeightPerServer||100;this[kErrorPenalty]=this[kOptions].errorPenalty||15;if(!Array.isArray(upstreams)){upstreams=[upstreams]}if(typeof factory!==\"function\"){throw new InvalidArgumentError(\"factory must be a function.\")}this[kInterceptors]=opts.interceptors?.BalancedPool&&Array.isArray(opts.interceptors.BalancedPool)?opts.interceptors.BalancedPool:[];this[kFactory]=factory;for(const upstream of upstreams){this.addUpstream(upstream)}this._updateBalancedPoolStats()}addUpstream(upstream){const upstreamOrigin=parseOrigin(upstream).origin;if(this[kClients].find(pool2=>pool2[kUrl].origin===upstreamOrigin&&pool2.closed!==true&&pool2.destroyed!==true)){return this}const pool=this[kFactory](upstreamOrigin,Object.assign({},this[kOptions]));this[kAddClient](pool);pool.on(\"connect\",()=>{pool[kWeight]=Math.min(this[kMaxWeightPerServer],pool[kWeight]+this[kErrorPenalty])});pool.on(\"connectionError\",()=>{pool[kWeight]=Math.max(1,pool[kWeight]-this[kErrorPenalty]);this._updateBalancedPoolStats()});pool.on(\"disconnect\",(...args)=>{const err=args[2];if(err&&err.code===\"UND_ERR_SOCKET\"){pool[kWeight]=Math.max(1,pool[kWeight]-this[kErrorPenalty]);this._updateBalancedPoolStats()}});for(const client of this[kClients]){client[kWeight]=this[kMaxWeightPerServer]}this._updateBalancedPoolStats();return this}_updateBalancedPoolStats(){let result=0;for(let i=0;i<this[kClients].length;i++){result=getGreatestCommonDivisor(this[kClients][i][kWeight],result)}this[kGreatestCommonDivisor]=result}removeUpstream(upstream){const upstreamOrigin=parseOrigin(upstream).origin;const pool=this[kClients].find(pool2=>pool2[kUrl].origin===upstreamOrigin&&pool2.closed!==true&&pool2.destroyed!==true);if(pool){this[kRemoveClient](pool)}return this}get upstreams(){return this[kClients].filter(dispatcher=>dispatcher.closed!==true&&dispatcher.destroyed!==true).map(p=>p[kUrl].origin)}[kGetDispatcher](){if(this[kClients].length===0){throw new BalancedPoolMissingUpstreamError}const dispatcher=this[kClients].find(dispatcher2=>!dispatcher2[kNeedDrain]&&dispatcher2.closed!==true&&dispatcher2.destroyed!==true);if(!dispatcher){return}const allClientsBusy=this[kClients].map(pool=>pool[kNeedDrain]).reduce((a,b)=>a&&b,true);if(allClientsBusy){return}let counter=0;let maxWeightIndex=this[kClients].findIndex(pool=>!pool[kNeedDrain]);while(counter++<this[kClients].length){this[kIndex]=(this[kIndex]+1)%this[kClients].length;const pool=this[kClients][this[kIndex]];if(pool[kWeight]>this[kClients][maxWeightIndex][kWeight]&&!pool[kNeedDrain]){maxWeightIndex=this[kIndex]}if(this[kIndex]===0){this[kCurrentWeight]=this[kCurrentWeight]-this[kGreatestCommonDivisor];if(this[kCurrentWeight]<=0){this[kCurrentWeight]=this[kMaxWeightPerServer]}}if(pool[kWeight]>=this[kCurrentWeight]&&!pool[kNeedDrain]){return pool}}this[kCurrentWeight]=this[kClients][maxWeightIndex][kWeight];this[kIndex]=maxWeightIndex;return this[kClients][maxWeightIndex]}}module.exports=BalancedPool;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["pool","dispatcher"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/dispatcher/balanced-pool.js"],"sourcesContent":["'use strict'\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = require('../core/errors')\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = require('./pool-base')\nconst Pool = require('./pool')\nconst { kUrl, kInterceptors } = require('../core/symbols')\nconst { parseOrigin } = require('../core/util')\nconst kFactory = Symbol('factory')\n\nconst kOptions = Symbol('options')\nconst kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor')\nconst kCurrentWeight = Symbol('kCurrentWeight')\nconst kIndex = Symbol('kIndex')\nconst kWeight = Symbol('kWeight')\nconst kMaxWeightPerServer = Symbol('kMaxWeightPerServer')\nconst kErrorPenalty = Symbol('kErrorPenalty')\n\n/**\n * Calculate the greatest common divisor of two numbers by\n * using the Euclidean algorithm.\n *\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction getGreatestCommonDivisor (a, b) {\n  if (a === 0) return b\n\n  while (b !== 0) {\n    const t = b\n    b = a % b\n    a = t\n  }\n  return a\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nclass BalancedPool extends PoolBase {\n  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {\n    super()\n\n    this[kOptions] = opts\n    this[kIndex] = -1\n    this[kCurrentWeight] = 0\n\n    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100\n    this[kErrorPenalty] = this[kOptions].errorPenalty || 15\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams]\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    this[kInterceptors] = opts.interceptors?.BalancedPool && Array.isArray(opts.interceptors.BalancedPool)\n      ? opts.interceptors.BalancedPool\n      : []\n    this[kFactory] = factory\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream)\n    }\n    this._updateBalancedPoolStats()\n  }\n\n  addUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    if (this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))) {\n      return this\n    }\n    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]))\n\n    this[kAddClient](pool)\n    pool.on('connect', () => {\n      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty])\n    })\n\n    pool.on('connectionError', () => {\n      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n      this._updateBalancedPoolStats()\n    })\n\n    pool.on('disconnect', (...args) => {\n      const err = args[2]\n      if (err && err.code === 'UND_ERR_SOCKET') {\n        // decrease the weight of the pool.\n        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n        this._updateBalancedPoolStats()\n      }\n    })\n\n    for (const client of this[kClients]) {\n      client[kWeight] = this[kMaxWeightPerServer]\n    }\n\n    this._updateBalancedPoolStats()\n\n    return this\n  }\n\n  _updateBalancedPoolStats () {\n    let result = 0\n    for (let i = 0; i < this[kClients].length; i++) {\n      result = getGreatestCommonDivisor(this[kClients][i][kWeight], result)\n    }\n\n    this[kGreatestCommonDivisor] = result\n  }\n\n  removeUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    const pool = this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))\n\n    if (pool) {\n      this[kRemoveClient](pool)\n    }\n\n    return this\n  }\n\n  get upstreams () {\n    return this[kClients]\n      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)\n      .map((p) => p[kUrl].origin)\n  }\n\n  [kGetDispatcher] () {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError()\n    }\n\n    const dispatcher = this[kClients].find(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n\n    if (!dispatcher) {\n      return\n    }\n\n    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true)\n\n    if (allClientsBusy) {\n      return\n    }\n\n    let counter = 0\n\n    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain])\n\n    while (counter++ < this[kClients].length) {\n      this[kIndex] = (this[kIndex] + 1) % this[kClients].length\n      const pool = this[kClients][this[kIndex]]\n\n      // find pool index with the largest weight\n      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n        maxWeightIndex = this[kIndex]\n      }\n\n      // decrease the current weight every `this[kClients].length`.\n      if (this[kIndex] === 0) {\n        // Set the current weight to the next lower weight.\n        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor]\n\n        if (this[kCurrentWeight] <= 0) {\n          this[kCurrentWeight] = this[kMaxWeightPerServer]\n        }\n      }\n      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {\n        return pool\n      }\n    }\n\n    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight]\n    this[kIndex] = maxWeightIndex\n    return this[kClients][maxWeightIndex]\n  }\n}\n\nmodule.exports = BalancedPool\n"]}}