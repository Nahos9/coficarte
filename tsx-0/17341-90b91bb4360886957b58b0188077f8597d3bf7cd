{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{InvalidArgumentError,SocketError}=require(\"../core/errors\");const{AsyncResource}=require(\"node:async_hooks\");const util=require(\"../core/util\");const{addSignal,removeSignal}=require(\"./abort-signal\");const assert=require(\"node:assert\");class UpgradeHandler extends AsyncResource{static{__name(this,\"UpgradeHandler\")}constructor(opts,callback){if(!opts||typeof opts!==\"object\"){throw new InvalidArgumentError(\"invalid opts\")}if(typeof callback!==\"function\"){throw new InvalidArgumentError(\"invalid callback\")}const{signal,opaque,responseHeaders}=opts;if(signal&&typeof signal.on!==\"function\"&&typeof signal.addEventListener!==\"function\"){throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\")}super(\"UNDICI_UPGRADE\");this.responseHeaders=responseHeaders||null;this.opaque=opaque||null;this.callback=callback;this.abort=null;this.context=null;addSignal(this,signal)}onConnect(abort,context){if(this.reason){abort(this.reason);return}assert(this.callback);this.abort=abort;this.context=null}onHeaders(){throw new SocketError(\"bad upgrade\",null)}onUpgrade(statusCode,rawHeaders,socket){assert(statusCode===101);const{callback,opaque,context}=this;removeSignal(this);this.callback=null;const headers=this.responseHeaders===\"raw\"?util.parseRawHeaders(rawHeaders):util.parseHeaders(rawHeaders);this.runInAsyncScope(callback,null,null,{headers,socket,opaque,context})}onError(err){const{callback,opaque}=this;removeSignal(this);if(callback){this.callback=null;queueMicrotask(()=>{this.runInAsyncScope(callback,null,err,{opaque})})}}}function upgrade(opts,callback){if(callback===void 0){return new Promise((resolve,reject)=>{upgrade.call(this,opts,(err,data)=>{return err?reject(err):resolve(data)})})}try{const upgradeHandler=new UpgradeHandler(opts,callback);this.dispatch({...opts,method:opts.method||\"GET\",upgrade:opts.protocol||\"Websocket\"},upgradeHandler)}catch(err){if(typeof callback!==\"function\"){throw err}const opaque=opts?.opaque;queueMicrotask(()=>callback(err,{opaque}))}}__name(upgrade,\"upgrade\");module.exports=upgrade;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAEA,KAAM,CAAE,qBAAsB,WAAY,EAAI,QAAQ,gBAAgB,EACtE,KAAM,CAAE,aAAc,EAAI,QAAQ,kBAAkB,EACpD,MAAM,KAAO,QAAQ,cAAc,EACnC,KAAM,CAAE,UAAW,YAAa,EAAI,QAAQ,gBAAgB,EAC5D,MAAM,OAAS,QAAQ,aAAa,EAEpC,MAAM,uBAAuB,aAAc,CAR3C,MAQ2C,+BACzC,YAAa,KAAM,SAAU,CAC3B,GAAI,CAAC,MAAQ,OAAO,OAAS,SAAU,CACrC,MAAM,IAAI,qBAAqB,cAAc,CAC/C,CAEA,GAAI,OAAO,WAAa,WAAY,CAClC,MAAM,IAAI,qBAAqB,kBAAkB,CACnD,CAEA,KAAM,CAAE,OAAQ,OAAQ,eAAgB,EAAI,KAE5C,GAAI,QAAU,OAAO,OAAO,KAAO,YAAc,OAAO,OAAO,mBAAqB,WAAY,CAC9F,MAAM,IAAI,qBAAqB,+CAA+C,CAChF,CAEA,MAAM,gBAAgB,EAEtB,KAAK,gBAAkB,iBAAmB,KAC1C,KAAK,OAAS,QAAU,KACxB,KAAK,SAAW,SAChB,KAAK,MAAQ,KACb,KAAK,QAAU,KAEf,UAAU,KAAM,MAAM,CACxB,CAEA,UAAW,MAAO,QAAS,CACzB,GAAI,KAAK,OAAQ,CACf,MAAM,KAAK,MAAM,EACjB,MACF,CAEA,OAAO,KAAK,QAAQ,EAEpB,KAAK,MAAQ,MACb,KAAK,QAAU,IACjB,CAEA,WAAa,CACX,MAAM,IAAI,YAAY,cAAe,IAAI,CAC3C,CAEA,UAAW,WAAY,WAAY,OAAQ,CACzC,OAAO,aAAe,GAAG,EAEzB,KAAM,CAAE,SAAU,OAAQ,OAAQ,EAAI,KAEtC,aAAa,IAAI,EAEjB,KAAK,SAAW,KAChB,MAAM,QAAU,KAAK,kBAAoB,MAAQ,KAAK,gBAAgB,UAAU,EAAI,KAAK,aAAa,UAAU,EAChH,KAAK,gBAAgB,SAAU,KAAM,KAAM,CACzC,QACA,OACA,OACA,OACF,CAAC,CACH,CAEA,QAAS,IAAK,CACZ,KAAM,CAAE,SAAU,MAAO,EAAI,KAE7B,aAAa,IAAI,EAEjB,GAAI,SAAU,CACZ,KAAK,SAAW,KAChB,eAAe,IAAM,CACnB,KAAK,gBAAgB,SAAU,KAAM,IAAK,CAAE,MAAO,CAAC,CACtD,CAAC,CACH,CACF,CACF,CAEA,SAAS,QAAS,KAAM,SAAU,CAChC,GAAI,WAAa,OAAW,CAC1B,OAAO,IAAI,QAAQ,CAAC,QAAS,SAAW,CACtC,QAAQ,KAAK,KAAM,KAAM,CAAC,IAAK,OAAS,CACtC,OAAO,IAAM,OAAO,GAAG,EAAI,QAAQ,IAAI,CACzC,CAAC,CACH,CAAC,CACH,CAEA,GAAI,CACF,MAAM,eAAiB,IAAI,eAAe,KAAM,QAAQ,EACxD,KAAK,SAAS,CACZ,GAAG,KACH,OAAQ,KAAK,QAAU,MACvB,QAAS,KAAK,UAAY,WAC5B,EAAG,cAAc,CACnB,OAAS,IAAK,CACZ,GAAI,OAAO,WAAa,WAAY,CAClC,MAAM,GACR,CACA,MAAM,OAAS,MAAM,OACrB,eAAe,IAAM,SAAS,IAAK,CAAE,MAAO,CAAC,CAAC,CAChD,CACF,CAvBS,0BAyBT,OAAO,QAAU","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/api/api-upgrade.js"],"sourcesContent":["'use strict'\n\nconst { InvalidArgumentError, SocketError } = require('../core/errors')\nconst { AsyncResource } = require('node:async_hooks')\nconst util = require('../core/util')\nconst { addSignal, removeSignal } = require('./abort-signal')\nconst assert = require('node:assert')\n\nclass UpgradeHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_UPGRADE')\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n    this.context = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = null\n  }\n\n  onHeaders () {\n    throw new SocketError('bad upgrade', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    assert(statusCode === 101)\n\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    this.runInAsyncScope(callback, null, null, {\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction upgrade (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      upgrade.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const upgradeHandler = new UpgradeHandler(opts, callback)\n    this.dispatch({\n      ...opts,\n      method: opts.method || 'GET',\n      upgrade: opts.protocol || 'Websocket'\n    }, upgradeHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = upgrade\n"]}}