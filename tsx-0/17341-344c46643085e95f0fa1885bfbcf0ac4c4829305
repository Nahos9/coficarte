{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{InvalidArgumentError,NotSupportedError}=require(\"./errors\");const assert=require(\"node:assert\");const{isValidHTTPToken,isValidHeaderValue,isStream,destroy,isBuffer,isFormDataLike,isIterable,isBlobLike,buildURL,validateHandler,getServerName,normalizedMethodRecords}=require(\"./util\");const{channels}=require(\"./diagnostics.js\");const{headerNameLowerCasedRecord}=require(\"./constants\");const invalidPathRegex=/[^\\u0021-\\u00ff]/;const kHandler=Symbol(\"handler\");class Request{static{__name(this,\"Request\")}constructor(origin,{path,method,body,headers,query,idempotent,blocking,upgrade,headersTimeout,bodyTimeout,reset,throwOnError,expectContinue,servername},handler){if(typeof path!==\"string\"){throw new InvalidArgumentError(\"path must be a string\")}else if(path[0]!==\"/\"&&!(path.startsWith(\"http://\")||path.startsWith(\"https://\"))&&method!==\"CONNECT\"){throw new InvalidArgumentError(\"path must be an absolute URL or start with a slash\")}else if(invalidPathRegex.test(path)){throw new InvalidArgumentError(\"invalid request path\")}if(typeof method!==\"string\"){throw new InvalidArgumentError(\"method must be a string\")}else if(normalizedMethodRecords[method]===void 0&&!isValidHTTPToken(method)){throw new InvalidArgumentError(\"invalid request method\")}if(upgrade&&typeof upgrade!==\"string\"){throw new InvalidArgumentError(\"upgrade must be a string\")}if(headersTimeout!=null&&(!Number.isFinite(headersTimeout)||headersTimeout<0)){throw new InvalidArgumentError(\"invalid headersTimeout\")}if(bodyTimeout!=null&&(!Number.isFinite(bodyTimeout)||bodyTimeout<0)){throw new InvalidArgumentError(\"invalid bodyTimeout\")}if(reset!=null&&typeof reset!==\"boolean\"){throw new InvalidArgumentError(\"invalid reset\")}if(expectContinue!=null&&typeof expectContinue!==\"boolean\"){throw new InvalidArgumentError(\"invalid expectContinue\")}this.headersTimeout=headersTimeout;this.bodyTimeout=bodyTimeout;this.throwOnError=throwOnError===true;this.method=method;this.abort=null;if(body==null){this.body=null}else if(isStream(body)){this.body=body;const rState=this.body._readableState;if(!rState||!rState.autoDestroy){this.endHandler=__name(function autoDestroy(){destroy(this)},\"autoDestroy\");this.body.on(\"end\",this.endHandler)}this.errorHandler=err=>{if(this.abort){this.abort(err)}else{this.error=err}};this.body.on(\"error\",this.errorHandler)}else if(isBuffer(body)){this.body=body.byteLength?body:null}else if(ArrayBuffer.isView(body)){this.body=body.buffer.byteLength?Buffer.from(body.buffer,body.byteOffset,body.byteLength):null}else if(body instanceof ArrayBuffer){this.body=body.byteLength?Buffer.from(body):null}else if(typeof body===\"string\"){this.body=body.length?Buffer.from(body):null}else if(isFormDataLike(body)||isIterable(body)||isBlobLike(body)){this.body=body}else{throw new InvalidArgumentError(\"body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable\")}this.completed=false;this.aborted=false;this.upgrade=upgrade||null;this.path=query?buildURL(path,query):path;this.origin=origin;this.idempotent=idempotent==null?method===\"HEAD\"||method===\"GET\":idempotent;this.blocking=blocking==null?false:blocking;this.reset=reset==null?null:reset;this.host=null;this.contentLength=null;this.contentType=null;this.headers=[];this.expectContinue=expectContinue!=null?expectContinue:false;if(Array.isArray(headers)){if(headers.length%2!==0){throw new InvalidArgumentError(\"headers array must be even\")}for(let i=0;i<headers.length;i+=2){processHeader(this,headers[i],headers[i+1])}}else if(headers&&typeof headers===\"object\"){if(headers[Symbol.iterator]){for(const header of headers){if(!Array.isArray(header)||header.length!==2){throw new InvalidArgumentError(\"headers must be in key-value pair format\")}processHeader(this,header[0],header[1])}}else{const keys=Object.keys(headers);for(let i=0;i<keys.length;++i){processHeader(this,keys[i],headers[keys[i]])}}}else if(headers!=null){throw new InvalidArgumentError(\"headers must be an object or an array\")}validateHandler(handler,method,upgrade);this.servername=servername||getServerName(this.host);this[kHandler]=handler;if(channels.create.hasSubscribers){channels.create.publish({request:this})}}onBodySent(chunk){if(this[kHandler].onBodySent){try{return this[kHandler].onBodySent(chunk)}catch(err){this.abort(err)}}}onRequestSent(){if(channels.bodySent.hasSubscribers){channels.bodySent.publish({request:this})}if(this[kHandler].onRequestSent){try{return this[kHandler].onRequestSent()}catch(err){this.abort(err)}}}onConnect(abort){assert(!this.aborted);assert(!this.completed);if(this.error){abort(this.error)}else{this.abort=abort;return this[kHandler].onConnect(abort)}}onResponseStarted(){return this[kHandler].onResponseStarted?.()}onHeaders(statusCode,headers,resume,statusText){assert(!this.aborted);assert(!this.completed);if(channels.headers.hasSubscribers){channels.headers.publish({request:this,response:{statusCode,headers,statusText}})}try{return this[kHandler].onHeaders(statusCode,headers,resume,statusText)}catch(err){this.abort(err)}}onData(chunk){assert(!this.aborted);assert(!this.completed);try{return this[kHandler].onData(chunk)}catch(err){this.abort(err);return false}}onUpgrade(statusCode,headers,socket){assert(!this.aborted);assert(!this.completed);return this[kHandler].onUpgrade(statusCode,headers,socket)}onComplete(trailers){this.onFinally();assert(!this.aborted);this.completed=true;if(channels.trailers.hasSubscribers){channels.trailers.publish({request:this,trailers})}try{return this[kHandler].onComplete(trailers)}catch(err){this.onError(err)}}onError(error){this.onFinally();if(channels.error.hasSubscribers){channels.error.publish({request:this,error})}if(this.aborted){return}this.aborted=true;return this[kHandler].onError(error)}onFinally(){if(this.errorHandler){this.body.off(\"error\",this.errorHandler);this.errorHandler=null}if(this.endHandler){this.body.off(\"end\",this.endHandler);this.endHandler=null}}addHeader(key,value){processHeader(this,key,value);return this}}function processHeader(request,key,val){if(val&&(typeof val===\"object\"&&!Array.isArray(val))){throw new InvalidArgumentError(`invalid ${key} header`)}else if(val===void 0){return}let headerName=headerNameLowerCasedRecord[key];if(headerName===void 0){headerName=key.toLowerCase();if(headerNameLowerCasedRecord[headerName]===void 0&&!isValidHTTPToken(headerName)){throw new InvalidArgumentError(\"invalid header key\")}}if(Array.isArray(val)){const arr=[];for(let i=0;i<val.length;i++){if(typeof val[i]===\"string\"){if(!isValidHeaderValue(val[i])){throw new InvalidArgumentError(`invalid ${key} header`)}arr.push(val[i])}else if(val[i]===null){arr.push(\"\")}else if(typeof val[i]===\"object\"){throw new InvalidArgumentError(`invalid ${key} header`)}else{arr.push(`${val[i]}`)}}val=arr}else if(typeof val===\"string\"){if(!isValidHeaderValue(val)){throw new InvalidArgumentError(`invalid ${key} header`)}}else if(val===null){val=\"\"}else{val=`${val}`}if(request.host===null&&headerName===\"host\"){if(typeof val!==\"string\"){throw new InvalidArgumentError(\"invalid host header\")}request.host=val}else if(request.contentLength===null&&headerName===\"content-length\"){request.contentLength=parseInt(val,10);if(!Number.isFinite(request.contentLength)){throw new InvalidArgumentError(\"invalid content-length header\")}}else if(request.contentType===null&&headerName===\"content-type\"){request.contentType=val;request.headers.push(key,val)}else if(headerName===\"transfer-encoding\"||headerName===\"keep-alive\"||headerName===\"upgrade\"){throw new InvalidArgumentError(`invalid ${headerName} header`)}else if(headerName===\"connection\"){const value=typeof val===\"string\"?val.toLowerCase():null;if(value!==\"close\"&&value!==\"keep-alive\"){throw new InvalidArgumentError(\"invalid connection header\")}if(value===\"close\"){request.reset=true}}else if(headerName===\"expect\"){throw new NotSupportedError(\"expect header not supported\")}else{request.headers.push(key,val)}}__name(processHeader,\"processHeader\");module.exports=Request;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/core/request.js"],"sourcesContent":["'use strict'\n\nconst {\n  InvalidArgumentError,\n  NotSupportedError\n} = require('./errors')\nconst assert = require('node:assert')\nconst {\n  isValidHTTPToken,\n  isValidHeaderValue,\n  isStream,\n  destroy,\n  isBuffer,\n  isFormDataLike,\n  isIterable,\n  isBlobLike,\n  buildURL,\n  validateHandler,\n  getServerName,\n  normalizedMethodRecords\n} = require('./util')\nconst { channels } = require('./diagnostics.js')\nconst { headerNameLowerCasedRecord } = require('./constants')\n\n// Verifies that a given path is valid does not contain control chars \\x00 to \\x20\nconst invalidPathRegex = /[^\\u0021-\\u00ff]/\n\nconst kHandler = Symbol('handler')\n\nclass Request {\n  constructor (origin, {\n    path,\n    method,\n    body,\n    headers,\n    query,\n    idempotent,\n    blocking,\n    upgrade,\n    headersTimeout,\n    bodyTimeout,\n    reset,\n    throwOnError,\n    expectContinue,\n    servername\n  }, handler) {\n    if (typeof path !== 'string') {\n      throw new InvalidArgumentError('path must be a string')\n    } else if (\n      path[0] !== '/' &&\n      !(path.startsWith('http://') || path.startsWith('https://')) &&\n      method !== 'CONNECT'\n    ) {\n      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')\n    } else if (invalidPathRegex.test(path)) {\n      throw new InvalidArgumentError('invalid request path')\n    }\n\n    if (typeof method !== 'string') {\n      throw new InvalidArgumentError('method must be a string')\n    } else if (normalizedMethodRecords[method] === undefined && !isValidHTTPToken(method)) {\n      throw new InvalidArgumentError('invalid request method')\n    }\n\n    if (upgrade && typeof upgrade !== 'string') {\n      throw new InvalidArgumentError('upgrade must be a string')\n    }\n\n    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('invalid headersTimeout')\n    }\n\n    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('invalid bodyTimeout')\n    }\n\n    if (reset != null && typeof reset !== 'boolean') {\n      throw new InvalidArgumentError('invalid reset')\n    }\n\n    if (expectContinue != null && typeof expectContinue !== 'boolean') {\n      throw new InvalidArgumentError('invalid expectContinue')\n    }\n\n    this.headersTimeout = headersTimeout\n\n    this.bodyTimeout = bodyTimeout\n\n    this.throwOnError = throwOnError === true\n\n    this.method = method\n\n    this.abort = null\n\n    if (body == null) {\n      this.body = null\n    } else if (isStream(body)) {\n      this.body = body\n\n      const rState = this.body._readableState\n      if (!rState || !rState.autoDestroy) {\n        this.endHandler = function autoDestroy () {\n          destroy(this)\n        }\n        this.body.on('end', this.endHandler)\n      }\n\n      this.errorHandler = err => {\n        if (this.abort) {\n          this.abort(err)\n        } else {\n          this.error = err\n        }\n      }\n      this.body.on('error', this.errorHandler)\n    } else if (isBuffer(body)) {\n      this.body = body.byteLength ? body : null\n    } else if (ArrayBuffer.isView(body)) {\n      this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null\n    } else if (body instanceof ArrayBuffer) {\n      this.body = body.byteLength ? Buffer.from(body) : null\n    } else if (typeof body === 'string') {\n      this.body = body.length ? Buffer.from(body) : null\n    } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {\n      this.body = body\n    } else {\n      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')\n    }\n\n    this.completed = false\n\n    this.aborted = false\n\n    this.upgrade = upgrade || null\n\n    this.path = query ? buildURL(path, query) : path\n\n    this.origin = origin\n\n    this.idempotent = idempotent == null\n      ? method === 'HEAD' || method === 'GET'\n      : idempotent\n\n    this.blocking = blocking == null ? false : blocking\n\n    this.reset = reset == null ? null : reset\n\n    this.host = null\n\n    this.contentLength = null\n\n    this.contentType = null\n\n    this.headers = []\n\n    // Only for H2\n    this.expectContinue = expectContinue != null ? expectContinue : false\n\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even')\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(this, headers[i], headers[i + 1])\n      }\n    } else if (headers && typeof headers === 'object') {\n      if (headers[Symbol.iterator]) {\n        for (const header of headers) {\n          if (!Array.isArray(header) || header.length !== 2) {\n            throw new InvalidArgumentError('headers must be in key-value pair format')\n          }\n          processHeader(this, header[0], header[1])\n        }\n      } else {\n        const keys = Object.keys(headers)\n        for (let i = 0; i < keys.length; ++i) {\n          processHeader(this, keys[i], headers[keys[i]])\n        }\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array')\n    }\n\n    validateHandler(handler, method, upgrade)\n\n    this.servername = servername || getServerName(this.host)\n\n    this[kHandler] = handler\n\n    if (channels.create.hasSubscribers) {\n      channels.create.publish({ request: this })\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this[kHandler].onBodySent) {\n      try {\n        return this[kHandler].onBodySent(chunk)\n      } catch (err) {\n        this.abort(err)\n      }\n    }\n  }\n\n  onRequestSent () {\n    if (channels.bodySent.hasSubscribers) {\n      channels.bodySent.publish({ request: this })\n    }\n\n    if (this[kHandler].onRequestSent) {\n      try {\n        return this[kHandler].onRequestSent()\n      } catch (err) {\n        this.abort(err)\n      }\n    }\n  }\n\n  onConnect (abort) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (this.error) {\n      abort(this.error)\n    } else {\n      this.abort = abort\n      return this[kHandler].onConnect(abort)\n    }\n  }\n\n  onResponseStarted () {\n    return this[kHandler].onResponseStarted?.()\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (channels.headers.hasSubscribers) {\n      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } })\n    }\n\n    try {\n      return this[kHandler].onHeaders(statusCode, headers, resume, statusText)\n    } catch (err) {\n      this.abort(err)\n    }\n  }\n\n  onData (chunk) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    try {\n      return this[kHandler].onData(chunk)\n    } catch (err) {\n      this.abort(err)\n      return false\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onUpgrade(statusCode, headers, socket)\n  }\n\n  onComplete (trailers) {\n    this.onFinally()\n\n    assert(!this.aborted)\n\n    this.completed = true\n    if (channels.trailers.hasSubscribers) {\n      channels.trailers.publish({ request: this, trailers })\n    }\n\n    try {\n      return this[kHandler].onComplete(trailers)\n    } catch (err) {\n      // TODO (fix): This might be a bad idea?\n      this.onError(err)\n    }\n  }\n\n  onError (error) {\n    this.onFinally()\n\n    if (channels.error.hasSubscribers) {\n      channels.error.publish({ request: this, error })\n    }\n\n    if (this.aborted) {\n      return\n    }\n    this.aborted = true\n\n    return this[kHandler].onError(error)\n  }\n\n  onFinally () {\n    if (this.errorHandler) {\n      this.body.off('error', this.errorHandler)\n      this.errorHandler = null\n    }\n\n    if (this.endHandler) {\n      this.body.off('end', this.endHandler)\n      this.endHandler = null\n    }\n  }\n\n  addHeader (key, value) {\n    processHeader(this, key, value)\n    return this\n  }\n}\n\nfunction processHeader (request, key, val) {\n  if (val && (typeof val === 'object' && !Array.isArray(val))) {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  } else if (val === undefined) {\n    return\n  }\n\n  let headerName = headerNameLowerCasedRecord[key]\n\n  if (headerName === undefined) {\n    headerName = key.toLowerCase()\n    if (headerNameLowerCasedRecord[headerName] === undefined && !isValidHTTPToken(headerName)) {\n      throw new InvalidArgumentError('invalid header key')\n    }\n  }\n\n  if (Array.isArray(val)) {\n    const arr = []\n    for (let i = 0; i < val.length; i++) {\n      if (typeof val[i] === 'string') {\n        if (!isValidHeaderValue(val[i])) {\n          throw new InvalidArgumentError(`invalid ${key} header`)\n        }\n        arr.push(val[i])\n      } else if (val[i] === null) {\n        arr.push('')\n      } else if (typeof val[i] === 'object') {\n        throw new InvalidArgumentError(`invalid ${key} header`)\n      } else {\n        arr.push(`${val[i]}`)\n      }\n    }\n    val = arr\n  } else if (typeof val === 'string') {\n    if (!isValidHeaderValue(val)) {\n      throw new InvalidArgumentError(`invalid ${key} header`)\n    }\n  } else if (val === null) {\n    val = ''\n  } else {\n    val = `${val}`\n  }\n\n  if (request.host === null && headerName === 'host') {\n    if (typeof val !== 'string') {\n      throw new InvalidArgumentError('invalid host header')\n    }\n    // Consumed by Client\n    request.host = val\n  } else if (request.contentLength === null && headerName === 'content-length') {\n    request.contentLength = parseInt(val, 10)\n    if (!Number.isFinite(request.contentLength)) {\n      throw new InvalidArgumentError('invalid content-length header')\n    }\n  } else if (request.contentType === null && headerName === 'content-type') {\n    request.contentType = val\n    request.headers.push(key, val)\n  } else if (headerName === 'transfer-encoding' || headerName === 'keep-alive' || headerName === 'upgrade') {\n    throw new InvalidArgumentError(`invalid ${headerName} header`)\n  } else if (headerName === 'connection') {\n    const value = typeof val === 'string' ? val.toLowerCase() : null\n    if (value !== 'close' && value !== 'keep-alive') {\n      throw new InvalidArgumentError('invalid connection header')\n    }\n\n    if (value === 'close') {\n      request.reset = true\n    }\n  } else if (headerName === 'expect') {\n    throw new NotSupportedError('expect header not supported')\n  } else {\n    request.headers.push(key, val)\n  }\n}\n\nmodule.exports = Request\n"]}}