{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{kState,kError,kResult,kAborted,kLastProgressEventFired}=require(\"./symbols\");const{ProgressEvent}=require(\"./progressevent\");const{getEncoding}=require(\"./encoding\");const{serializeAMimeType,parseMIMEType}=require(\"../fetch/data-url\");const{types}=require(\"node:util\");const{StringDecoder}=require(\"string_decoder\");const{btoa}=require(\"node:buffer\");const staticPropertyDescriptors={enumerable:true,writable:false,configurable:false};function readOperation(fr,blob,type,encodingName){if(fr[kState]===\"loading\"){throw new DOMException(\"Invalid state\",\"InvalidStateError\")}fr[kState]=\"loading\";fr[kResult]=null;fr[kError]=null;const stream=blob.stream();const reader=stream.getReader();const bytes=[];let chunkPromise=reader.read();let isFirstChunk=true;(async()=>{while(!fr[kAborted]){try{const{done,value}=await chunkPromise;if(isFirstChunk&&!fr[kAborted]){queueMicrotask(()=>{fireAProgressEvent(\"loadstart\",fr)})}isFirstChunk=false;if(!done&&types.isUint8Array(value)){bytes.push(value);if((fr[kLastProgressEventFired]===void 0||Date.now()-fr[kLastProgressEventFired]>=50)&&!fr[kAborted]){fr[kLastProgressEventFired]=Date.now();queueMicrotask(()=>{fireAProgressEvent(\"progress\",fr)})}chunkPromise=reader.read()}else if(done){queueMicrotask(()=>{fr[kState]=\"done\";try{const result=packageData(bytes,type,blob.type,encodingName);if(fr[kAborted]){return}fr[kResult]=result;fireAProgressEvent(\"load\",fr)}catch(error){fr[kError]=error;fireAProgressEvent(\"error\",fr)}if(fr[kState]!==\"loading\"){fireAProgressEvent(\"loadend\",fr)}});break}}catch(error){if(fr[kAborted]){return}queueMicrotask(()=>{fr[kState]=\"done\";fr[kError]=error;fireAProgressEvent(\"error\",fr);if(fr[kState]!==\"loading\"){fireAProgressEvent(\"loadend\",fr)}});break}}})()}__name(readOperation,\"readOperation\");function fireAProgressEvent(e,reader){const event=new ProgressEvent(e,{bubbles:false,cancelable:false});reader.dispatchEvent(event)}__name(fireAProgressEvent,\"fireAProgressEvent\");function packageData(bytes,type,mimeType,encodingName){switch(type){case\"DataURL\":{let dataURL=\"data:\";const parsed=parseMIMEType(mimeType||\"application/octet-stream\");if(parsed!==\"failure\"){dataURL+=serializeAMimeType(parsed)}dataURL+=\";base64,\";const decoder=new StringDecoder(\"latin1\");for(const chunk of bytes){dataURL+=btoa(decoder.write(chunk))}dataURL+=btoa(decoder.end());return dataURL}case\"Text\":{let encoding=\"failure\";if(encodingName){encoding=getEncoding(encodingName)}if(encoding===\"failure\"&&mimeType){const type2=parseMIMEType(mimeType);if(type2!==\"failure\"){encoding=getEncoding(type2.parameters.get(\"charset\"))}}if(encoding===\"failure\"){encoding=\"UTF-8\"}return decode(bytes,encoding)}case\"ArrayBuffer\":{const sequence=combineByteSequences(bytes);return sequence.buffer}case\"BinaryString\":{let binaryString=\"\";const decoder=new StringDecoder(\"latin1\");for(const chunk of bytes){binaryString+=decoder.write(chunk)}binaryString+=decoder.end();return binaryString}}}__name(packageData,\"packageData\");function decode(ioQueue,encoding){const bytes=combineByteSequences(ioQueue);const BOMEncoding=BOMSniffing(bytes);let slice=0;if(BOMEncoding!==null){encoding=BOMEncoding;slice=BOMEncoding===\"UTF-8\"?3:2}const sliced=bytes.slice(slice);return new TextDecoder(encoding).decode(sliced)}__name(decode,\"decode\");function BOMSniffing(ioQueue){const[a,b,c]=ioQueue;if(a===239&&b===187&&c===191){return\"UTF-8\"}else if(a===254&&b===255){return\"UTF-16BE\"}else if(a===255&&b===254){return\"UTF-16LE\"}return null}__name(BOMSniffing,\"BOMSniffing\");function combineByteSequences(sequences){const size=sequences.reduce((a,b)=>{return a+b.byteLength},0);let offset=0;return sequences.reduce((a,b)=>{a.set(b,offset);offset+=b.byteLength;return a},new Uint8Array(size))}__name(combineByteSequences,\"combineByteSequences\");module.exports={staticPropertyDescriptors,readOperation,fireAProgressEvent};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["type"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/fileapi/util.js"],"sourcesContent":["'use strict'\n\nconst {\n  kState,\n  kError,\n  kResult,\n  kAborted,\n  kLastProgressEventFired\n} = require('./symbols')\nconst { ProgressEvent } = require('./progressevent')\nconst { getEncoding } = require('./encoding')\nconst { serializeAMimeType, parseMIMEType } = require('../fetch/data-url')\nconst { types } = require('node:util')\nconst { StringDecoder } = require('string_decoder')\nconst { btoa } = require('node:buffer')\n\n/** @type {PropertyDescriptor} */\nconst staticPropertyDescriptors = {\n  enumerable: true,\n  writable: false,\n  configurable: false\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#readOperation\n * @param {import('./filereader').FileReader} fr\n * @param {import('buffer').Blob} blob\n * @param {string} type\n * @param {string?} encodingName\n */\nfunction readOperation (fr, blob, type, encodingName) {\n  // 1. If fr’s state is \"loading\", throw an InvalidStateError\n  //    DOMException.\n  if (fr[kState] === 'loading') {\n    throw new DOMException('Invalid state', 'InvalidStateError')\n  }\n\n  // 2. Set fr’s state to \"loading\".\n  fr[kState] = 'loading'\n\n  // 3. Set fr’s result to null.\n  fr[kResult] = null\n\n  // 4. Set fr’s error to null.\n  fr[kError] = null\n\n  // 5. Let stream be the result of calling get stream on blob.\n  /** @type {import('stream/web').ReadableStream} */\n  const stream = blob.stream()\n\n  // 6. Let reader be the result of getting a reader from stream.\n  const reader = stream.getReader()\n\n  // 7. Let bytes be an empty byte sequence.\n  /** @type {Uint8Array[]} */\n  const bytes = []\n\n  // 8. Let chunkPromise be the result of reading a chunk from\n  //    stream with reader.\n  let chunkPromise = reader.read()\n\n  // 9. Let isFirstChunk be true.\n  let isFirstChunk = true\n\n  // 10. In parallel, while true:\n  // Note: \"In parallel\" just means non-blocking\n  // Note 2: readOperation itself cannot be async as double\n  // reading the body would then reject the promise, instead\n  // of throwing an error.\n  ;(async () => {\n    while (!fr[kAborted]) {\n      // 1. Wait for chunkPromise to be fulfilled or rejected.\n      try {\n        const { done, value } = await chunkPromise\n\n        // 2. If chunkPromise is fulfilled, and isFirstChunk is\n        //    true, queue a task to fire a progress event called\n        //    loadstart at fr.\n        if (isFirstChunk && !fr[kAborted]) {\n          queueMicrotask(() => {\n            fireAProgressEvent('loadstart', fr)\n          })\n        }\n\n        // 3. Set isFirstChunk to false.\n        isFirstChunk = false\n\n        // 4. If chunkPromise is fulfilled with an object whose\n        //    done property is false and whose value property is\n        //    a Uint8Array object, run these steps:\n        if (!done && types.isUint8Array(value)) {\n          // 1. Let bs be the byte sequence represented by the\n          //    Uint8Array object.\n\n          // 2. Append bs to bytes.\n          bytes.push(value)\n\n          // 3. If roughly 50ms have passed since these steps\n          //    were last invoked, queue a task to fire a\n          //    progress event called progress at fr.\n          if (\n            (\n              fr[kLastProgressEventFired] === undefined ||\n              Date.now() - fr[kLastProgressEventFired] >= 50\n            ) &&\n            !fr[kAborted]\n          ) {\n            fr[kLastProgressEventFired] = Date.now()\n            queueMicrotask(() => {\n              fireAProgressEvent('progress', fr)\n            })\n          }\n\n          // 4. Set chunkPromise to the result of reading a\n          //    chunk from stream with reader.\n          chunkPromise = reader.read()\n        } else if (done) {\n          // 5. Otherwise, if chunkPromise is fulfilled with an\n          //    object whose done property is true, queue a task\n          //    to run the following steps and abort this algorithm:\n          queueMicrotask(() => {\n            // 1. Set fr’s state to \"done\".\n            fr[kState] = 'done'\n\n            // 2. Let result be the result of package data given\n            //    bytes, type, blob’s type, and encodingName.\n            try {\n              const result = packageData(bytes, type, blob.type, encodingName)\n\n              // 4. Else:\n\n              if (fr[kAborted]) {\n                return\n              }\n\n              // 1. Set fr’s result to result.\n              fr[kResult] = result\n\n              // 2. Fire a progress event called load at the fr.\n              fireAProgressEvent('load', fr)\n            } catch (error) {\n              // 3. If package data threw an exception error:\n\n              // 1. Set fr’s error to error.\n              fr[kError] = error\n\n              // 2. Fire a progress event called error at fr.\n              fireAProgressEvent('error', fr)\n            }\n\n            // 5. If fr’s state is not \"loading\", fire a progress\n            //    event called loadend at the fr.\n            if (fr[kState] !== 'loading') {\n              fireAProgressEvent('loadend', fr)\n            }\n          })\n\n          break\n        }\n      } catch (error) {\n        if (fr[kAborted]) {\n          return\n        }\n\n        // 6. Otherwise, if chunkPromise is rejected with an\n        //    error error, queue a task to run the following\n        //    steps and abort this algorithm:\n        queueMicrotask(() => {\n          // 1. Set fr’s state to \"done\".\n          fr[kState] = 'done'\n\n          // 2. Set fr’s error to error.\n          fr[kError] = error\n\n          // 3. Fire a progress event called error at fr.\n          fireAProgressEvent('error', fr)\n\n          // 4. If fr’s state is not \"loading\", fire a progress\n          //    event called loadend at fr.\n          if (fr[kState] !== 'loading') {\n            fireAProgressEvent('loadend', fr)\n          }\n        })\n\n        break\n      }\n    }\n  })()\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#fire-a-progress-event\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e The name of the event\n * @param {import('./filereader').FileReader} reader\n */\nfunction fireAProgressEvent (e, reader) {\n  // The progress event e does not bubble. e.bubbles must be false\n  // The progress event e is NOT cancelable. e.cancelable must be false\n  const event = new ProgressEvent(e, {\n    bubbles: false,\n    cancelable: false\n  })\n\n  reader.dispatchEvent(event)\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#blob-package-data\n * @param {Uint8Array[]} bytes\n * @param {string} type\n * @param {string?} mimeType\n * @param {string?} encodingName\n */\nfunction packageData (bytes, type, mimeType, encodingName) {\n  // 1. A Blob has an associated package data algorithm, given\n  //    bytes, a type, a optional mimeType, and a optional\n  //    encodingName, which switches on type and runs the\n  //    associated steps:\n\n  switch (type) {\n    case 'DataURL': {\n      // 1. Return bytes as a DataURL [RFC2397] subject to\n      //    the considerations below:\n      //  * Use mimeType as part of the Data URL if it is\n      //    available in keeping with the Data URL\n      //    specification [RFC2397].\n      //  * If mimeType is not available return a Data URL\n      //    without a media-type. [RFC2397].\n\n      // https://datatracker.ietf.org/doc/html/rfc2397#section-3\n      // dataurl    := \"data:\" [ mediatype ] [ \";base64\" ] \",\" data\n      // mediatype  := [ type \"/\" subtype ] *( \";\" parameter )\n      // data       := *urlchar\n      // parameter  := attribute \"=\" value\n      let dataURL = 'data:'\n\n      const parsed = parseMIMEType(mimeType || 'application/octet-stream')\n\n      if (parsed !== 'failure') {\n        dataURL += serializeAMimeType(parsed)\n      }\n\n      dataURL += ';base64,'\n\n      const decoder = new StringDecoder('latin1')\n\n      for (const chunk of bytes) {\n        dataURL += btoa(decoder.write(chunk))\n      }\n\n      dataURL += btoa(decoder.end())\n\n      return dataURL\n    }\n    case 'Text': {\n      // 1. Let encoding be failure\n      let encoding = 'failure'\n\n      // 2. If the encodingName is present, set encoding to the\n      //    result of getting an encoding from encodingName.\n      if (encodingName) {\n        encoding = getEncoding(encodingName)\n      }\n\n      // 3. If encoding is failure, and mimeType is present:\n      if (encoding === 'failure' && mimeType) {\n        // 1. Let type be the result of parse a MIME type\n        //    given mimeType.\n        const type = parseMIMEType(mimeType)\n\n        // 2. If type is not failure, set encoding to the result\n        //    of getting an encoding from type’s parameters[\"charset\"].\n        if (type !== 'failure') {\n          encoding = getEncoding(type.parameters.get('charset'))\n        }\n      }\n\n      // 4. If encoding is failure, then set encoding to UTF-8.\n      if (encoding === 'failure') {\n        encoding = 'UTF-8'\n      }\n\n      // 5. Decode bytes using fallback encoding encoding, and\n      //    return the result.\n      return decode(bytes, encoding)\n    }\n    case 'ArrayBuffer': {\n      // Return a new ArrayBuffer whose contents are bytes.\n      const sequence = combineByteSequences(bytes)\n\n      return sequence.buffer\n    }\n    case 'BinaryString': {\n      // Return bytes as a binary string, in which every byte\n      //  is represented by a code unit of equal value [0..255].\n      let binaryString = ''\n\n      const decoder = new StringDecoder('latin1')\n\n      for (const chunk of bytes) {\n        binaryString += decoder.write(chunk)\n      }\n\n      binaryString += decoder.end()\n\n      return binaryString\n    }\n  }\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#decode\n * @param {Uint8Array[]} ioQueue\n * @param {string} encoding\n */\nfunction decode (ioQueue, encoding) {\n  const bytes = combineByteSequences(ioQueue)\n\n  // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.\n  const BOMEncoding = BOMSniffing(bytes)\n\n  let slice = 0\n\n  // 2. If BOMEncoding is non-null:\n  if (BOMEncoding !== null) {\n    // 1. Set encoding to BOMEncoding.\n    encoding = BOMEncoding\n\n    // 2. Read three bytes from ioQueue, if BOMEncoding is\n    //    UTF-8; otherwise read two bytes.\n    //    (Do nothing with those bytes.)\n    slice = BOMEncoding === 'UTF-8' ? 3 : 2\n  }\n\n  // 3. Process a queue with an instance of encoding’s\n  //    decoder, ioQueue, output, and \"replacement\".\n\n  // 4. Return output.\n\n  const sliced = bytes.slice(slice)\n  return new TextDecoder(encoding).decode(sliced)\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#bom-sniff\n * @param {Uint8Array} ioQueue\n */\nfunction BOMSniffing (ioQueue) {\n  // 1. Let BOM be the result of peeking 3 bytes from ioQueue,\n  //    converted to a byte sequence.\n  const [a, b, c] = ioQueue\n\n  // 2. For each of the rows in the table below, starting with\n  //    the first one and going down, if BOM starts with the\n  //    bytes given in the first column, then return the\n  //    encoding given in the cell in the second column of that\n  //    row. Otherwise, return null.\n  if (a === 0xEF && b === 0xBB && c === 0xBF) {\n    return 'UTF-8'\n  } else if (a === 0xFE && b === 0xFF) {\n    return 'UTF-16BE'\n  } else if (a === 0xFF && b === 0xFE) {\n    return 'UTF-16LE'\n  }\n\n  return null\n}\n\n/**\n * @param {Uint8Array[]} sequences\n */\nfunction combineByteSequences (sequences) {\n  const size = sequences.reduce((a, b) => {\n    return a + b.byteLength\n  }, 0)\n\n  let offset = 0\n\n  return sequences.reduce((a, b) => {\n    a.set(b, offset)\n    offset += b.byteLength\n    return a\n  }, new Uint8Array(size))\n}\n\nmodule.exports = {\n  staticPropertyDescriptors,\n  readOperation,\n  fireAProgressEvent\n}\n"]}}