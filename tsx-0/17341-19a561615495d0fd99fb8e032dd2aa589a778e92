{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});exports.getParse=getParse;exports.update=update;const domutils_1=require(\"domutils\");const domhandler_1=require(\"domhandler\");function getParse(parser){return __name(function parse(content,options,isDocument,context){if(typeof Buffer!==\"undefined\"&&Buffer.isBuffer(content)){content=content.toString()}if(typeof content===\"string\"){return parser(content,options,isDocument,context)}const doc=content;if(!Array.isArray(doc)&&(0,domhandler_1.isDocument)(doc)){return doc}const root=new domhandler_1.Document([]);update(doc,root);return root},\"parse\")}__name(getParse,\"getParse\");function update(newChilds,parent){const arr=Array.isArray(newChilds)?newChilds:[newChilds];if(parent){parent.children=arr}else{parent=null}for(let i=0;i<arr.length;i++){const node=arr[i];if(node.parent&&node.parent.children!==arr){(0,domutils_1.removeElement)(node)}if(parent){node.prev=arr[i-1]||null;node.next=arr[i+1]||null}else{node.prev=node.next=null}node.parent=parent}return parent}__name(update,\"update\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CAAE,MAAO,IAAK,CAAC,EAC5D,QAAQ,SAAW,SACnB,QAAQ,OAAS,OACjB,MAAM,WAAa,QAAQ,UAAU,EACrC,MAAM,aAAe,QAAQ,YAAY,EAOzC,SAAS,SAAS,OAAQ,CAUtB,OAAO,gBAAS,MAAM,QAAS,QAAS,WAAY,QAAS,CACzD,GAAI,OAAO,SAAW,aAAe,OAAO,SAAS,OAAO,EAAG,CAC3D,QAAU,QAAQ,SAAS,CAC/B,CACA,GAAI,OAAO,UAAY,SAAU,CAC7B,OAAO,OAAO,QAAS,QAAS,WAAY,OAAO,CACvD,CACA,MAAM,IAAM,QACZ,GAAI,CAAC,MAAM,QAAQ,GAAG,IAAM,EAAG,aAAa,YAAY,GAAG,EAAG,CAE1D,OAAO,GACX,CAEA,MAAM,KAAO,IAAI,aAAa,SAAS,CAAC,CAAC,EAEzC,OAAO,IAAK,IAAI,EAChB,OAAO,IACX,EAjBO,QAkBX,CA5BS,4BAoCT,SAAS,OAAO,UAAW,OAAQ,CAE/B,MAAM,IAAM,MAAM,QAAQ,SAAS,EAAI,UAAY,CAAC,SAAS,EAE7D,GAAI,OAAQ,CACR,OAAO,SAAW,GACtB,KACK,CACD,OAAS,IACb,CAEA,QAAS,EAAI,EAAG,EAAI,IAAI,OAAQ,IAAK,CACjC,MAAM,KAAO,IAAI,CAAC,EAElB,GAAI,KAAK,QAAU,KAAK,OAAO,WAAa,IAAK,EAC5C,EAAG,WAAW,eAAe,IAAI,CACtC,CACA,GAAI,OAAQ,CACR,KAAK,KAAO,IAAI,EAAI,CAAC,GAAK,KAC1B,KAAK,KAAO,IAAI,EAAI,CAAC,GAAK,IAC9B,KACK,CACD,KAAK,KAAO,KAAK,KAAO,IAC5B,CACA,KAAK,OAAS,MAClB,CACA,OAAO,MACX,CA3BS","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/cheerio@1.0.0/node_modules/cheerio/dist/commonjs/parse.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getParse = getParse;\nexports.update = update;\nconst domutils_1 = require(\"domutils\");\nconst domhandler_1 = require(\"domhandler\");\n/**\n * Get the parse function with options.\n *\n * @param parser - The parser function.\n * @returns The parse function with options.\n */\nfunction getParse(parser) {\n    /**\n     * Parse a HTML string or a node.\n     *\n     * @param content - The HTML string or node.\n     * @param options - The parser options.\n     * @param isDocument - If `content` is a document.\n     * @param context - The context node in the DOM tree.\n     * @returns The parsed document node.\n     */\n    return function parse(content, options, isDocument, context) {\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(content)) {\n            content = content.toString();\n        }\n        if (typeof content === 'string') {\n            return parser(content, options, isDocument, context);\n        }\n        const doc = content;\n        if (!Array.isArray(doc) && (0, domhandler_1.isDocument)(doc)) {\n            // If `doc` is already a root, just return it\n            return doc;\n        }\n        // Add conent to new root element\n        const root = new domhandler_1.Document([]);\n        // Update the DOM using the root\n        update(doc, root);\n        return root;\n    };\n}\n/**\n * Update the dom structure, for one changed layer.\n *\n * @param newChilds - The new children.\n * @param parent - The new parent.\n * @returns The parent node.\n */\nfunction update(newChilds, parent) {\n    // Normalize\n    const arr = Array.isArray(newChilds) ? newChilds : [newChilds];\n    // Update parent\n    if (parent) {\n        parent.children = arr;\n    }\n    else {\n        parent = null;\n    }\n    // Update neighbors\n    for (let i = 0; i < arr.length; i++) {\n        const node = arr[i];\n        // Cleanly remove existing nodes from their previous structures.\n        if (node.parent && node.parent.children !== arr) {\n            (0, domutils_1.removeElement)(node);\n        }\n        if (parent) {\n            node.prev = arr[i - 1] || null;\n            node.next = arr[i + 1] || null;\n        }\n        else {\n            node.prev = node.next = null;\n        }\n        node.parent = parent;\n    }\n    return parent;\n}\n//# sourceMappingURL=parse.js.map"]}}