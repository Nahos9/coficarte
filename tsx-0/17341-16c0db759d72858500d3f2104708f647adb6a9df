{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{WebsocketFrameSend}=require(\"./frame\");const{opcodes,sendHints}=require(\"./constants\");const FixedQueue=require(\"../../dispatcher/fixed-queue\");const FastBuffer=Buffer[Symbol.species];class SendQueue{static{__name(this,\"SendQueue\")}#queue=new FixedQueue;#running=false;#socket;constructor(socket){this.#socket=socket}add(item,cb,hint){if(hint!==sendHints.blob){const frame=createFrame(item,hint);if(!this.#running){this.#socket.write(frame,cb)}else{const node2={promise:null,callback:cb,frame};this.#queue.push(node2)}return}const node={promise:item.arrayBuffer().then(ab=>{node.promise=null;node.frame=createFrame(ab,hint)}),callback:cb,frame:null};this.#queue.push(node);if(!this.#running){this.#run()}}async#run(){this.#running=true;const queue=this.#queue;while(!queue.isEmpty()){const node=queue.shift();if(node.promise!==null){await node.promise}this.#socket.write(node.frame,node.callback);node.callback=node.frame=null}this.#running=false}}function createFrame(data,hint){return new WebsocketFrameSend(toBuffer(data,hint)).createFrame(hint===sendHints.string?opcodes.TEXT:opcodes.BINARY)}__name(createFrame,\"createFrame\");function toBuffer(data,hint){switch(hint){case sendHints.string:return Buffer.from(data);case sendHints.arrayBuffer:case sendHints.blob:return new FastBuffer(data);case sendHints.typedArray:return new FastBuffer(data.buffer,data.byteOffset,data.byteLength)}}__name(toBuffer,\"toBuffer\");module.exports={SendQueue};\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAEA,KAAM,CAAE,kBAAmB,EAAI,QAAQ,SAAS,EAChD,KAAM,CAAE,QAAS,SAAU,EAAI,QAAQ,aAAa,EACpD,MAAM,WAAa,QAAQ,8BAA8B,EAGzD,MAAM,WAAa,OAAO,OAAO,OAAO,EASxC,MAAM,SAAU,CAhBhB,MAgBgB,0BAId,OAAS,IAAI,WAKb,SAAW,MAGX,QAEA,YAAa,OAAQ,CACnB,KAAK,QAAU,MACjB,CAEA,IAAK,KAAM,GAAI,KAAM,CACnB,GAAI,OAAS,UAAU,KAAM,CAC3B,MAAM,MAAQ,YAAY,KAAM,IAAI,EACpC,GAAI,CAAC,KAAK,SAAU,CAElB,KAAK,QAAQ,MAAM,MAAO,EAAE,CAC9B,KAAO,CAEL,MAAMA,MAAO,CACX,QAAS,KACT,SAAU,GACV,KACF,EACA,KAAK,OAAO,KAAKA,KAAI,CACvB,CACA,MACF,CAGA,MAAM,KAAO,CACX,QAAS,KAAK,YAAY,EAAE,KAAM,IAAO,CACvC,KAAK,QAAU,KACf,KAAK,MAAQ,YAAY,GAAI,IAAI,CACnC,CAAC,EACD,SAAU,GACV,MAAO,IACT,EAEA,KAAK,OAAO,KAAK,IAAI,EAErB,GAAI,CAAC,KAAK,SAAU,CAClB,KAAK,KAAK,CACZ,CACF,CAEA,KAAM,MAAQ,CACZ,KAAK,SAAW,KAChB,MAAM,MAAQ,KAAK,OACnB,MAAO,CAAC,MAAM,QAAQ,EAAG,CACvB,MAAM,KAAO,MAAM,MAAM,EAEzB,GAAI,KAAK,UAAY,KAAM,CACzB,MAAM,KAAK,OACb,CAEA,KAAK,QAAQ,MAAM,KAAK,MAAO,KAAK,QAAQ,EAE5C,KAAK,SAAW,KAAK,MAAQ,IAC/B,CACA,KAAK,SAAW,KAClB,CACF,CAEA,SAAS,YAAa,KAAM,KAAM,CAChC,OAAO,IAAI,mBAAmB,SAAS,KAAM,IAAI,CAAC,EAAE,YAAY,OAAS,UAAU,OAAS,QAAQ,KAAO,QAAQ,MAAM,CAC3H,CAFS,kCAIT,SAAS,SAAU,KAAM,KAAM,CAC7B,OAAQ,KAAM,CACZ,KAAK,UAAU,OACb,OAAO,OAAO,KAAK,IAAI,EACzB,KAAK,UAAU,YACf,KAAK,UAAU,KACb,OAAO,IAAI,WAAW,IAAI,EAC5B,KAAK,UAAU,WACb,OAAO,IAAI,WAAW,KAAK,OAAQ,KAAK,WAAY,KAAK,UAAU,CACvE,CACF,CAVS,4BAYT,OAAO,QAAU,CAAE,SAAU","names":["node"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/websocket/sender.js"],"sourcesContent":["'use strict'\n\nconst { WebsocketFrameSend } = require('./frame')\nconst { opcodes, sendHints } = require('./constants')\nconst FixedQueue = require('../../dispatcher/fixed-queue')\n\n/** @type {typeof Uint8Array} */\nconst FastBuffer = Buffer[Symbol.species]\n\n/**\n * @typedef {object} SendQueueNode\n * @property {Promise<void> | null} promise\n * @property {((...args: any[]) => any)} callback\n * @property {Buffer | null} frame\n */\n\nclass SendQueue {\n  /**\n   * @type {FixedQueue}\n   */\n  #queue = new FixedQueue()\n\n  /**\n   * @type {boolean}\n   */\n  #running = false\n\n  /** @type {import('node:net').Socket} */\n  #socket\n\n  constructor (socket) {\n    this.#socket = socket\n  }\n\n  add (item, cb, hint) {\n    if (hint !== sendHints.blob) {\n      const frame = createFrame(item, hint)\n      if (!this.#running) {\n        // fast-path\n        this.#socket.write(frame, cb)\n      } else {\n        /** @type {SendQueueNode} */\n        const node = {\n          promise: null,\n          callback: cb,\n          frame\n        }\n        this.#queue.push(node)\n      }\n      return\n    }\n\n    /** @type {SendQueueNode} */\n    const node = {\n      promise: item.arrayBuffer().then((ab) => {\n        node.promise = null\n        node.frame = createFrame(ab, hint)\n      }),\n      callback: cb,\n      frame: null\n    }\n\n    this.#queue.push(node)\n\n    if (!this.#running) {\n      this.#run()\n    }\n  }\n\n  async #run () {\n    this.#running = true\n    const queue = this.#queue\n    while (!queue.isEmpty()) {\n      const node = queue.shift()\n      // wait pending promise\n      if (node.promise !== null) {\n        await node.promise\n      }\n      // write\n      this.#socket.write(node.frame, node.callback)\n      // cleanup\n      node.callback = node.frame = null\n    }\n    this.#running = false\n  }\n}\n\nfunction createFrame (data, hint) {\n  return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.string ? opcodes.TEXT : opcodes.BINARY)\n}\n\nfunction toBuffer (data, hint) {\n  switch (hint) {\n    case sendHints.string:\n      return Buffer.from(data)\n    case sendHints.arrayBuffer:\n    case sendHints.blob:\n      return new FastBuffer(data)\n    case sendHints.typedArray:\n      return new FastBuffer(data.buffer, data.byteOffset, data.byteLength)\n  }\n}\n\nmodule.exports = { SendQueue }\n"]}}