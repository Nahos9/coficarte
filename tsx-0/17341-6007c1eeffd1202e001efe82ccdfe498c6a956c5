{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{MockNotMatchedError}=require(\"./mock-errors\");const{kDispatches,kMockAgent,kOriginalDispatch,kOrigin,kGetNetConnect}=require(\"./mock-symbols\");const{buildURL}=require(\"../core/util\");const{STATUS_CODES}=require(\"node:http\");const{types:{isPromise}}=require(\"node:util\");function matchValue(match,value){if(typeof match===\"string\"){return match===value}if(match instanceof RegExp){return match.test(value)}if(typeof match===\"function\"){return match(value)===true}return false}__name(matchValue,\"matchValue\");function lowerCaseEntries(headers){return Object.fromEntries(Object.entries(headers).map(([headerName,headerValue])=>{return[headerName.toLocaleLowerCase(),headerValue]}))}__name(lowerCaseEntries,\"lowerCaseEntries\");function getHeaderByName(headers,key){if(Array.isArray(headers)){for(let i=0;i<headers.length;i+=2){if(headers[i].toLocaleLowerCase()===key.toLocaleLowerCase()){return headers[i+1]}}return void 0}else if(typeof headers.get===\"function\"){return headers.get(key)}else{return lowerCaseEntries(headers)[key.toLocaleLowerCase()]}}__name(getHeaderByName,\"getHeaderByName\");function buildHeadersFromArray(headers){const clone=headers.slice();const entries=[];for(let index=0;index<clone.length;index+=2){entries.push([clone[index],clone[index+1]])}return Object.fromEntries(entries)}__name(buildHeadersFromArray,\"buildHeadersFromArray\");function matchHeaders(mockDispatch2,headers){if(typeof mockDispatch2.headers===\"function\"){if(Array.isArray(headers)){headers=buildHeadersFromArray(headers)}return mockDispatch2.headers(headers?lowerCaseEntries(headers):{})}if(typeof mockDispatch2.headers===\"undefined\"){return true}if(typeof headers!==\"object\"||typeof mockDispatch2.headers!==\"object\"){return false}for(const[matchHeaderName,matchHeaderValue]of Object.entries(mockDispatch2.headers)){const headerValue=getHeaderByName(headers,matchHeaderName);if(!matchValue(matchHeaderValue,headerValue)){return false}}return true}__name(matchHeaders,\"matchHeaders\");function safeUrl(path){if(typeof path!==\"string\"){return path}const pathSegments=path.split(\"?\");if(pathSegments.length!==2){return path}const qp=new URLSearchParams(pathSegments.pop());qp.sort();return[...pathSegments,qp.toString()].join(\"?\")}__name(safeUrl,\"safeUrl\");function matchKey(mockDispatch2,{path,method,body,headers}){const pathMatch=matchValue(mockDispatch2.path,path);const methodMatch=matchValue(mockDispatch2.method,method);const bodyMatch=typeof mockDispatch2.body!==\"undefined\"?matchValue(mockDispatch2.body,body):true;const headersMatch=matchHeaders(mockDispatch2,headers);return pathMatch&&methodMatch&&bodyMatch&&headersMatch}__name(matchKey,\"matchKey\");function getResponseData(data){if(Buffer.isBuffer(data)){return data}else if(data instanceof Uint8Array){return data}else if(data instanceof ArrayBuffer){return data}else if(typeof data===\"object\"){return JSON.stringify(data)}else{return data.toString()}}__name(getResponseData,\"getResponseData\");function getMockDispatch(mockDispatches,key){const basePath=key.query?buildURL(key.path,key.query):key.path;const resolvedPath=typeof basePath===\"string\"?safeUrl(basePath):basePath;let matchedMockDispatches=mockDispatches.filter(({consumed})=>!consumed).filter(({path})=>matchValue(safeUrl(path),resolvedPath));if(matchedMockDispatches.length===0){throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)}matchedMockDispatches=matchedMockDispatches.filter(({method})=>matchValue(method,key.method));if(matchedMockDispatches.length===0){throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`)}matchedMockDispatches=matchedMockDispatches.filter(({body})=>typeof body!==\"undefined\"?matchValue(body,key.body):true);if(matchedMockDispatches.length===0){throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`)}matchedMockDispatches=matchedMockDispatches.filter(mockDispatch2=>matchHeaders(mockDispatch2,key.headers));if(matchedMockDispatches.length===0){const headers=typeof key.headers===\"object\"?JSON.stringify(key.headers):key.headers;throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`)}return matchedMockDispatches[0]}__name(getMockDispatch,\"getMockDispatch\");function addMockDispatch(mockDispatches,key,data){const baseData={timesInvoked:0,times:1,persist:false,consumed:false};const replyData=typeof data===\"function\"?{callback:data}:{...data};const newMockDispatch={...baseData,...key,pending:true,data:{error:null,...replyData}};mockDispatches.push(newMockDispatch);return newMockDispatch}__name(addMockDispatch,\"addMockDispatch\");function deleteMockDispatch(mockDispatches,key){const index=mockDispatches.findIndex(dispatch=>{if(!dispatch.consumed){return false}return matchKey(dispatch,key)});if(index!==-1){mockDispatches.splice(index,1)}}__name(deleteMockDispatch,\"deleteMockDispatch\");function buildKey(opts){const{path,method,body,headers,query}=opts;return{path,method,body,headers,query}}__name(buildKey,\"buildKey\");function generateKeyValues(data){const keys=Object.keys(data);const result=[];for(let i=0;i<keys.length;++i){const key=keys[i];const value=data[key];const name=Buffer.from(`${key}`);if(Array.isArray(value)){for(let j=0;j<value.length;++j){result.push(name,Buffer.from(`${value[j]}`))}}else{result.push(name,Buffer.from(`${value}`))}}return result}__name(generateKeyValues,\"generateKeyValues\");function getStatusText(statusCode){return STATUS_CODES[statusCode]||\"unknown\"}__name(getStatusText,\"getStatusText\");async function getResponse(body){const buffers=[];for await(const data of body){buffers.push(data)}return Buffer.concat(buffers).toString(\"utf8\")}__name(getResponse,\"getResponse\");function mockDispatch(opts,handler){const key=buildKey(opts);const mockDispatch2=getMockDispatch(this[kDispatches],key);mockDispatch2.timesInvoked++;if(mockDispatch2.data.callback){mockDispatch2.data={...mockDispatch2.data,...mockDispatch2.data.callback(opts)}}const{data:{statusCode,data,headers,trailers,error},delay,persist}=mockDispatch2;const{timesInvoked,times}=mockDispatch2;mockDispatch2.consumed=!persist&&timesInvoked>=times;mockDispatch2.pending=timesInvoked<times;if(error!==null){deleteMockDispatch(this[kDispatches],key);handler.onError(error);return true}if(typeof delay===\"number\"&&delay>0){setTimeout(()=>{handleReply(this[kDispatches])},delay)}else{handleReply(this[kDispatches])}function handleReply(mockDispatches,_data=data){const optsHeaders=Array.isArray(opts.headers)?buildHeadersFromArray(opts.headers):opts.headers;const body=typeof _data===\"function\"?_data({...opts,headers:optsHeaders}):_data;if(isPromise(body)){body.then(newData=>handleReply(mockDispatches,newData));return}const responseData=getResponseData(body);const responseHeaders=generateKeyValues(headers);const responseTrailers=generateKeyValues(trailers);handler.onConnect?.(err=>handler.onError(err),null);handler.onHeaders?.(statusCode,responseHeaders,resume,getStatusText(statusCode));handler.onData?.(Buffer.from(responseData));handler.onComplete?.(responseTrailers);deleteMockDispatch(mockDispatches,key)}__name(handleReply,\"handleReply\");function resume(){}__name(resume,\"resume\");return true}__name(mockDispatch,\"mockDispatch\");function buildMockDispatch(){const agent=this[kMockAgent];const origin=this[kOrigin];const originalDispatch=this[kOriginalDispatch];return __name(function dispatch(opts,handler){if(agent.isMockActive){try{mockDispatch.call(this,opts,handler)}catch(error){if(error instanceof MockNotMatchedError){const netConnect=agent[kGetNetConnect]();if(netConnect===false){throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)}if(checkNetConnect(netConnect,origin)){originalDispatch.call(this,opts,handler)}else{throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)}}else{throw error}}}else{originalDispatch.call(this,opts,handler)}},\"dispatch\")}__name(buildMockDispatch,\"buildMockDispatch\");function checkNetConnect(netConnect,origin){const url=new URL(origin);if(netConnect===true){return true}else if(Array.isArray(netConnect)&&netConnect.some(matcher=>matchValue(matcher,url.host))){return true}return false}__name(checkNetConnect,\"checkNetConnect\");function buildMockOptions(opts){if(opts){const{agent,...mockOptions}=opts;return mockOptions}}__name(buildMockOptions,\"buildMockOptions\");module.exports={getResponseData,getMockDispatch,addMockDispatch,deleteMockDispatch,buildKey,generateKeyValues,matchValue,getResponse,getStatusText,mockDispatch,buildMockDispatch,checkNetConnect,buildMockOptions,getHeaderByName,buildHeadersFromArray};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["mockDispatch"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/mock/mock-utils.js"],"sourcesContent":["'use strict'\n\nconst { MockNotMatchedError } = require('./mock-errors')\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kGetNetConnect\n} = require('./mock-symbols')\nconst { buildURL } = require('../core/util')\nconst { STATUS_CODES } = require('node:http')\nconst {\n  types: {\n    isPromise\n  }\n} = require('node:util')\n\nfunction matchValue (match, value) {\n  if (typeof match === 'string') {\n    return match === value\n  }\n  if (match instanceof RegExp) {\n    return match.test(value)\n  }\n  if (typeof match === 'function') {\n    return match(value) === true\n  }\n  return false\n}\n\nfunction lowerCaseEntries (headers) {\n  return Object.fromEntries(\n    Object.entries(headers).map(([headerName, headerValue]) => {\n      return [headerName.toLocaleLowerCase(), headerValue]\n    })\n  )\n}\n\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */\nfunction getHeaderByName (headers, key) {\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n        return headers[i + 1]\n      }\n    }\n\n    return undefined\n  } else if (typeof headers.get === 'function') {\n    return headers.get(key)\n  } else {\n    return lowerCaseEntries(headers)[key.toLocaleLowerCase()]\n  }\n}\n\n/** @param {string[]} headers */\nfunction buildHeadersFromArray (headers) { // fetch HeadersList\n  const clone = headers.slice()\n  const entries = []\n  for (let index = 0; index < clone.length; index += 2) {\n    entries.push([clone[index], clone[index + 1]])\n  }\n  return Object.fromEntries(entries)\n}\n\nfunction matchHeaders (mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'function') {\n    if (Array.isArray(headers)) { // fetch HeadersList\n      headers = buildHeadersFromArray(headers)\n    }\n    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})\n  }\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true\n  }\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const headerValue = getHeaderByName(headers, matchHeaderName)\n\n    if (!matchValue(matchHeaderValue, headerValue)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction safeUrl (path) {\n  if (typeof path !== 'string') {\n    return path\n  }\n\n  const pathSegments = path.split('?')\n\n  if (pathSegments.length !== 2) {\n    return path\n  }\n\n  const qp = new URLSearchParams(pathSegments.pop())\n  qp.sort()\n  return [...pathSegments, qp.toString()].join('?')\n}\n\nfunction matchKey (mockDispatch, { path, method, body, headers }) {\n  const pathMatch = matchValue(mockDispatch.path, path)\n  const methodMatch = matchValue(mockDispatch.method, method)\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true\n  const headersMatch = matchHeaders(mockDispatch, headers)\n  return pathMatch && methodMatch && bodyMatch && headersMatch\n}\n\nfunction getResponseData (data) {\n  if (Buffer.isBuffer(data)) {\n    return data\n  } else if (data instanceof Uint8Array) {\n    return data\n  } else if (data instanceof ArrayBuffer) {\n    return data\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data)\n  } else {\n    return data.toString()\n  }\n}\n\nfunction getMockDispatch (mockDispatches, key) {\n  const basePath = key.query ? buildURL(key.path, key.query) : key.path\n  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath\n\n  // Match path\n  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)\n  }\n\n  // Match method\n  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`)\n  }\n\n  // Match body\n  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`)\n  }\n\n  // Match headers\n  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))\n  if (matchedMockDispatches.length === 0) {\n    const headers = typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`)\n  }\n\n  return matchedMockDispatches[0]\n}\n\nfunction addMockDispatch (mockDispatches, key, data) {\n  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false }\n  const replyData = typeof data === 'function' ? { callback: data } : { ...data }\n  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } }\n  mockDispatches.push(newMockDispatch)\n  return newMockDispatch\n}\n\nfunction deleteMockDispatch (mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false\n    }\n    return matchKey(dispatch, key)\n  })\n  if (index !== -1) {\n    mockDispatches.splice(index, 1)\n  }\n}\n\nfunction buildKey (opts) {\n  const { path, method, body, headers, query } = opts\n  return {\n    path,\n    method,\n    body,\n    headers,\n    query\n  }\n}\n\nfunction generateKeyValues (data) {\n  const keys = Object.keys(data)\n  const result = []\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i]\n    const value = data[key]\n    const name = Buffer.from(`${key}`)\n    if (Array.isArray(value)) {\n      for (let j = 0; j < value.length; ++j) {\n        result.push(name, Buffer.from(`${value[j]}`))\n      }\n    } else {\n      result.push(name, Buffer.from(`${value}`))\n    }\n  }\n  return result\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */\nfunction getStatusText (statusCode) {\n  return STATUS_CODES[statusCode] || 'unknown'\n}\n\nasync function getResponse (body) {\n  const buffers = []\n  for await (const data of body) {\n    buffers.push(data)\n  }\n  return Buffer.concat(buffers).toString('utf8')\n}\n\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\nfunction mockDispatch (opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts)\n  const mockDispatch = getMockDispatch(this[kDispatches], key)\n\n  mockDispatch.timesInvoked++\n\n  // Here's where we resolve a callback if a callback is present for the dispatch data.\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) }\n  }\n\n  // Parse mockDispatch data\n  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch\n  const { timesInvoked, times } = mockDispatch\n\n  // If it's used up and not persistent, mark as consumed\n  mockDispatch.consumed = !persist && timesInvoked >= times\n  mockDispatch.pending = timesInvoked < times\n\n  // If specified, trigger dispatch error\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key)\n    handler.onError(error)\n    return true\n  }\n\n  // Handle the request with a delay if necessary\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches])\n    }, delay)\n  } else {\n    handleReply(this[kDispatches])\n  }\n\n  function handleReply (mockDispatches, _data = data) {\n    // fetch's HeadersList is a 1D string array\n    const optsHeaders = Array.isArray(opts.headers)\n      ? buildHeadersFromArray(opts.headers)\n      : opts.headers\n    const body = typeof _data === 'function'\n      ? _data({ ...opts, headers: optsHeaders })\n      : _data\n\n    // util.types.isPromise is likely needed for jest.\n    if (isPromise(body)) {\n      // If handleReply is asynchronous, throwing an error\n      // in the callback will reject the promise, rather than\n      // synchronously throw the error, which breaks some tests.\n      // Rather, we wait for the callback to resolve if it is a\n      // promise, and then re-run handleReply with the new body.\n      body.then((newData) => handleReply(mockDispatches, newData))\n      return\n    }\n\n    const responseData = getResponseData(body)\n    const responseHeaders = generateKeyValues(headers)\n    const responseTrailers = generateKeyValues(trailers)\n\n    handler.onConnect?.(err => handler.onError(err), null)\n    handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode))\n    handler.onData?.(Buffer.from(responseData))\n    handler.onComplete?.(responseTrailers)\n    deleteMockDispatch(mockDispatches, key)\n  }\n\n  function resume () {}\n\n  return true\n}\n\nfunction buildMockDispatch () {\n  const agent = this[kMockAgent]\n  const origin = this[kOrigin]\n  const originalDispatch = this[kOriginalDispatch]\n\n  return function dispatch (opts, handler) {\n    if (agent.isMockActive) {\n      try {\n        mockDispatch.call(this, opts, handler)\n      } catch (error) {\n        if (error instanceof MockNotMatchedError) {\n          const netConnect = agent[kGetNetConnect]()\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)\n          }\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler)\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)\n          }\n        } else {\n          throw error\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler)\n    }\n  }\n}\n\nfunction checkNetConnect (netConnect, origin) {\n  const url = new URL(origin)\n  if (netConnect === true) {\n    return true\n  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n    return true\n  }\n  return false\n}\n\nfunction buildMockOptions (opts) {\n  if (opts) {\n    const { agent, ...mockOptions } = opts\n    return mockOptions\n  }\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  getStatusText,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildMockOptions,\n  getHeaderByName,\n  buildHeadersFromArray\n}\n"]}}