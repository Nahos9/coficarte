{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const util=require(\"../../core/util\");const{ReadableStreamFrom,isBlobLike,isReadableStreamLike,readableStreamClose,createDeferredPromise,fullyReadBody,extractMimeType,utf8DecodeBytes}=require(\"./util\");const{FormData}=require(\"./formdata\");const{kState}=require(\"./symbols\");const{webidl}=require(\"./webidl\");const{Blob}=require(\"node:buffer\");const assert=require(\"node:assert\");const{isErrored,isDisturbed}=require(\"node:stream\");const{isArrayBuffer}=require(\"node:util/types\");const{serializeAMimeType}=require(\"./data-url\");const{multipartFormDataParser}=require(\"./formdata-parser\");const textEncoder=new TextEncoder;function noop(){}__name(noop,\"noop\");const hasFinalizationRegistry=globalThis.FinalizationRegistry&&process.version.indexOf(\"v18\")!==0;let streamRegistry;if(hasFinalizationRegistry){streamRegistry=new FinalizationRegistry(weakRef=>{const stream=weakRef.deref();if(stream&&!stream.locked&&!isDisturbed(stream)&&!isErrored(stream)){stream.cancel(\"Response object has been garbage collected\").catch(noop)}})}function extractBody(object,keepalive=false){let stream=null;if(object instanceof ReadableStream){stream=object}else if(isBlobLike(object)){stream=object.stream()}else{stream=new ReadableStream({async pull(controller){const buffer=typeof source===\"string\"?textEncoder.encode(source):source;if(buffer.byteLength){controller.enqueue(buffer)}queueMicrotask(()=>readableStreamClose(controller))},start(){},type:\"bytes\"})}assert(isReadableStreamLike(stream));let action=null;let source=null;let length=null;let type=null;if(typeof object===\"string\"){source=object;type=\"text/plain;charset=UTF-8\"}else if(object instanceof URLSearchParams){source=object.toString();type=\"application/x-www-form-urlencoded;charset=UTF-8\"}else if(isArrayBuffer(object)){source=new Uint8Array(object.slice())}else if(ArrayBuffer.isView(object)){source=new Uint8Array(object.buffer.slice(object.byteOffset,object.byteOffset+object.byteLength))}else if(util.isFormDataLike(object)){const boundary=`----formdata-undici-0${`${Math.floor(Math.random()*1e11)}`.padStart(11,\"0\")}`;const prefix=`--${boundary}\\r\nContent-Disposition: form-data`;/*! formdata-polyfill. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */const escape=__name(str=>str.replace(/\\n/g,\"%0A\").replace(/\\r/g,\"%0D\").replace(/\"/g,\"%22\"),\"escape\");const normalizeLinefeeds=__name(value=>value.replace(/\\r?\\n|\\r/g,\"\\r\\n\"),\"normalizeLinefeeds\");const blobParts=[];const rn=new Uint8Array([13,10]);length=0;let hasUnknownSizeValue=false;for(const[name,value]of object){if(typeof value===\"string\"){const chunk2=textEncoder.encode(prefix+`; name=\"${escape(normalizeLinefeeds(name))}\"\\r\n\\r\n${normalizeLinefeeds(value)}\\r\n`);blobParts.push(chunk2);length+=chunk2.byteLength}else{const chunk2=textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"`+(value.name?`; filename=\"${escape(value.name)}\"`:\"\")+`\\r\nContent-Type: ${value.type||\"application/octet-stream\"}\\r\n\\r\n`);blobParts.push(chunk2,value,rn);if(typeof value.size===\"number\"){length+=chunk2.byteLength+value.size+rn.byteLength}else{hasUnknownSizeValue=true}}}const chunk=textEncoder.encode(`--${boundary}--`);blobParts.push(chunk);length+=chunk.byteLength;if(hasUnknownSizeValue){length=null}source=object;action=__name(async function*(){for(const part of blobParts){if(part.stream){yield*part.stream()}else{yield part}}},\"action\");type=`multipart/form-data; boundary=${boundary}`}else if(isBlobLike(object)){source=object;length=object.size;if(object.type){type=object.type}}else if(typeof object[Symbol.asyncIterator]===\"function\"){if(keepalive){throw new TypeError(\"keepalive\")}if(util.isDisturbed(object)||object.locked){throw new TypeError(\"Response body object should not be disturbed or locked\")}stream=object instanceof ReadableStream?object:ReadableStreamFrom(object)}if(typeof source===\"string\"||util.isBuffer(source)){length=Buffer.byteLength(source)}if(action!=null){let iterator;stream=new ReadableStream({async start(){iterator=action(object)[Symbol.asyncIterator]()},async pull(controller){const{value,done}=await iterator.next();if(done){queueMicrotask(()=>{controller.close();controller.byobRequest?.respond(0)})}else{if(!isErrored(stream)){const buffer=new Uint8Array(value);if(buffer.byteLength){controller.enqueue(buffer)}}}return controller.desiredSize>0},async cancel(reason){await iterator.return()},type:\"bytes\"})}const body={stream,source,length};return[body,type]}__name(extractBody,\"extractBody\");function safelyExtractBody(object,keepalive=false){if(object instanceof ReadableStream){assert(!util.isDisturbed(object),\"The body has already been consumed.\");assert(!object.locked,\"The stream is locked.\")}return extractBody(object,keepalive)}__name(safelyExtractBody,\"safelyExtractBody\");function cloneBody(instance,body){const[out1,out2]=body.stream.tee();if(hasFinalizationRegistry){streamRegistry.register(instance,new WeakRef(out1))}body.stream=out1;return{stream:out2,length:body.length,source:body.source}}__name(cloneBody,\"cloneBody\");function throwIfAborted(state){if(state.aborted){throw new DOMException(\"The operation was aborted.\",\"AbortError\")}}__name(throwIfAborted,\"throwIfAborted\");function bodyMixinMethods(instance){const methods={blob(){return consumeBody(this,bytes=>{let mimeType=bodyMimeType(this);if(mimeType===null){mimeType=\"\"}else if(mimeType){mimeType=serializeAMimeType(mimeType)}return new Blob([bytes],{type:mimeType})},instance)},arrayBuffer(){return consumeBody(this,bytes=>{return new Uint8Array(bytes).buffer},instance)},text(){return consumeBody(this,utf8DecodeBytes,instance)},json(){return consumeBody(this,parseJSONFromBytes,instance)},formData(){return consumeBody(this,value=>{const mimeType=bodyMimeType(this);if(mimeType!==null){switch(mimeType.essence){case\"multipart/form-data\":{const parsed=multipartFormDataParser(value,mimeType);if(parsed===\"failure\"){throw new TypeError(\"Failed to parse body as FormData.\")}const fd=new FormData;fd[kState]=parsed;return fd}case\"application/x-www-form-urlencoded\":{const entries=new URLSearchParams(value.toString());const fd=new FormData;for(const[name,value2]of entries){fd.append(name,value2)}return fd}}}throw new TypeError('Content-Type was not one of \"multipart/form-data\" or \"application/x-www-form-urlencoded\".')},instance)},bytes(){return consumeBody(this,bytes=>{return new Uint8Array(bytes)},instance)}};return methods}__name(bodyMixinMethods,\"bodyMixinMethods\");function mixinBody(prototype){Object.assign(prototype.prototype,bodyMixinMethods(prototype))}__name(mixinBody,\"mixinBody\");async function consumeBody(object,convertBytesToJSValue,instance){webidl.brandCheck(object,instance);if(bodyUnusable(object)){throw new TypeError(\"Body is unusable: Body has already been read\")}throwIfAborted(object[kState]);const promise=createDeferredPromise();const errorSteps=__name(error=>promise.reject(error),\"errorSteps\");const successSteps=__name(data=>{try{promise.resolve(convertBytesToJSValue(data))}catch(e){errorSteps(e)}},\"successSteps\");if(object[kState].body==null){successSteps(Buffer.allocUnsafe(0));return promise.promise}await fullyReadBody(object[kState].body,successSteps,errorSteps);return promise.promise}__name(consumeBody,\"consumeBody\");function bodyUnusable(object){const body=object[kState].body;return body!=null&&(body.stream.locked||util.isDisturbed(body.stream))}__name(bodyUnusable,\"bodyUnusable\");function parseJSONFromBytes(bytes){return JSON.parse(utf8DecodeBytes(bytes))}__name(parseJSONFromBytes,\"parseJSONFromBytes\");function bodyMimeType(requestOrResponse){const headers=requestOrResponse[kState].headersList;const mimeType=extractMimeType(headers);if(mimeType===\"failure\"){return null}return mimeType}__name(bodyMimeType,\"bodyMimeType\");module.exports={extractBody,safelyExtractBody,cloneBody,mixinBody,streamRegistry,hasFinalizationRegistry,bodyUnusable};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["chunk","value"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/fetch/body.js"],"sourcesContent":["'use strict'\n\nconst util = require('../../core/util')\nconst {\n  ReadableStreamFrom,\n  isBlobLike,\n  isReadableStreamLike,\n  readableStreamClose,\n  createDeferredPromise,\n  fullyReadBody,\n  extractMimeType,\n  utf8DecodeBytes\n} = require('./util')\nconst { FormData } = require('./formdata')\nconst { kState } = require('./symbols')\nconst { webidl } = require('./webidl')\nconst { Blob } = require('node:buffer')\nconst assert = require('node:assert')\nconst { isErrored, isDisturbed } = require('node:stream')\nconst { isArrayBuffer } = require('node:util/types')\nconst { serializeAMimeType } = require('./data-url')\nconst { multipartFormDataParser } = require('./formdata-parser')\n\nconst textEncoder = new TextEncoder()\nfunction noop () {}\n\nconst hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf('v18') !== 0\nlet streamRegistry\n\nif (hasFinalizationRegistry) {\n  streamRegistry = new FinalizationRegistry((weakRef) => {\n    const stream = weakRef.deref()\n    if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {\n      stream.cancel('Response object has been garbage collected').catch(noop)\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  // 1. Let stream be null.\n  let stream = null\n\n  // 2. If object is a ReadableStream object, then set stream to object.\n  if (object instanceof ReadableStream) {\n    stream = object\n  } else if (isBlobLike(object)) {\n    // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running objectâs get stream.\n    stream = object.stream()\n  } else {\n    // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream with byte reading support.\n    stream = new ReadableStream({\n      async pull (controller) {\n        const buffer = typeof source === 'string' ? textEncoder.encode(source) : source\n\n        if (buffer.byteLength) {\n          controller.enqueue(buffer)\n        }\n\n        queueMicrotask(() => readableStreamClose(controller))\n      },\n      start () {},\n      type: 'bytes'\n    })\n  }\n\n  // 5. Assert: stream is a ReadableStream object.\n  assert(isReadableStreamLike(stream))\n\n  // 6. Let action be null.\n  let action = null\n\n  // 7. Let source be null.\n  let source = null\n\n  // 8. Let length be null.\n  let length = null\n\n  // 9. Let type be null.\n  let type = null\n\n  // 10. Switch on object:\n  if (typeof object === 'string') {\n    // Set source to the UTF-8 encoding of object.\n    // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n    source = object\n\n    // Set type to `text/plain;charset=UTF-8`.\n    type = 'text/plain;charset=UTF-8'\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with objectâs list.\n    source = object.toString()\n\n    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    type = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice())\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength))\n  } else if (util.isFormDataLike(object)) {\n    const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, '0')}`\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with objectâs entry list and UTF-8.\n    // - This ensures that the body is immutable and can't be changed afterwords\n    // - That the content-length is calculated in advance.\n    // - And that all parts are pre-encoded and ready to be sent.\n\n    const blobParts = []\n    const rn = new Uint8Array([13, 10]) // '\\r\\n'\n    length = 0\n    let hasUnknownSizeValue = false\n\n    for (const [name, value] of object) {\n      if (typeof value === 'string') {\n        const chunk = textEncoder.encode(prefix +\n          `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`)\n        blobParts.push(chunk)\n        length += chunk.byteLength\n      } else {\n        const chunk = textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' +\n          `Content-Type: ${\n            value.type || 'application/octet-stream'\n          }\\r\\n\\r\\n`)\n        blobParts.push(chunk, value, rn)\n        if (typeof value.size === 'number') {\n          length += chunk.byteLength + value.size + rn.byteLength\n        } else {\n          hasUnknownSizeValue = true\n        }\n      }\n    }\n\n    const chunk = textEncoder.encode(`--${boundary}--`)\n    blobParts.push(chunk)\n    length += chunk.byteLength\n    if (hasUnknownSizeValue) {\n      length = null\n    }\n\n    // Set source to object.\n    source = object\n\n    action = async function * () {\n      for (const part of blobParts) {\n        if (part.stream) {\n          yield * part.stream()\n        } else {\n          yield part\n        }\n      }\n    }\n\n    // Set type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    type = `multipart/form-data; boundary=${boundary}`\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set source to object.\n    source = object\n\n    // Set length to objectâs size.\n    length = object.size\n\n    // If objectâs type attribute is not the empty byte sequence, set\n    // type to its value.\n    if (object.type) {\n      type = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      object instanceof ReadableStream ? object : ReadableStreamFrom(object)\n  }\n\n  // 11. If source is a byte sequence, then set action to a\n  // step that returns source and length to sourceâs length.\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 12. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n            controller.byobRequest?.respond(0)\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            const buffer = new Uint8Array(value)\n            if (buffer.byteLength) {\n              controller.enqueue(buffer)\n            }\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      },\n      type: 'bytes'\n    })\n  }\n\n  // 13. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 14. Return (body, type).\n  return [body, type]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.')\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (instance, body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let Â« out1, out2 Â» be the result of teeing bodyâs stream.\n  const [out1, out2] = body.stream.tee()\n\n  if (hasFinalizationRegistry) {\n    streamRegistry.register(instance, new WeakRef(out1))\n  }\n\n  // 2. Set bodyâs stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  }\n}\n\nfunction throwIfAborted (state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError')\n  }\n}\n\nfunction bodyMixinMethods (instance) {\n  const methods = {\n    blob () {\n      // The blob() method steps are to return the result of\n      // running consume body with this and the following step\n      // given a byte sequence bytes: return a Blob whose\n      // contents are bytes and whose type attribute is thisâs\n      // MIME type.\n      return consumeBody(this, (bytes) => {\n        let mimeType = bodyMimeType(this)\n\n        if (mimeType === null) {\n          mimeType = ''\n        } else if (mimeType) {\n          mimeType = serializeAMimeType(mimeType)\n        }\n\n        // Return a Blob whose contents are bytes and type attribute\n        // is mimeType.\n        return new Blob([bytes], { type: mimeType })\n      }, instance)\n    },\n\n    arrayBuffer () {\n      // The arrayBuffer() method steps are to return the result\n      // of running consume body with this and the following step\n      // given a byte sequence bytes: return a new ArrayBuffer\n      // whose contents are bytes.\n      return consumeBody(this, (bytes) => {\n        return new Uint8Array(bytes).buffer\n      }, instance)\n    },\n\n    text () {\n      // The text() method steps are to return the result of running\n      // consume body with this and UTF-8 decode.\n      return consumeBody(this, utf8DecodeBytes, instance)\n    },\n\n    json () {\n      // The json() method steps are to return the result of running\n      // consume body with this and parse JSON from bytes.\n      return consumeBody(this, parseJSONFromBytes, instance)\n    },\n\n    formData () {\n      // The formData() method steps are to return the result of running\n      // consume body with this and the following step given a byte sequence bytes:\n      return consumeBody(this, (value) => {\n        // 1. Let mimeType be the result of get the MIME type with this.\n        const mimeType = bodyMimeType(this)\n\n        // 2. If mimeType is non-null, then switch on mimeTypeâs essence and run\n        //    the corresponding steps:\n        if (mimeType !== null) {\n          switch (mimeType.essence) {\n            case 'multipart/form-data': {\n              // 1. ... [long step]\n              const parsed = multipartFormDataParser(value, mimeType)\n\n              // 2. If that fails for some reason, then throw a TypeError.\n              if (parsed === 'failure') {\n                throw new TypeError('Failed to parse body as FormData.')\n              }\n\n              // 3. Return a new FormData object, appending each entry,\n              //    resulting from the parsing operation, to its entry list.\n              const fd = new FormData()\n              fd[kState] = parsed\n\n              return fd\n            }\n            case 'application/x-www-form-urlencoded': {\n              // 1. Let entries be the result of parsing bytes.\n              const entries = new URLSearchParams(value.toString())\n\n              // 2. If entries is failure, then throw a TypeError.\n\n              // 3. Return a new FormData object whose entry list is entries.\n              const fd = new FormData()\n\n              for (const [name, value] of entries) {\n                fd.append(name, value)\n              }\n\n              return fd\n            }\n          }\n        }\n\n        // 3. Throw a TypeError.\n        throw new TypeError(\n          'Content-Type was not one of \"multipart/form-data\" or \"application/x-www-form-urlencoded\".'\n        )\n      }, instance)\n    },\n\n    bytes () {\n      // The bytes() method steps are to return the result of running consume body\n      // with this and the following step given a byte sequence bytes: return the\n      // result of creating a Uint8Array from bytes in thisâs relevant realm.\n      return consumeBody(this, (bytes) => {\n        return new Uint8Array(bytes)\n      }, instance)\n    }\n  }\n\n  return methods\n}\n\nfunction mixinBody (prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */\nasync function consumeBody (object, convertBytesToJSValue, instance) {\n  webidl.brandCheck(object, instance)\n\n  // 1. If object is unusable, then return a promise rejected\n  //    with a TypeError.\n  if (bodyUnusable(object)) {\n    throw new TypeError('Body is unusable: Body has already been read')\n  }\n\n  throwIfAborted(object[kState])\n\n  // 2. Let promise be a new promise.\n  const promise = createDeferredPromise()\n\n  // 3. Let errorSteps given error be to reject promise with error.\n  const errorSteps = (error) => promise.reject(error)\n\n  // 4. Let successSteps given a byte sequence data be to resolve\n  //    promise with the result of running convertBytesToJSValue\n  //    with data. If that threw an exception, then run errorSteps\n  //    with that exception.\n  const successSteps = (data) => {\n    try {\n      promise.resolve(convertBytesToJSValue(data))\n    } catch (e) {\n      errorSteps(e)\n    }\n  }\n\n  // 5. If objectâs body is null, then run successSteps with an\n  //    empty byte sequence.\n  if (object[kState].body == null) {\n    successSteps(Buffer.allocUnsafe(0))\n    return promise.promise\n  }\n\n  // 6. Otherwise, fully read objectâs body given successSteps,\n  //    errorSteps, and objectâs relevant global object.\n  await fullyReadBody(object[kState].body, successSteps, errorSteps)\n\n  // 7. Return promise.\n  return promise.promise\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable (object) {\n  const body = object[kState].body\n\n  // An object including the Body interface mixin is\n  // said to be unusable if its body is non-null and\n  // its bodyâs stream is disturbed or locked.\n  return body != null && (body.stream.locked || util.isDisturbed(body.stream))\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */\nfunction parseJSONFromBytes (bytes) {\n  return JSON.parse(utf8DecodeBytes(bytes))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} requestOrResponse\n */\nfunction bodyMimeType (requestOrResponse) {\n  // 1. Let headers be null.\n  // 2. If requestOrResponse is a Request object, then set headers to requestOrResponseâs requestâs header list.\n  // 3. Otherwise, set headers to requestOrResponseâs responseâs header list.\n  /** @type {import('./headers').HeadersList} */\n  const headers = requestOrResponse[kState].headersList\n\n  // 4. Let mimeType be the result of extracting a MIME type from headers.\n  const mimeType = extractMimeType(headers)\n\n  // 5. If mimeType is failure, then return null.\n  if (mimeType === 'failure') {\n    return null\n  }\n\n  // 6. Return mimeType.\n  return mimeType\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody,\n  streamRegistry,\n  hasFinalizationRegistry,\n  bodyUnusable\n}\n"]}}