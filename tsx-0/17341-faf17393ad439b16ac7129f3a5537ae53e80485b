{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const assert=require(\"node:assert\");const{kRetryHandlerDefaultRetry}=require(\"../core/symbols\");const{RequestRetryError}=require(\"../core/errors\");const{isDisturbed,parseHeaders,parseRangeHeader,wrapRequestBody}=require(\"../core/util\");function calculateRetryAfterHeader(retryAfter){const current=Date.now();return new Date(retryAfter).getTime()-current}__name(calculateRetryAfterHeader,\"calculateRetryAfterHeader\");class RetryHandler{static{__name(this,\"RetryHandler\")}constructor(opts,handlers){const{retryOptions,...dispatchOpts}=opts;const{retry:retryFn,maxRetries,maxTimeout,minTimeout,timeoutFactor,methods,errorCodes,retryAfter,statusCodes}=retryOptions??{};this.dispatch=handlers.dispatch;this.handler=handlers.handler;this.opts={...dispatchOpts,body:wrapRequestBody(opts.body)};this.abort=null;this.aborted=false;this.retryOpts={retry:retryFn??RetryHandler[kRetryHandlerDefaultRetry],retryAfter:retryAfter??true,maxTimeout:maxTimeout??30*1e3,minTimeout:minTimeout??500,timeoutFactor:timeoutFactor??2,maxRetries:maxRetries??5,methods:methods??[\"GET\",\"HEAD\",\"OPTIONS\",\"PUT\",\"DELETE\",\"TRACE\"],statusCodes:statusCodes??[500,502,503,504,429],errorCodes:errorCodes??[\"ECONNRESET\",\"ECONNREFUSED\",\"ENOTFOUND\",\"ENETDOWN\",\"ENETUNREACH\",\"EHOSTDOWN\",\"EHOSTUNREACH\",\"EPIPE\",\"UND_ERR_SOCKET\"]};this.retryCount=0;this.retryCountCheckpoint=0;this.start=0;this.end=null;this.etag=null;this.resume=null;this.handler.onConnect(reason=>{this.aborted=true;if(this.abort){this.abort(reason)}else{this.reason=reason}})}onRequestSent(){if(this.handler.onRequestSent){this.handler.onRequestSent()}}onUpgrade(statusCode,headers,socket){if(this.handler.onUpgrade){this.handler.onUpgrade(statusCode,headers,socket)}}onConnect(abort){if(this.aborted){abort(this.reason)}else{this.abort=abort}}onBodySent(chunk){if(this.handler.onBodySent)return this.handler.onBodySent(chunk)}static[kRetryHandlerDefaultRetry](err,{state,opts},cb){const{statusCode,code,headers}=err;const{method,retryOptions}=opts;const{maxRetries,minTimeout,maxTimeout,timeoutFactor,statusCodes,errorCodes,methods}=retryOptions;const{counter}=state;if(code&&code!==\"UND_ERR_REQ_RETRY\"&&!errorCodes.includes(code)){cb(err);return}if(Array.isArray(methods)&&!methods.includes(method)){cb(err);return}if(statusCode!=null&&Array.isArray(statusCodes)&&!statusCodes.includes(statusCode)){cb(err);return}if(counter>maxRetries){cb(err);return}let retryAfterHeader=headers?.[\"retry-after\"];if(retryAfterHeader){retryAfterHeader=Number(retryAfterHeader);retryAfterHeader=Number.isNaN(retryAfterHeader)?calculateRetryAfterHeader(retryAfterHeader):retryAfterHeader*1e3}const retryTimeout=retryAfterHeader>0?Math.min(retryAfterHeader,maxTimeout):Math.min(minTimeout*timeoutFactor**(counter-1),maxTimeout);setTimeout(()=>cb(null),retryTimeout)}onHeaders(statusCode,rawHeaders,resume,statusMessage){const headers=parseHeaders(rawHeaders);this.retryCount+=1;if(statusCode>=300){if(this.retryOpts.statusCodes.includes(statusCode)===false){return this.handler.onHeaders(statusCode,rawHeaders,resume,statusMessage)}else{this.abort(new RequestRetryError(\"Request failed\",statusCode,{headers,data:{count:this.retryCount}}));return false}}if(this.resume!=null){this.resume=null;if(statusCode!==206&&(this.start>0||statusCode!==200)){this.abort(new RequestRetryError(\"server does not support the range header and the payload was partially consumed\",statusCode,{headers,data:{count:this.retryCount}}));return false}const contentRange=parseRangeHeader(headers[\"content-range\"]);if(!contentRange){this.abort(new RequestRetryError(\"Content-Range mismatch\",statusCode,{headers,data:{count:this.retryCount}}));return false}if(this.etag!=null&&this.etag!==headers.etag){this.abort(new RequestRetryError(\"ETag mismatch\",statusCode,{headers,data:{count:this.retryCount}}));return false}const{start,size,end=size-1}=contentRange;assert(this.start===start,\"content-range mismatch\");assert(this.end==null||this.end===end,\"content-range mismatch\");this.resume=resume;return true}if(this.end==null){if(statusCode===206){const range=parseRangeHeader(headers[\"content-range\"]);if(range==null){return this.handler.onHeaders(statusCode,rawHeaders,resume,statusMessage)}const{start,size,end=size-1}=range;assert(start!=null&&Number.isFinite(start),\"content-range mismatch\");assert(end!=null&&Number.isFinite(end),\"invalid content-length\");this.start=start;this.end=end}if(this.end==null){const contentLength=headers[\"content-length\"];this.end=contentLength!=null?Number(contentLength)-1:null}assert(Number.isFinite(this.start));assert(this.end==null||Number.isFinite(this.end),\"invalid content-length\");this.resume=resume;this.etag=headers.etag!=null?headers.etag:null;if(this.etag!=null&&this.etag.startsWith(\"W/\")){this.etag=null}return this.handler.onHeaders(statusCode,rawHeaders,resume,statusMessage)}const err=new RequestRetryError(\"Request failed\",statusCode,{headers,data:{count:this.retryCount}});this.abort(err);return false}onData(chunk){this.start+=chunk.length;return this.handler.onData(chunk)}onComplete(rawTrailers){this.retryCount=0;return this.handler.onComplete(rawTrailers)}onError(err){if(this.aborted||isDisturbed(this.opts.body)){return this.handler.onError(err)}if(this.retryCount-this.retryCountCheckpoint>0){this.retryCount=this.retryCountCheckpoint+(this.retryCount-this.retryCountCheckpoint)}else{this.retryCount+=1}this.retryOpts.retry(err,{state:{counter:this.retryCount},opts:{retryOptions:this.retryOpts,...this.opts}},onRetry.bind(this));function onRetry(err2){if(err2!=null||this.aborted||isDisturbed(this.opts.body)){return this.handler.onError(err2)}if(this.start!==0){const headers={range:`bytes=${this.start}-${this.end??\"\"}`};if(this.etag!=null){headers[\"if-match\"]=this.etag}this.opts={...this.opts,headers:{...this.opts.headers,...headers}}}try{this.retryCountCheckpoint=this.retryCount;this.dispatch(this.opts,this)}catch(err3){this.handler.onError(err3)}}__name(onRetry,\"onRetry\")}}module.exports=RetryHandler;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["err"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/handler/retry-handler.js"],"sourcesContent":["'use strict'\nconst assert = require('node:assert')\n\nconst { kRetryHandlerDefaultRetry } = require('../core/symbols')\nconst { RequestRetryError } = require('../core/errors')\nconst {\n  isDisturbed,\n  parseHeaders,\n  parseRangeHeader,\n  wrapRequestBody\n} = require('../core/util')\n\nfunction calculateRetryAfterHeader (retryAfter) {\n  const current = Date.now()\n  return new Date(retryAfter).getTime() - current\n}\n\nclass RetryHandler {\n  constructor (opts, handlers) {\n    const { retryOptions, ...dispatchOpts } = opts\n    const {\n      // Retry scoped\n      retry: retryFn,\n      maxRetries,\n      maxTimeout,\n      minTimeout,\n      timeoutFactor,\n      // Response scoped\n      methods,\n      errorCodes,\n      retryAfter,\n      statusCodes\n    } = retryOptions ?? {}\n\n    this.dispatch = handlers.dispatch\n    this.handler = handlers.handler\n    this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) }\n    this.abort = null\n    this.aborted = false\n    this.retryOpts = {\n      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],\n      retryAfter: retryAfter ?? true,\n      maxTimeout: maxTimeout ?? 30 * 1000, // 30s,\n      minTimeout: minTimeout ?? 500, // .5s\n      timeoutFactor: timeoutFactor ?? 2,\n      maxRetries: maxRetries ?? 5,\n      // What errors we should retry\n      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],\n      // Indicates which errors to retry\n      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],\n      // List of errors to retry\n      errorCodes: errorCodes ?? [\n        'ECONNRESET',\n        'ECONNREFUSED',\n        'ENOTFOUND',\n        'ENETDOWN',\n        'ENETUNREACH',\n        'EHOSTDOWN',\n        'EHOSTUNREACH',\n        'EPIPE',\n        'UND_ERR_SOCKET'\n      ]\n    }\n\n    this.retryCount = 0\n    this.retryCountCheckpoint = 0\n    this.start = 0\n    this.end = null\n    this.etag = null\n    this.resume = null\n\n    // Handle possible onConnect duplication\n    this.handler.onConnect(reason => {\n      this.aborted = true\n      if (this.abort) {\n        this.abort(reason)\n      } else {\n        this.reason = reason\n      }\n    })\n  }\n\n  onRequestSent () {\n    if (this.handler.onRequestSent) {\n      this.handler.onRequestSent()\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    if (this.handler.onUpgrade) {\n      this.handler.onUpgrade(statusCode, headers, socket)\n    }\n  }\n\n  onConnect (abort) {\n    if (this.aborted) {\n      abort(this.reason)\n    } else {\n      this.abort = abort\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this.handler.onBodySent) return this.handler.onBodySent(chunk)\n  }\n\n  static [kRetryHandlerDefaultRetry] (err, { state, opts }, cb) {\n    const { statusCode, code, headers } = err\n    const { method, retryOptions } = opts\n    const {\n      maxRetries,\n      minTimeout,\n      maxTimeout,\n      timeoutFactor,\n      statusCodes,\n      errorCodes,\n      methods\n    } = retryOptions\n    const { counter } = state\n\n    // Any code that is not a Undici's originated and allowed to retry\n    if (code && code !== 'UND_ERR_REQ_RETRY' && !errorCodes.includes(code)) {\n      cb(err)\n      return\n    }\n\n    // If a set of method are provided and the current method is not in the list\n    if (Array.isArray(methods) && !methods.includes(method)) {\n      cb(err)\n      return\n    }\n\n    // If a set of status code are provided and the current status code is not in the list\n    if (\n      statusCode != null &&\n      Array.isArray(statusCodes) &&\n      !statusCodes.includes(statusCode)\n    ) {\n      cb(err)\n      return\n    }\n\n    // If we reached the max number of retries\n    if (counter > maxRetries) {\n      cb(err)\n      return\n    }\n\n    let retryAfterHeader = headers?.['retry-after']\n    if (retryAfterHeader) {\n      retryAfterHeader = Number(retryAfterHeader)\n      retryAfterHeader = Number.isNaN(retryAfterHeader)\n        ? calculateRetryAfterHeader(retryAfterHeader)\n        : retryAfterHeader * 1e3 // Retry-After is in seconds\n    }\n\n    const retryTimeout =\n      retryAfterHeader > 0\n        ? Math.min(retryAfterHeader, maxTimeout)\n        : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout)\n\n    setTimeout(() => cb(null), retryTimeout)\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const headers = parseHeaders(rawHeaders)\n\n    this.retryCount += 1\n\n    if (statusCode >= 300) {\n      if (this.retryOpts.statusCodes.includes(statusCode) === false) {\n        return this.handler.onHeaders(\n          statusCode,\n          rawHeaders,\n          resume,\n          statusMessage\n        )\n      } else {\n        this.abort(\n          new RequestRetryError('Request failed', statusCode, {\n            headers,\n            data: {\n              count: this.retryCount\n            }\n          })\n        )\n        return false\n      }\n    }\n\n    // Checkpoint for resume from where we left it\n    if (this.resume != null) {\n      this.resume = null\n\n      // Only Partial Content 206 supposed to provide Content-Range,\n      // any other status code that partially consumed the payload\n      // should not be retry because it would result in downstream\n      // wrongly concatanete multiple responses.\n      if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {\n        this.abort(\n          new RequestRetryError('server does not support the range header and the payload was partially consumed', statusCode, {\n            headers,\n            data: { count: this.retryCount }\n          })\n        )\n        return false\n      }\n\n      const contentRange = parseRangeHeader(headers['content-range'])\n      // If no content range\n      if (!contentRange) {\n        this.abort(\n          new RequestRetryError('Content-Range mismatch', statusCode, {\n            headers,\n            data: { count: this.retryCount }\n          })\n        )\n        return false\n      }\n\n      // Let's start with a weak etag check\n      if (this.etag != null && this.etag !== headers.etag) {\n        this.abort(\n          new RequestRetryError('ETag mismatch', statusCode, {\n            headers,\n            data: { count: this.retryCount }\n          })\n        )\n        return false\n      }\n\n      const { start, size, end = size - 1 } = contentRange\n\n      assert(this.start === start, 'content-range mismatch')\n      assert(this.end == null || this.end === end, 'content-range mismatch')\n\n      this.resume = resume\n      return true\n    }\n\n    if (this.end == null) {\n      if (statusCode === 206) {\n        // First time we receive 206\n        const range = parseRangeHeader(headers['content-range'])\n\n        if (range == null) {\n          return this.handler.onHeaders(\n            statusCode,\n            rawHeaders,\n            resume,\n            statusMessage\n          )\n        }\n\n        const { start, size, end = size - 1 } = range\n        assert(\n          start != null && Number.isFinite(start),\n          'content-range mismatch'\n        )\n        assert(end != null && Number.isFinite(end), 'invalid content-length')\n\n        this.start = start\n        this.end = end\n      }\n\n      // We make our best to checkpoint the body for further range headers\n      if (this.end == null) {\n        const contentLength = headers['content-length']\n        this.end = contentLength != null ? Number(contentLength) - 1 : null\n      }\n\n      assert(Number.isFinite(this.start))\n      assert(\n        this.end == null || Number.isFinite(this.end),\n        'invalid content-length'\n      )\n\n      this.resume = resume\n      this.etag = headers.etag != null ? headers.etag : null\n\n      // Weak etags are not useful for comparison nor cache\n      // for instance not safe to assume if the response is byte-per-byte\n      // equal\n      if (this.etag != null && this.etag.startsWith('W/')) {\n        this.etag = null\n      }\n\n      return this.handler.onHeaders(\n        statusCode,\n        rawHeaders,\n        resume,\n        statusMessage\n      )\n    }\n\n    const err = new RequestRetryError('Request failed', statusCode, {\n      headers,\n      data: { count: this.retryCount }\n    })\n\n    this.abort(err)\n\n    return false\n  }\n\n  onData (chunk) {\n    this.start += chunk.length\n\n    return this.handler.onData(chunk)\n  }\n\n  onComplete (rawTrailers) {\n    this.retryCount = 0\n    return this.handler.onComplete(rawTrailers)\n  }\n\n  onError (err) {\n    if (this.aborted || isDisturbed(this.opts.body)) {\n      return this.handler.onError(err)\n    }\n\n    // We reconcile in case of a mix between network errors\n    // and server error response\n    if (this.retryCount - this.retryCountCheckpoint > 0) {\n      // We count the difference between the last checkpoint and the current retry count\n      this.retryCount =\n        this.retryCountCheckpoint +\n        (this.retryCount - this.retryCountCheckpoint)\n    } else {\n      this.retryCount += 1\n    }\n\n    this.retryOpts.retry(\n      err,\n      {\n        state: { counter: this.retryCount },\n        opts: { retryOptions: this.retryOpts, ...this.opts }\n      },\n      onRetry.bind(this)\n    )\n\n    function onRetry (err) {\n      if (err != null || this.aborted || isDisturbed(this.opts.body)) {\n        return this.handler.onError(err)\n      }\n\n      if (this.start !== 0) {\n        const headers = { range: `bytes=${this.start}-${this.end ?? ''}` }\n\n        // Weak etag check - weak etags will make comparison algorithms never match\n        if (this.etag != null) {\n          headers['if-match'] = this.etag\n        }\n\n        this.opts = {\n          ...this.opts,\n          headers: {\n            ...this.opts.headers,\n            ...headers\n          }\n        }\n      }\n\n      try {\n        this.retryCountCheckpoint = this.retryCount\n        this.dispatch(this.opts, this)\n      } catch (err) {\n        this.handler.onError(err)\n      }\n    }\n  }\n}\n\nmodule.exports = RetryHandler\n"]}}