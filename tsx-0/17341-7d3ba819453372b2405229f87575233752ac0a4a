{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{Transform}=require(\"node:stream\");const zlib=require(\"node:zlib\");const{redirectStatusSet,referrerPolicySet:referrerPolicyTokens,badPortsSet}=require(\"./constants\");const{getGlobalOrigin}=require(\"./global\");const{collectASequenceOfCodePoints,collectAnHTTPQuotedString,removeChars,parseMIMEType}=require(\"./data-url\");const{performance}=require(\"node:perf_hooks\");const{isBlobLike,ReadableStreamFrom,isValidHTTPToken,normalizedMethodRecordsBase}=require(\"../../core/util\");const assert=require(\"node:assert\");const{isUint8Array}=require(\"node:util/types\");const{webidl}=require(\"./webidl\");let supportedHashes=[];let crypto;try{crypto=require(\"node:crypto\");const possibleRelevantHashes=[\"sha256\",\"sha384\",\"sha512\"];supportedHashes=crypto.getHashes().filter(hash=>possibleRelevantHashes.includes(hash))}catch{}function responseURL(response){const urlList=response.urlList;const length=urlList.length;return length===0?null:urlList[length-1].toString()}__name(responseURL,\"responseURL\");function responseLocationURL(response,requestFragment){if(!redirectStatusSet.has(response.status)){return null}let location=response.headersList.get(\"location\",true);if(location!==null&&isValidHeaderValue(location)){if(!isValidEncodedURL(location)){location=normalizeBinaryStringToUtf8(location)}location=new URL(location,responseURL(response))}if(location&&!location.hash){location.hash=requestFragment}return location}__name(responseLocationURL,\"responseLocationURL\");function isValidEncodedURL(url){for(let i=0;i<url.length;++i){const code=url.charCodeAt(i);if(code>126||code<32){return false}}return true}__name(isValidEncodedURL,\"isValidEncodedURL\");function normalizeBinaryStringToUtf8(value){return Buffer.from(value,\"binary\").toString(\"utf8\")}__name(normalizeBinaryStringToUtf8,\"normalizeBinaryStringToUtf8\");function requestCurrentURL(request){return request.urlList[request.urlList.length-1]}__name(requestCurrentURL,\"requestCurrentURL\");function requestBadPort(request){const url=requestCurrentURL(request);if(urlIsHttpHttpsScheme(url)&&badPortsSet.has(url.port)){return\"blocked\"}return\"allowed\"}__name(requestBadPort,\"requestBadPort\");function isErrorLike(object){return object instanceof Error||(object?.constructor?.name===\"Error\"||object?.constructor?.name===\"DOMException\")}__name(isErrorLike,\"isErrorLike\");function isValidReasonPhrase(statusText){for(let i=0;i<statusText.length;++i){const c=statusText.charCodeAt(i);if(!(c===9||c>=32&&c<=126||c>=128&&c<=255)){return false}}return true}__name(isValidReasonPhrase,\"isValidReasonPhrase\");const isValidHeaderName=isValidHTTPToken;function isValidHeaderValue(potentialValue){return(potentialValue[0]===\"\t\"||potentialValue[0]===\" \"||potentialValue[potentialValue.length-1]===\"\t\"||potentialValue[potentialValue.length-1]===\" \"||potentialValue.includes(\"\\n\")||potentialValue.includes(\"\\r\")||potentialValue.includes(\"\\0\"))===false}__name(isValidHeaderValue,\"isValidHeaderValue\");function setRequestReferrerPolicyOnRedirect(request,actualResponse){const{headersList}=actualResponse;const policyHeader=(headersList.get(\"referrer-policy\",true)??\"\").split(\",\");let policy=\"\";if(policyHeader.length>0){for(let i=policyHeader.length;i!==0;i--){const token=policyHeader[i-1].trim();if(referrerPolicyTokens.has(token)){policy=token;break}}}if(policy!==\"\"){request.referrerPolicy=policy}}__name(setRequestReferrerPolicyOnRedirect,\"setRequestReferrerPolicyOnRedirect\");function crossOriginResourcePolicyCheck(){return\"allowed\"}__name(crossOriginResourcePolicyCheck,\"crossOriginResourcePolicyCheck\");function corsCheck(){return\"success\"}__name(corsCheck,\"corsCheck\");function TAOCheck(){return\"success\"}__name(TAOCheck,\"TAOCheck\");function appendFetchMetadata(httpRequest){let header=null;header=httpRequest.mode;httpRequest.headersList.set(\"sec-fetch-mode\",header,true)}__name(appendFetchMetadata,\"appendFetchMetadata\");function appendRequestOriginHeader(request){let serializedOrigin=request.origin;if(serializedOrigin===\"client\"||serializedOrigin===void 0){return}if(request.responseTainting===\"cors\"||request.mode===\"websocket\"){request.headersList.append(\"origin\",serializedOrigin,true)}else if(request.method!==\"GET\"&&request.method!==\"HEAD\"){switch(request.referrerPolicy){case\"no-referrer\":serializedOrigin=null;break;case\"no-referrer-when-downgrade\":case\"strict-origin\":case\"strict-origin-when-cross-origin\":if(request.origin&&urlHasHttpsScheme(request.origin)&&!urlHasHttpsScheme(requestCurrentURL(request))){serializedOrigin=null}break;case\"same-origin\":if(!sameOrigin(request,requestCurrentURL(request))){serializedOrigin=null}break;default:}request.headersList.append(\"origin\",serializedOrigin,true)}}__name(appendRequestOriginHeader,\"appendRequestOriginHeader\");function coarsenTime(timestamp,crossOriginIsolatedCapability){return timestamp}__name(coarsenTime,\"coarsenTime\");function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo,defaultStartTime,crossOriginIsolatedCapability){if(!connectionTimingInfo?.startTime||connectionTimingInfo.startTime<defaultStartTime){return{domainLookupStartTime:defaultStartTime,domainLookupEndTime:defaultStartTime,connectionStartTime:defaultStartTime,connectionEndTime:defaultStartTime,secureConnectionStartTime:defaultStartTime,ALPNNegotiatedProtocol:connectionTimingInfo?.ALPNNegotiatedProtocol}}return{domainLookupStartTime:coarsenTime(connectionTimingInfo.domainLookupStartTime,crossOriginIsolatedCapability),domainLookupEndTime:coarsenTime(connectionTimingInfo.domainLookupEndTime,crossOriginIsolatedCapability),connectionStartTime:coarsenTime(connectionTimingInfo.connectionStartTime,crossOriginIsolatedCapability),connectionEndTime:coarsenTime(connectionTimingInfo.connectionEndTime,crossOriginIsolatedCapability),secureConnectionStartTime:coarsenTime(connectionTimingInfo.secureConnectionStartTime,crossOriginIsolatedCapability),ALPNNegotiatedProtocol:connectionTimingInfo.ALPNNegotiatedProtocol}}__name(clampAndCoarsenConnectionTimingInfo,\"clampAndCoarsenConnectionTimingInfo\");function coarsenedSharedCurrentTime(crossOriginIsolatedCapability){return coarsenTime(performance.now(),crossOriginIsolatedCapability)}__name(coarsenedSharedCurrentTime,\"coarsenedSharedCurrentTime\");function createOpaqueTimingInfo(timingInfo){return{startTime:timingInfo.startTime??0,redirectStartTime:0,redirectEndTime:0,postRedirectStartTime:timingInfo.startTime??0,finalServiceWorkerStartTime:0,finalNetworkResponseStartTime:0,finalNetworkRequestStartTime:0,endTime:0,encodedBodySize:0,decodedBodySize:0,finalConnectionTimingInfo:null}}__name(createOpaqueTimingInfo,\"createOpaqueTimingInfo\");function makePolicyContainer(){return{referrerPolicy:\"strict-origin-when-cross-origin\"}}__name(makePolicyContainer,\"makePolicyContainer\");function clonePolicyContainer(policyContainer){return{referrerPolicy:policyContainer.referrerPolicy}}__name(clonePolicyContainer,\"clonePolicyContainer\");function determineRequestsReferrer(request){const policy=request.referrerPolicy;assert(policy);let referrerSource=null;if(request.referrer===\"client\"){const globalOrigin=getGlobalOrigin();if(!globalOrigin||globalOrigin.origin===\"null\"){return\"no-referrer\"}referrerSource=new URL(globalOrigin)}else if(request.referrer instanceof URL){referrerSource=request.referrer}let referrerURL=stripURLForReferrer(referrerSource);const referrerOrigin=stripURLForReferrer(referrerSource,true);if(referrerURL.toString().length>4096){referrerURL=referrerOrigin}const areSameOrigin=sameOrigin(request,referrerURL);const isNonPotentiallyTrustWorthy=isURLPotentiallyTrustworthy(referrerURL)&&!isURLPotentiallyTrustworthy(request.url);switch(policy){case\"origin\":return referrerOrigin!=null?referrerOrigin:stripURLForReferrer(referrerSource,true);case\"unsafe-url\":return referrerURL;case\"same-origin\":return areSameOrigin?referrerOrigin:\"no-referrer\";case\"origin-when-cross-origin\":return areSameOrigin?referrerURL:referrerOrigin;case\"strict-origin-when-cross-origin\":{const currentURL=requestCurrentURL(request);if(sameOrigin(referrerURL,currentURL)){return referrerURL}if(isURLPotentiallyTrustworthy(referrerURL)&&!isURLPotentiallyTrustworthy(currentURL)){return\"no-referrer\"}return referrerOrigin}case\"strict-origin\":case\"no-referrer-when-downgrade\":default:return isNonPotentiallyTrustWorthy?\"no-referrer\":referrerOrigin}}__name(determineRequestsReferrer,\"determineRequestsReferrer\");function stripURLForReferrer(url,originOnly){assert(url instanceof URL);url=new URL(url);if(url.protocol===\"file:\"||url.protocol===\"about:\"||url.protocol===\"blank:\"){return\"no-referrer\"}url.username=\"\";url.password=\"\";url.hash=\"\";if(originOnly){url.pathname=\"\";url.search=\"\"}return url}__name(stripURLForReferrer,\"stripURLForReferrer\");function isURLPotentiallyTrustworthy(url){if(!(url instanceof URL)){return false}if(url.href===\"about:blank\"||url.href===\"about:srcdoc\"){return true}if(url.protocol===\"data:\")return true;if(url.protocol===\"file:\")return true;return isOriginPotentiallyTrustworthy(url.origin);function isOriginPotentiallyTrustworthy(origin){if(origin==null||origin===\"null\")return false;const originAsURL=new URL(origin);if(originAsURL.protocol===\"https:\"||originAsURL.protocol===\"wss:\"){return true}if(/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname)||(originAsURL.hostname===\"localhost\"||originAsURL.hostname.includes(\"localhost.\"))||originAsURL.hostname.endsWith(\".localhost\")){return true}return false}__name(isOriginPotentiallyTrustworthy,\"isOriginPotentiallyTrustworthy\")}__name(isURLPotentiallyTrustworthy,\"isURLPotentiallyTrustworthy\");function bytesMatch(bytes,metadataList){if(crypto===void 0){return true}const parsedMetadata=parseMetadata(metadataList);if(parsedMetadata===\"no metadata\"){return true}if(parsedMetadata.length===0){return true}const strongest=getStrongestMetadata(parsedMetadata);const metadata=filterMetadataListByAlgorithm(parsedMetadata,strongest);for(const item of metadata){const algorithm=item.algo;const expectedValue=item.hash;let actualValue=crypto.createHash(algorithm).update(bytes).digest(\"base64\");if(actualValue[actualValue.length-1]===\"=\"){if(actualValue[actualValue.length-2]===\"=\"){actualValue=actualValue.slice(0,-2)}else{actualValue=actualValue.slice(0,-1)}}if(compareBase64Mixed(actualValue,expectedValue)){return true}}return false}__name(bytesMatch,\"bytesMatch\");const parseHashWithOptions=/(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\\s|$)( +[!-~]*)?)?/i;function parseMetadata(metadata){const result=[];let empty=true;for(const token of metadata.split(\" \")){empty=false;const parsedToken=parseHashWithOptions.exec(token);if(parsedToken===null||parsedToken.groups===void 0||parsedToken.groups.algo===void 0){continue}const algorithm=parsedToken.groups.algo.toLowerCase();if(supportedHashes.includes(algorithm)){result.push(parsedToken.groups)}}if(empty===true){return\"no metadata\"}return result}__name(parseMetadata,\"parseMetadata\");function getStrongestMetadata(metadataList){let algorithm=metadataList[0].algo;if(algorithm[3]===\"5\"){return algorithm}for(let i=1;i<metadataList.length;++i){const metadata=metadataList[i];if(metadata.algo[3]===\"5\"){algorithm=\"sha512\";break}else if(algorithm[3]===\"3\"){continue}else if(metadata.algo[3]===\"3\"){algorithm=\"sha384\"}}return algorithm}__name(getStrongestMetadata,\"getStrongestMetadata\");function filterMetadataListByAlgorithm(metadataList,algorithm){if(metadataList.length===1){return metadataList}let pos=0;for(let i=0;i<metadataList.length;++i){if(metadataList[i].algo===algorithm){metadataList[pos++]=metadataList[i]}}metadataList.length=pos;return metadataList}__name(filterMetadataListByAlgorithm,\"filterMetadataListByAlgorithm\");function compareBase64Mixed(actualValue,expectedValue){if(actualValue.length!==expectedValue.length){return false}for(let i=0;i<actualValue.length;++i){if(actualValue[i]!==expectedValue[i]){if(actualValue[i]===\"+\"&&expectedValue[i]===\"-\"||actualValue[i]===\"/\"&&expectedValue[i]===\"_\"){continue}return false}}return true}__name(compareBase64Mixed,\"compareBase64Mixed\");function tryUpgradeRequestToAPotentiallyTrustworthyURL(request){}__name(tryUpgradeRequestToAPotentiallyTrustworthyURL,\"tryUpgradeRequestToAPotentiallyTrustworthyURL\");function sameOrigin(A,B){if(A.origin===B.origin&&A.origin===\"null\"){return true}if(A.protocol===B.protocol&&A.hostname===B.hostname&&A.port===B.port){return true}return false}__name(sameOrigin,\"sameOrigin\");function createDeferredPromise(){let res;let rej;const promise=new Promise((resolve,reject)=>{res=resolve;rej=reject});return{promise,resolve:res,reject:rej}}__name(createDeferredPromise,\"createDeferredPromise\");function isAborted(fetchParams){return fetchParams.controller.state===\"aborted\"}__name(isAborted,\"isAborted\");function isCancelled(fetchParams){return fetchParams.controller.state===\"aborted\"||fetchParams.controller.state===\"terminated\"}__name(isCancelled,\"isCancelled\");function normalizeMethod(method){return normalizedMethodRecordsBase[method.toLowerCase()]??method}__name(normalizeMethod,\"normalizeMethod\");function serializeJavascriptValueToJSONString(value){const result=JSON.stringify(value);if(result===void 0){throw new TypeError(\"Value is not JSON serializable\")}assert(typeof result===\"string\");return result}__name(serializeJavascriptValueToJSONString,\"serializeJavascriptValueToJSONString\");const esIteratorPrototype=Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));function createIterator(name,kInternalIterator,keyIndex=0,valueIndex=1){class FastIterableIterator{static{__name(this,\"FastIterableIterator\")}#target;#kind;#index;constructor(target,kind){this.#target=target;this.#kind=kind;this.#index=0}next(){if(typeof this!==\"object\"||this===null||!(#target in this)){throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`)}const index=this.#index;const values=this.#target[kInternalIterator];const len=values.length;if(index>=len){return{value:void 0,done:true}}const{[keyIndex]:key,[valueIndex]:value}=values[index];this.#index=index+1;let result;switch(this.#kind){case\"key\":result=key;break;case\"value\":result=value;break;case\"key+value\":result=[key,value];break}return{value:result,done:false}}}delete FastIterableIterator.prototype.constructor;Object.setPrototypeOf(FastIterableIterator.prototype,esIteratorPrototype);Object.defineProperties(FastIterableIterator.prototype,{[Symbol.toStringTag]:{writable:false,enumerable:false,configurable:true,value:`${name} Iterator`},next:{writable:true,enumerable:true,configurable:true}});return function(target,kind){return new FastIterableIterator(target,kind)}}__name(createIterator,\"createIterator\");function iteratorMixin(name,object,kInternalIterator,keyIndex=0,valueIndex=1){const makeIterator=createIterator(name,kInternalIterator,keyIndex,valueIndex);const properties={keys:{writable:true,enumerable:true,configurable:true,value:__name(function keys(){webidl.brandCheck(this,object);return makeIterator(this,\"key\")},\"keys\")},values:{writable:true,enumerable:true,configurable:true,value:__name(function values(){webidl.brandCheck(this,object);return makeIterator(this,\"value\")},\"values\")},entries:{writable:true,enumerable:true,configurable:true,value:__name(function entries(){webidl.brandCheck(this,object);return makeIterator(this,\"key+value\")},\"entries\")},forEach:{writable:true,enumerable:true,configurable:true,value:__name(function forEach(callbackfn,thisArg=globalThis){webidl.brandCheck(this,object);webidl.argumentLengthCheck(arguments,1,`${name}.forEach`);if(typeof callbackfn!==\"function\"){throw new TypeError(`Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`)}for(const{0:key,1:value}of makeIterator(this,\"key+value\")){callbackfn.call(thisArg,value,key,this)}},\"forEach\")}};return Object.defineProperties(object.prototype,{...properties,[Symbol.iterator]:{writable:true,enumerable:false,configurable:true,value:properties.entries.value}})}__name(iteratorMixin,\"iteratorMixin\");async function fullyReadBody(body,processBody,processBodyError){const successSteps=processBody;const errorSteps=processBodyError;let reader;try{reader=body.stream.getReader()}catch(e){errorSteps(e);return}try{successSteps(await readAllBytes(reader))}catch(e){errorSteps(e)}}__name(fullyReadBody,\"fullyReadBody\");function isReadableStreamLike(stream){return stream instanceof ReadableStream||stream[Symbol.toStringTag]===\"ReadableStream\"&&typeof stream.tee===\"function\"}__name(isReadableStreamLike,\"isReadableStreamLike\");function readableStreamClose(controller){try{controller.close();controller.byobRequest?.respond(0)}catch(err){if(!err.message.includes(\"Controller is already closed\")&&!err.message.includes(\"ReadableStream is already closed\")){throw err}}}__name(readableStreamClose,\"readableStreamClose\");const invalidIsomorphicEncodeValueRegex=/[^\\x00-\\xFF]/;function isomorphicEncode(input){assert(!invalidIsomorphicEncodeValueRegex.test(input));return input}__name(isomorphicEncode,\"isomorphicEncode\");async function readAllBytes(reader){const bytes=[];let byteLength=0;while(true){const{done,value:chunk}=await reader.read();if(done){return Buffer.concat(bytes,byteLength)}if(!isUint8Array(chunk)){throw new TypeError(\"Received non-Uint8Array chunk\")}bytes.push(chunk);byteLength+=chunk.length}}__name(readAllBytes,\"readAllBytes\");function urlIsLocal(url){assert(\"protocol\"in url);const protocol=url.protocol;return protocol===\"about:\"||protocol===\"blob:\"||protocol===\"data:\"}__name(urlIsLocal,\"urlIsLocal\");function urlHasHttpsScheme(url){return typeof url===\"string\"&&url[5]===\":\"&&url[0]===\"h\"&&url[1]===\"t\"&&url[2]===\"t\"&&url[3]===\"p\"&&url[4]===\"s\"||url.protocol===\"https:\"}__name(urlHasHttpsScheme,\"urlHasHttpsScheme\");function urlIsHttpHttpsScheme(url){assert(\"protocol\"in url);const protocol=url.protocol;return protocol===\"http:\"||protocol===\"https:\"}__name(urlIsHttpHttpsScheme,\"urlIsHttpHttpsScheme\");function simpleRangeHeaderValue(value,allowWhitespace){const data=value;if(!data.startsWith(\"bytes\")){return\"failure\"}const position={position:5};if(allowWhitespace){collectASequenceOfCodePoints(char=>char===\"\t\"||char===\" \",data,position)}if(data.charCodeAt(position.position)!==61){return\"failure\"}position.position++;if(allowWhitespace){collectASequenceOfCodePoints(char=>char===\"\t\"||char===\" \",data,position)}const rangeStart=collectASequenceOfCodePoints(char=>{const code=char.charCodeAt(0);return code>=48&&code<=57},data,position);const rangeStartValue=rangeStart.length?Number(rangeStart):null;if(allowWhitespace){collectASequenceOfCodePoints(char=>char===\"\t\"||char===\" \",data,position)}if(data.charCodeAt(position.position)!==45){return\"failure\"}position.position++;if(allowWhitespace){collectASequenceOfCodePoints(char=>char===\"\t\"||char===\" \",data,position)}const rangeEnd=collectASequenceOfCodePoints(char=>{const code=char.charCodeAt(0);return code>=48&&code<=57},data,position);const rangeEndValue=rangeEnd.length?Number(rangeEnd):null;if(position.position<data.length){return\"failure\"}if(rangeEndValue===null&&rangeStartValue===null){return\"failure\"}if(rangeStartValue>rangeEndValue){return\"failure\"}return{rangeStartValue,rangeEndValue}}__name(simpleRangeHeaderValue,\"simpleRangeHeaderValue\");function buildContentRange(rangeStart,rangeEnd,fullLength){let contentRange=\"bytes \";contentRange+=isomorphicEncode(`${rangeStart}`);contentRange+=\"-\";contentRange+=isomorphicEncode(`${rangeEnd}`);contentRange+=\"/\";contentRange+=isomorphicEncode(`${fullLength}`);return contentRange}__name(buildContentRange,\"buildContentRange\");class InflateStream extends Transform{static{__name(this,\"InflateStream\")}#zlibOptions;constructor(zlibOptions){super();this.#zlibOptions=zlibOptions}_transform(chunk,encoding,callback){if(!this._inflateStream){if(chunk.length===0){callback();return}this._inflateStream=(chunk[0]&15)===8?zlib.createInflate(this.#zlibOptions):zlib.createInflateRaw(this.#zlibOptions);this._inflateStream.on(\"data\",this.push.bind(this));this._inflateStream.on(\"end\",()=>this.push(null));this._inflateStream.on(\"error\",err=>this.destroy(err))}this._inflateStream.write(chunk,encoding,callback)}_final(callback){if(this._inflateStream){this._inflateStream.end();this._inflateStream=null}callback()}}function createInflate(zlibOptions){return new InflateStream(zlibOptions)}__name(createInflate,\"createInflate\");function extractMimeType(headers){let charset=null;let essence=null;let mimeType=null;const values=getDecodeSplit(\"content-type\",headers);if(values===null){return\"failure\"}for(const value of values){const temporaryMimeType=parseMIMEType(value);if(temporaryMimeType===\"failure\"||temporaryMimeType.essence===\"*/*\"){continue}mimeType=temporaryMimeType;if(mimeType.essence!==essence){charset=null;if(mimeType.parameters.has(\"charset\")){charset=mimeType.parameters.get(\"charset\")}essence=mimeType.essence}else if(!mimeType.parameters.has(\"charset\")&&charset!==null){mimeType.parameters.set(\"charset\",charset)}}if(mimeType==null){return\"failure\"}return mimeType}__name(extractMimeType,\"extractMimeType\");function gettingDecodingSplitting(value){const input=value;const position={position:0};const values=[];let temporaryValue=\"\";while(position.position<input.length){temporaryValue+=collectASequenceOfCodePoints(char=>char!=='\"'&&char!==\",\",input,position);if(position.position<input.length){if(input.charCodeAt(position.position)===34){temporaryValue+=collectAnHTTPQuotedString(input,position);if(position.position<input.length){continue}}else{assert(input.charCodeAt(position.position)===44);position.position++}}temporaryValue=removeChars(temporaryValue,true,true,char=>char===9||char===32);values.push(temporaryValue);temporaryValue=\"\"}return values}__name(gettingDecodingSplitting,\"gettingDecodingSplitting\");function getDecodeSplit(name,list){const value=list.get(name,true);if(value===null){return null}return gettingDecodingSplitting(value)}__name(getDecodeSplit,\"getDecodeSplit\");const textDecoder=new TextDecoder;function utf8DecodeBytes(buffer){if(buffer.length===0){return\"\"}if(buffer[0]===239&&buffer[1]===187&&buffer[2]===191){buffer=buffer.subarray(3)}const output=textDecoder.decode(buffer);return output}__name(utf8DecodeBytes,\"utf8DecodeBytes\");class EnvironmentSettingsObjectBase{static{__name(this,\"EnvironmentSettingsObjectBase\")}get baseUrl(){return getGlobalOrigin()}get origin(){return this.baseUrl?.origin}policyContainer=makePolicyContainer()}class EnvironmentSettingsObject{static{__name(this,\"EnvironmentSettingsObject\")}settingsObject=new EnvironmentSettingsObjectBase}const environmentSettingsObject=new EnvironmentSettingsObject;module.exports={isAborted,isCancelled,isValidEncodedURL,createDeferredPromise,ReadableStreamFrom,tryUpgradeRequestToAPotentiallyTrustworthyURL,clampAndCoarsenConnectionTimingInfo,coarsenedSharedCurrentTime,determineRequestsReferrer,makePolicyContainer,clonePolicyContainer,appendFetchMetadata,appendRequestOriginHeader,TAOCheck,corsCheck,crossOriginResourcePolicyCheck,createOpaqueTimingInfo,setRequestReferrerPolicyOnRedirect,isValidHTTPToken,requestBadPort,requestCurrentURL,responseURL,responseLocationURL,isBlobLike,isURLPotentiallyTrustworthy,isValidReasonPhrase,sameOrigin,normalizeMethod,serializeJavascriptValueToJSONString,iteratorMixin,createIterator,isValidHeaderName,isValidHeaderValue,isErrorLike,fullyReadBody,bytesMatch,isReadableStreamLike,readableStreamClose,isomorphicEncode,urlIsLocal,urlHasHttpsScheme,urlIsHttpHttpsScheme,readAllBytes,simpleRangeHeaderValue,buildContentRange,parseMetadata,createInflate,extractMimeType,getDecodeSplit,utf8DecodeBytes,environmentSettingsObject};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/fetch/util.js"],"sourcesContent":["'use strict'\n\nconst { Transform } = require('node:stream')\nconst zlib = require('node:zlib')\nconst { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require('./constants')\nconst { getGlobalOrigin } = require('./global')\nconst { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = require('./data-url')\nconst { performance } = require('node:perf_hooks')\nconst { isBlobLike, ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = require('../../core/util')\nconst assert = require('node:assert')\nconst { isUint8Array } = require('node:util/types')\nconst { webidl } = require('./webidl')\n\nlet supportedHashes = []\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = require('node:crypto')\n  const possibleRelevantHashes = ['sha256', 'sha384', 'sha512']\n  supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash))\n/* c8 ignore next 3 */\n} catch {\n\n}\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatusSet.has(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location', true)\n\n  // 3. If location is a header value, then set location to the result of\n  //    parsing location with response’s URL.\n  if (location !== null && isValidHeaderValue(location)) {\n    if (!isValidEncodedURL(location)) {\n      // Some websites respond location header in UTF-8 form without encoding them as ASCII\n      // and major browsers redirect them to correctly UTF-8 encoded addresses.\n      // Here, we handle that behavior in the same way.\n      location = normalizeBinaryStringToUtf8(location)\n    }\n    location = new URL(location, responseURL(response))\n  }\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc1738#section-2.2\n * @param {string} url\n * @returns {boolean}\n */\nfunction isValidEncodedURL (url) {\n  for (let i = 0; i < url.length; ++i) {\n    const code = url.charCodeAt(i)\n\n    if (\n      code > 0x7E || // Non-US-ASCII + DEL\n      code < 0x20 // Control characters NUL - US\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * If string contains non-ASCII characters, assumes it's UTF-8 encoded and decodes it.\n * Since UTF-8 is a superset of ASCII, this will work for ASCII strings as well.\n * @param {string} value\n * @returns {string}\n */\nfunction normalizeBinaryStringToUtf8 (value) {\n  return Buffer.from(value, 'binary').toString('utf8')\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isErrorLike (object) {\n  return object instanceof Error || (\n    object?.constructor?.name === 'Error' ||\n    object?.constructor?.name === 'DOMException'\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */\nconst isValidHeaderName = isValidHTTPToken\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue (potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  return (\n    potentialValue[0] === '\\t' ||\n    potentialValue[0] === ' ' ||\n    potentialValue[potentialValue.length - 1] === '\\t' ||\n    potentialValue[potentialValue.length - 1] === ' ' ||\n    potentialValue.includes('\\n') ||\n    potentialValue.includes('\\r') ||\n    potentialValue.includes('\\0')\n  ) === false\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n\n  // 8.1 Parse a referrer policy from a Referrer-Policy header\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n  const { headersList } = actualResponse\n  // 2. Let policy be the empty string.\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n  // 4. Return policy.\n  const policyHeader = (headersList.get('referrer-policy', true) ?? '').split(',')\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  let policy = ''\n  if (policyHeader.length > 0) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim()\n      if (referrerPolicyTokens.has(token)) {\n        policy = token\n        break\n      }\n    }\n  }\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header, true)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin\n  //    with request.\n  // TODO: implement \"byte-serializing a request origin\"\n  let serializedOrigin = request.origin\n\n  // - \"'client' is changed to an origin during fetching.\"\n  //   This doesn't happen in undici (in most cases) because undici, by default,\n  //   has no concept of origin.\n  // - request.origin can also be set to request.client.origin (client being\n  //   an environment settings object), which is undefined without using\n  //   setGlobalOrigin.\n  if (serializedOrigin === 'client' || serializedOrigin === undefined) {\n    return\n  }\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\",\n  //    then append (`Origin`, serializedOrigin) to request’s header list.\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    request.headersList.append('origin', serializedOrigin, true)\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and\n        // request’s current URL’s scheme is not \"https\", then set\n        // serializedOrigin to `null`.\n        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s\n        // origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n    request.headersList.append('origin', serializedOrigin, true)\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsen-time\nfunction coarsenTime (timestamp, crossOriginIsolatedCapability) {\n  // TODO\n  return timestamp\n}\n\n// https://fetch.spec.whatwg.org/#clamp-and-coarsen-connection-timing-info\nfunction clampAndCoarsenConnectionTimingInfo (connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {\n  if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {\n    return {\n      domainLookupStartTime: defaultStartTime,\n      domainLookupEndTime: defaultStartTime,\n      connectionStartTime: defaultStartTime,\n      connectionEndTime: defaultStartTime,\n      secureConnectionStartTime: defaultStartTime,\n      ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol\n    }\n  }\n\n  return {\n    domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),\n    domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),\n    connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),\n    connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),\n    secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),\n    ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsened-shared-current-time\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  return coarsenTime(performance.now(), crossOriginIsolatedCapability)\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // Note: the fetch spec doesn't make use of embedder policy or CSP list\n  return {\n    referrerPolicy: 'strict-origin-when-cross-origin'\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer (policyContainer) {\n  return {\n    referrerPolicy: policyContainer.referrerPolicy\n  }\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer (request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy\n\n  // Note: policy cannot (shouldn't) be null or an empty string.\n  assert(policy)\n\n  // 2. Let environment be request’s client.\n\n  let referrerSource = null\n\n  // 3. Switch on request’s referrer:\n  if (request.referrer === 'client') {\n    // Note: node isn't a browser and doesn't implement document/iframes,\n    // so we bypass this step and replace it with our own.\n\n    const globalOrigin = getGlobalOrigin()\n\n    if (!globalOrigin || globalOrigin.origin === 'null') {\n      return 'no-referrer'\n    }\n\n    // note: we need to clone it as it's mutated\n    referrerSource = new URL(globalOrigin)\n  } else if (request.referrer instanceof URL) {\n    // Let referrerSource be request’s referrer.\n    referrerSource = request.referrer\n  }\n\n  // 4. Let request’s referrerURL be the result of stripping referrerSource for\n  //    use as a referrer.\n  let referrerURL = stripURLForReferrer(referrerSource)\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n  //    a referrer, with the origin-only flag set to true.\n  const referrerOrigin = stripURLForReferrer(referrerSource, true)\n\n  // 6. If the result of serializing referrerURL is a string whose length is\n  //    greater than 4096, set referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin\n  }\n\n  const areSameOrigin = sameOrigin(request, referrerURL)\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) &&\n    !isURLPotentiallyTrustworthy(request.url)\n\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin': return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true)\n    case 'unsafe-url': return referrerURL\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer'\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerURL : referrerOrigin\n    case 'strict-origin-when-cross-origin': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If the origin of referrerURL and the origin of request’s current\n      //    URL are the same, then return referrerURL.\n      if (sameOrigin(referrerURL, currentURL)) {\n        return referrerURL\n      }\n\n      // 2. If referrerURL is a potentially trustworthy URL and request’s\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n\n      // 3. Return referrerOrigin.\n      return referrerOrigin\n    }\n    case 'strict-origin': // eslint-disable-line\n      /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * request’s current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n      /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n\n    default: // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */\nfunction stripURLForReferrer (url, originOnly) {\n  // 1. Assert: url is a URL.\n  assert(url instanceof URL)\n\n  url = new URL(url)\n\n  // 2. If url’s scheme is a local scheme, then return no referrer.\n  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {\n    return 'no-referrer'\n  }\n\n  // 3. Set url’s username to the empty string.\n  url.username = ''\n\n  // 4. Set url’s password to the empty string.\n  url.password = ''\n\n  // 5. Set url’s fragment to null.\n  url.hash = ''\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly) {\n    // 1. Set url’s path to « the empty string ».\n    url.pathname = ''\n\n    // 2. Set url’s query to null.\n    url.search = ''\n  }\n\n  // 7. Return url.\n  return url\n}\n\nfunction isURLPotentiallyTrustworthy (url) {\n  if (!(url instanceof URL)) {\n    return false\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true\n\n  // If file, return true\n  if (url.protocol === 'file:') return true\n\n  return isOriginPotentiallyTrustworthy(url.origin)\n\n  function isOriginPotentiallyTrustworthy (origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false\n\n    const originAsURL = new URL(origin)\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) ||\n     (originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.')) ||\n     (originAsURL.hostname.endsWith('.localhost'))) {\n      return true\n    }\n\n    // If any other, return false\n    return false\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch (bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList)\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true\n  }\n\n  // 3. If response is not eligible for integrity validation, return false.\n  // TODO\n\n  // 4. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true\n  }\n\n  // 5. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  const strongest = getStrongestMetadata(parsedMetadata)\n  const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest)\n\n  // 6. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo\n\n    // 2. Let expectedValue be the val component of item.\n    const expectedValue = item.hash\n\n    // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n    // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64')\n\n    if (actualValue[actualValue.length - 1] === '=') {\n      if (actualValue[actualValue.length - 2] === '=') {\n        actualValue = actualValue.slice(0, -2)\n      } else {\n        actualValue = actualValue.slice(0, -1)\n      }\n    }\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (compareBase64Mixed(actualValue, expectedValue)) {\n      return true\n    }\n  }\n\n  // 7. Return false.\n  return false\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\\s|$)( +[!-~]*)?)?/i\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata (metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = []\n\n  // 2. Let empty be equal to true.\n  let empty = true\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token)\n\n    // 3. If token does not parse, continue to the next token.\n    if (\n      parsedToken === null ||\n      parsedToken.groups === undefined ||\n      parsedToken.groups.algo === undefined\n    ) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo.toLowerCase()\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm)) {\n      result.push(parsedToken.groups)\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata'\n  }\n\n  return result\n}\n\n/**\n * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList\n */\nfunction getStrongestMetadata (metadataList) {\n  // Let algorithm be the algo component of the first item in metadataList.\n  // Can be sha256\n  let algorithm = metadataList[0].algo\n  // If the algorithm is sha512, then it is the strongest\n  // and we can return immediately\n  if (algorithm[3] === '5') {\n    return algorithm\n  }\n\n  for (let i = 1; i < metadataList.length; ++i) {\n    const metadata = metadataList[i]\n    // If the algorithm is sha512, then it is the strongest\n    // and we can break the loop immediately\n    if (metadata.algo[3] === '5') {\n      algorithm = 'sha512'\n      break\n    // If the algorithm is sha384, then a potential sha256 or sha384 is ignored\n    } else if (algorithm[3] === '3') {\n      continue\n    // algorithm is sha256, check if algorithm is sha384 and if so, set it as\n    // the strongest\n    } else if (metadata.algo[3] === '3') {\n      algorithm = 'sha384'\n    }\n  }\n  return algorithm\n}\n\nfunction filterMetadataListByAlgorithm (metadataList, algorithm) {\n  if (metadataList.length === 1) {\n    return metadataList\n  }\n\n  let pos = 0\n  for (let i = 0; i < metadataList.length; ++i) {\n    if (metadataList[i].algo === algorithm) {\n      metadataList[pos++] = metadataList[i]\n    }\n  }\n\n  metadataList.length = pos\n\n  return metadataList\n}\n\n/**\n * Compares two base64 strings, allowing for base64url\n * in the second string.\n *\n* @param {string} actualValue always base64\n * @param {string} expectedValue base64 or base64url\n * @returns {boolean}\n */\nfunction compareBase64Mixed (actualValue, expectedValue) {\n  if (actualValue.length !== expectedValue.length) {\n    return false\n  }\n  for (let i = 0; i < actualValue.length; ++i) {\n    if (actualValue[i] !== expectedValue[i]) {\n      if (\n        (actualValue[i] === '+' && expectedValue[i] === '-') ||\n        (actualValue[i] === '/' && expectedValue[i] === '_')\n      ) {\n        continue\n      }\n      return false\n    }\n  }\n\n  return true\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  if (A.origin === B.origin && A.origin === 'null') {\n    return true\n  }\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nfunction isAborted (fetchParams) {\n  return fetchParams.controller.state === 'aborted'\n}\n\nfunction isCancelled (fetchParams) {\n  return fetchParams.controller.state === 'aborted' ||\n    fetchParams.controller.state === 'terminated'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */\nfunction normalizeMethod (method) {\n  return normalizedMethodRecordsBase[method.toLowerCase()] ?? method\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString (value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value)\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable')\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string')\n\n  // 4. Return result.\n  return result\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {symbol} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction createIterator (name, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  class FastIterableIterator {\n    /** @type {any} */\n    #target\n    /** @type {'key' | 'value' | 'key+value'} */\n    #kind\n    /** @type {number} */\n    #index\n\n    /**\n     * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object\n     * @param {unknown} target\n     * @param {'key' | 'value' | 'key+value'} kind\n     */\n    constructor (target, kind) {\n      this.#target = target\n      this.#kind = kind\n      this.#index = 0\n    }\n\n    next () {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n      // 2. Let thisValue be the this value.\n      // 3. Let object be ? ToObject(thisValue).\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (typeof this !== 'object' || this === null || !(#target in this)) {\n        throw new TypeError(\n          `'next' called on an object that does not implement interface ${name} Iterator.`\n        )\n      }\n\n      // 6. Let index be object’s index.\n      // 7. Let kind be object’s kind.\n      // 8. Let values be object’s target's value pairs to iterate over.\n      const index = this.#index\n      const values = this.#target[kInternalIterator]\n\n      // 9. Let len be the length of values.\n      const len = values.length\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return {\n          value: undefined,\n          done: true\n        }\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const { [keyIndex]: key, [valueIndex]: value } = values[index]\n\n      // 12. Set object’s index to index + 1.\n      this.#index = index + 1\n\n      // 13. Return the iterator result for pair and kind.\n\n      // https://webidl.spec.whatwg.org/#iterator-result\n\n      // 1. Let result be a value determined by the value of kind:\n      let result\n      switch (this.#kind) {\n        case 'key':\n          // 1. Let idlKey be pair’s key.\n          // 2. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 3. result is key.\n          result = key\n          break\n        case 'value':\n          // 1. Let idlValue be pair’s value.\n          // 2. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 3. result is value.\n          result = value\n          break\n        case 'key+value':\n          // 1. Let idlKey be pair’s key.\n          // 2. Let idlValue be pair’s value.\n          // 3. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 4. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 5. Let array be ! ArrayCreate(2).\n          // 6. Call ! CreateDataProperty(array, \"0\", key).\n          // 7. Call ! CreateDataProperty(array, \"1\", value).\n          // 8. result is array.\n          result = [key, value]\n          break\n      }\n\n      // 2. Return CreateIterResultObject(result, false).\n      return {\n        value: result,\n        done: false\n      }\n    }\n  }\n\n  // https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n  // @ts-ignore\n  delete FastIterableIterator.prototype.constructor\n\n  Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype)\n\n  Object.defineProperties(FastIterableIterator.prototype, {\n    [Symbol.toStringTag]: {\n      writable: false,\n      enumerable: false,\n      configurable: true,\n      value: `${name} Iterator`\n    },\n    next: { writable: true, enumerable: true, configurable: true }\n  })\n\n  /**\n   * @param {unknown} target\n   * @param {'key' | 'value' | 'key+value'} kind\n   * @returns {IterableIterator<any>}\n   */\n  return function (target, kind) {\n    return new FastIterableIterator(target, kind)\n  }\n}\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {any} object class\n * @param {symbol} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction iteratorMixin (name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex)\n\n  const properties = {\n    keys: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function keys () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'key')\n      }\n    },\n    values: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function values () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'value')\n      }\n    },\n    entries: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function entries () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'key+value')\n      }\n    },\n    forEach: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function forEach (callbackfn, thisArg = globalThis) {\n        webidl.brandCheck(this, object)\n        webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`)\n        if (typeof callbackfn !== 'function') {\n          throw new TypeError(\n            `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`\n          )\n        }\n        for (const { 0: key, 1: value } of makeIterator(this, 'key+value')) {\n          callbackfn.call(thisArg, value, key, this)\n        }\n      }\n    }\n  }\n\n  return Object.defineProperties(object.prototype, {\n    ...properties,\n    [Symbol.iterator]: {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: properties.entries.value\n    }\n  })\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nasync function fullyReadBody (body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = processBody\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = processBodyError\n\n  // 4. Let reader be the result of getting a reader for body’s stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n  let reader\n\n  try {\n    reader = body.stream.getReader()\n  } catch (e) {\n    errorSteps(e)\n    return\n  }\n\n  // 5. Read all bytes from reader, given successSteps and errorSteps.\n  try {\n    successSteps(await readAllBytes(reader))\n  } catch (e) {\n    errorSteps(e)\n  }\n}\n\nfunction isReadableStreamLike (stream) {\n  return stream instanceof ReadableStream || (\n    stream[Symbol.toStringTag] === 'ReadableStream' &&\n    typeof stream.tee === 'function'\n  )\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose (controller) {\n  try {\n    controller.close()\n    controller.byobRequest?.respond(0)\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed') && !err.message.includes('ReadableStream is already closed')) {\n      throw err\n    }\n  }\n}\n\nconst invalidIsomorphicEncodeValueRegex = /[^\\x00-\\xFF]/ // eslint-disable-line\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode (input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  assert(!invalidIsomorphicEncodeValueRegex.test(input))\n\n  // 2. Return a byte sequence whose length is equal to input’s code\n  //    point length and whose bytes have the same values as the\n  //    values of input’s code points, in the same order\n  return input\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */\nasync function readAllBytes (reader) {\n  const bytes = []\n  let byteLength = 0\n\n  while (true) {\n    const { done, value: chunk } = await reader.read()\n\n    if (done) {\n      // 1. Call successSteps with bytes.\n      return Buffer.concat(bytes, byteLength)\n    }\n\n    // 1. If chunk is not a Uint8Array object, call failureSteps\n    //    with a TypeError and abort these steps.\n    if (!isUint8Array(chunk)) {\n      throw new TypeError('Received non-Uint8Array chunk')\n    }\n\n    // 2. Append the bytes represented by chunk to bytes.\n    bytes.push(chunk)\n    byteLength += chunk.length\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */\nfunction urlIsLocal (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'\n}\n\n/**\n * @param {string|URL} url\n * @returns {boolean}\n */\nfunction urlHasHttpsScheme (url) {\n  return (\n    (\n      typeof url === 'string' &&\n      url[5] === ':' &&\n      url[0] === 'h' &&\n      url[1] === 't' &&\n      url[2] === 't' &&\n      url[3] === 'p' &&\n      url[4] === 's'\n    ) ||\n    url.protocol === 'https:'\n  )\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */\nfunction urlIsHttpHttpsScheme (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'http:' || protocol === 'https:'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#simple-range-header-value\n * @param {string} value\n * @param {boolean} allowWhitespace\n */\nfunction simpleRangeHeaderValue (value, allowWhitespace) {\n  // 1. Let data be the isomorphic decoding of value.\n  // Note: isomorphic decoding takes a sequence of bytes (ie. a Uint8Array) and turns it into a string,\n  // nothing more. We obviously don't need to do that if value is a string already.\n  const data = value\n\n  // 2. If data does not start with \"bytes\", then return failure.\n  if (!data.startsWith('bytes')) {\n    return 'failure'\n  }\n\n  // 3. Let position be a position variable for data, initially pointing at the 5th code point of data.\n  const position = { position: 5 }\n\n  // 4. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //    from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 5. If the code point at position within data is not U+003D (=), then return failure.\n  if (data.charCodeAt(position.position) !== 0x3D) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1.\n  position.position++\n\n  // 7. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from\n  //    data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 8. Let rangeStart be the result of collecting a sequence of code points that are ASCII digits,\n  //    from data given position.\n  const rangeStart = collectASequenceOfCodePoints(\n    (char) => {\n      const code = char.charCodeAt(0)\n\n      return code >= 0x30 && code <= 0x39\n    },\n    data,\n    position\n  )\n\n  // 9. Let rangeStartValue be rangeStart, interpreted as decimal number, if rangeStart is not the\n  //    empty string; otherwise null.\n  const rangeStartValue = rangeStart.length ? Number(rangeStart) : null\n\n  // 10. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //     from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 11. If the code point at position within data is not U+002D (-), then return failure.\n  if (data.charCodeAt(position.position) !== 0x2D) {\n    return 'failure'\n  }\n\n  // 12. Advance position by 1.\n  position.position++\n\n  // 13. If allowWhitespace is true, collect a sequence of code points that are HTTP tab\n  //     or space, from data given position.\n  // Note from Khafra: its the same step as in #8 again lol\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 14. Let rangeEnd be the result of collecting a sequence of code points that are\n  //     ASCII digits, from data given position.\n  // Note from Khafra: you wouldn't guess it, but this is also the same step as #8\n  const rangeEnd = collectASequenceOfCodePoints(\n    (char) => {\n      const code = char.charCodeAt(0)\n\n      return code >= 0x30 && code <= 0x39\n    },\n    data,\n    position\n  )\n\n  // 15. Let rangeEndValue be rangeEnd, interpreted as decimal number, if rangeEnd\n  //     is not the empty string; otherwise null.\n  // Note from Khafra: THE SAME STEP, AGAIN!!!\n  // Note: why interpret as a decimal if we only collect ascii digits?\n  const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null\n\n  // 16. If position is not past the end of data, then return failure.\n  if (position.position < data.length) {\n    return 'failure'\n  }\n\n  // 17. If rangeEndValue and rangeStartValue are null, then return failure.\n  if (rangeEndValue === null && rangeStartValue === null) {\n    return 'failure'\n  }\n\n  // 18. If rangeStartValue and rangeEndValue are numbers, and rangeStartValue is\n  //     greater than rangeEndValue, then return failure.\n  // Note: ... when can they not be numbers?\n  if (rangeStartValue > rangeEndValue) {\n    return 'failure'\n  }\n\n  // 19. Return (rangeStartValue, rangeEndValue).\n  return { rangeStartValue, rangeEndValue }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#build-a-content-range\n * @param {number} rangeStart\n * @param {number} rangeEnd\n * @param {number} fullLength\n */\nfunction buildContentRange (rangeStart, rangeEnd, fullLength) {\n  // 1. Let contentRange be `bytes `.\n  let contentRange = 'bytes '\n\n  // 2. Append rangeStart, serialized and isomorphic encoded, to contentRange.\n  contentRange += isomorphicEncode(`${rangeStart}`)\n\n  // 3. Append 0x2D (-) to contentRange.\n  contentRange += '-'\n\n  // 4. Append rangeEnd, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${rangeEnd}`)\n\n  // 5. Append 0x2F (/) to contentRange.\n  contentRange += '/'\n\n  // 6. Append fullLength, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${fullLength}`)\n\n  // 7. Return contentRange.\n  return contentRange\n}\n\n// A Stream, which pipes the response to zlib.createInflate() or\n// zlib.createInflateRaw() depending on the first byte of the Buffer.\n// If the lower byte of the first byte is 0x08, then the stream is\n// interpreted as a zlib stream, otherwise it's interpreted as a\n// raw deflate stream.\nclass InflateStream extends Transform {\n  #zlibOptions\n\n  /** @param {zlib.ZlibOptions} [zlibOptions] */\n  constructor (zlibOptions) {\n    super()\n    this.#zlibOptions = zlibOptions\n  }\n\n  _transform (chunk, encoding, callback) {\n    if (!this._inflateStream) {\n      if (chunk.length === 0) {\n        callback()\n        return\n      }\n      this._inflateStream = (chunk[0] & 0x0F) === 0x08\n        ? zlib.createInflate(this.#zlibOptions)\n        : zlib.createInflateRaw(this.#zlibOptions)\n\n      this._inflateStream.on('data', this.push.bind(this))\n      this._inflateStream.on('end', () => this.push(null))\n      this._inflateStream.on('error', (err) => this.destroy(err))\n    }\n\n    this._inflateStream.write(chunk, encoding, callback)\n  }\n\n  _final (callback) {\n    if (this._inflateStream) {\n      this._inflateStream.end()\n      this._inflateStream = null\n    }\n    callback()\n  }\n}\n\n/**\n * @param {zlib.ZlibOptions} [zlibOptions]\n * @returns {InflateStream}\n */\nfunction createInflate (zlibOptions) {\n  return new InflateStream(zlibOptions)\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-extract-mime-type\n * @param {import('./headers').HeadersList} headers\n */\nfunction extractMimeType (headers) {\n  // 1. Let charset be null.\n  let charset = null\n\n  // 2. Let essence be null.\n  let essence = null\n\n  // 3. Let mimeType be null.\n  let mimeType = null\n\n  // 4. Let values be the result of getting, decoding, and splitting `Content-Type` from headers.\n  const values = getDecodeSplit('content-type', headers)\n\n  // 5. If values is null, then return failure.\n  if (values === null) {\n    return 'failure'\n  }\n\n  // 6. For each value of values:\n  for (const value of values) {\n    // 6.1. Let temporaryMimeType be the result of parsing value.\n    const temporaryMimeType = parseMIMEType(value)\n\n    // 6.2. If temporaryMimeType is failure or its essence is \"*/*\", then continue.\n    if (temporaryMimeType === 'failure' || temporaryMimeType.essence === '*/*') {\n      continue\n    }\n\n    // 6.3. Set mimeType to temporaryMimeType.\n    mimeType = temporaryMimeType\n\n    // 6.4. If mimeType’s essence is not essence, then:\n    if (mimeType.essence !== essence) {\n      // 6.4.1. Set charset to null.\n      charset = null\n\n      // 6.4.2. If mimeType’s parameters[\"charset\"] exists, then set charset to\n      //        mimeType’s parameters[\"charset\"].\n      if (mimeType.parameters.has('charset')) {\n        charset = mimeType.parameters.get('charset')\n      }\n\n      // 6.4.3. Set essence to mimeType’s essence.\n      essence = mimeType.essence\n    } else if (!mimeType.parameters.has('charset') && charset !== null) {\n      // 6.5. Otherwise, if mimeType’s parameters[\"charset\"] does not exist, and\n      //      charset is non-null, set mimeType’s parameters[\"charset\"] to charset.\n      mimeType.parameters.set('charset', charset)\n    }\n  }\n\n  // 7. If mimeType is null, then return failure.\n  if (mimeType == null) {\n    return 'failure'\n  }\n\n  // 8. Return mimeType.\n  return mimeType\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value-get-decode-and-split\n * @param {string|null} value\n */\nfunction gettingDecodingSplitting (value) {\n  // 1. Let input be the result of isomorphic decoding value.\n  const input = value\n\n  // 2. Let position be a position variable for input, initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let values be a list of strings, initially empty.\n  const values = []\n\n  // 4. Let temporaryValue be the empty string.\n  let temporaryValue = ''\n\n  // 5. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 5.1. Append the result of collecting a sequence of code points that are not U+0022 (\")\n    //      or U+002C (,) from input, given position, to temporaryValue.\n    temporaryValue += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== ',',\n      input,\n      position\n    )\n\n    // 5.2. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 5.2.1. If the code point at position within input is U+0022 (\"), then:\n      if (input.charCodeAt(position.position) === 0x22) {\n        // 5.2.1.1. Append the result of collecting an HTTP quoted string from input, given position, to temporaryValue.\n        temporaryValue += collectAnHTTPQuotedString(\n          input,\n          position\n        )\n\n        // 5.2.1.2. If position is not past the end of input, then continue.\n        if (position.position < input.length) {\n          continue\n        }\n      } else {\n        // 5.2.2. Otherwise:\n\n        // 5.2.2.1. Assert: the code point at position within input is U+002C (,).\n        assert(input.charCodeAt(position.position) === 0x2C)\n\n        // 5.2.2.2. Advance position by 1.\n        position.position++\n      }\n    }\n\n    // 5.3. Remove all HTTP tab or space from the start and end of temporaryValue.\n    temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 0x9 || char === 0x20)\n\n    // 5.4. Append temporaryValue to values.\n    values.push(temporaryValue)\n\n    // 5.6. Set temporaryValue to the empty string.\n    temporaryValue = ''\n  }\n\n  // 6. Return values.\n  return values\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-list-get-decode-split\n * @param {string} name lowercase header name\n * @param {import('./headers').HeadersList} list\n */\nfunction getDecodeSplit (name, list) {\n  // 1. Let value be the result of getting name from list.\n  const value = list.get(name, true)\n\n  // 2. If value is null, then return null.\n  if (value === null) {\n    return null\n  }\n\n  // 3. Return the result of getting, decoding, and splitting value.\n  return gettingDecodingSplitting(value)\n}\n\nconst textDecoder = new TextDecoder()\n\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */\nfunction utf8DecodeBytes (buffer) {\n  if (buffer.length === 0) {\n    return ''\n  }\n\n  // 1. Let buffer be the result of peeking three bytes from\n  //    ioQueue, converted to a byte sequence.\n\n  // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n  //    bytes from ioQueue. (Do nothing with those bytes.)\n  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n    buffer = buffer.subarray(3)\n  }\n\n  // 3. Process a queue with an instance of UTF-8’s\n  //    decoder, ioQueue, output, and \"replacement\".\n  const output = textDecoder.decode(buffer)\n\n  // 4. Return output.\n  return output\n}\n\nclass EnvironmentSettingsObjectBase {\n  get baseUrl () {\n    return getGlobalOrigin()\n  }\n\n  get origin () {\n    return this.baseUrl?.origin\n  }\n\n  policyContainer = makePolicyContainer()\n}\n\nclass EnvironmentSettingsObject {\n  settingsObject = new EnvironmentSettingsObjectBase()\n}\n\nconst environmentSettingsObject = new EnvironmentSettingsObject()\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  isValidEncodedURL,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  clampAndCoarsenConnectionTimingInfo,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  iteratorMixin,\n  createIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch,\n  isReadableStreamLike,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlHasHttpsScheme,\n  urlIsHttpHttpsScheme,\n  readAllBytes,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  parseMetadata,\n  createInflate,\n  extractMimeType,\n  getDecodeSplit,\n  utf8DecodeBytes,\n  environmentSettingsObject\n}\n"]}}