{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{kProxy,kClose,kDestroy,kInterceptors}=require(\"../core/symbols\");const{URL}=require(\"node:url\");const Agent=require(\"./agent\");const Pool=require(\"./pool\");const DispatcherBase=require(\"./dispatcher-base\");const{InvalidArgumentError,RequestAbortedError,SecureProxyConnectionError}=require(\"../core/errors\");const buildConnector=require(\"../core/connect\");const kAgent=Symbol(\"proxy agent\");const kClient=Symbol(\"proxy client\");const kProxyHeaders=Symbol(\"proxy headers\");const kRequestTls=Symbol(\"request tls settings\");const kProxyTls=Symbol(\"proxy tls settings\");const kConnectEndpoint=Symbol(\"connect endpoint function\");function defaultProtocolPort(protocol){return protocol===\"https:\"?443:80}__name(defaultProtocolPort,\"defaultProtocolPort\");function defaultFactory(origin,opts){return new Pool(origin,opts)}__name(defaultFactory,\"defaultFactory\");const noop=__name(()=>{},\"noop\");class ProxyAgent extends DispatcherBase{static{__name(this,\"ProxyAgent\")}constructor(opts){super();if(!opts||typeof opts===\"object\"&&!(opts instanceof URL)&&!opts.uri){throw new InvalidArgumentError(\"Proxy uri is mandatory\")}const{clientFactory=defaultFactory}=opts;if(typeof clientFactory!==\"function\"){throw new InvalidArgumentError(\"Proxy opts.clientFactory must be a function.\")}const url=this.#getUrl(opts);const{href,origin,port,protocol,username,password,hostname:proxyHostname}=url;this[kProxy]={uri:href,protocol};this[kInterceptors]=opts.interceptors?.ProxyAgent&&Array.isArray(opts.interceptors.ProxyAgent)?opts.interceptors.ProxyAgent:[];this[kRequestTls]=opts.requestTls;this[kProxyTls]=opts.proxyTls;this[kProxyHeaders]=opts.headers||{};if(opts.auth&&opts.token){throw new InvalidArgumentError(\"opts.auth cannot be used in combination with opts.token\")}else if(opts.auth){this[kProxyHeaders][\"proxy-authorization\"]=`Basic ${opts.auth}`}else if(opts.token){this[kProxyHeaders][\"proxy-authorization\"]=opts.token}else if(username&&password){this[kProxyHeaders][\"proxy-authorization\"]=`Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString(\"base64\")}`}const connect=buildConnector({...opts.proxyTls});this[kConnectEndpoint]=buildConnector({...opts.requestTls});this[kClient]=clientFactory(url,{connect});this[kAgent]=new Agent({...opts,connect:async(opts2,callback)=>{let requestedPath=opts2.host;if(!opts2.port){requestedPath+=`:${defaultProtocolPort(opts2.protocol)}`}try{const{socket,statusCode}=await this[kClient].connect({origin,port,path:requestedPath,signal:opts2.signal,headers:{...this[kProxyHeaders],host:opts2.host},servername:this[kProxyTls]?.servername||proxyHostname});if(statusCode!==200){socket.on(\"error\",noop).destroy();callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`))}if(opts2.protocol!==\"https:\"){callback(null,socket);return}let servername;if(this[kRequestTls]){servername=this[kRequestTls].servername}else{servername=opts2.servername}this[kConnectEndpoint]({...opts2,servername,httpSocket:socket},callback)}catch(err){if(err.code===\"ERR_TLS_CERT_ALTNAME_INVALID\"){callback(new SecureProxyConnectionError(err))}else{callback(err)}}}})}dispatch(opts,handler){const headers=buildHeaders(opts.headers);throwIfProxyAuthIsSent(headers);if(headers&&!(\"host\"in headers)&&!(\"Host\"in headers)){const{host}=new URL(opts.origin);headers.host=host}return this[kAgent].dispatch({...opts,headers},handler)}#getUrl(opts){if(typeof opts===\"string\"){return new URL(opts)}else if(opts instanceof URL){return opts}else{return new URL(opts.uri)}}async[kClose](){await this[kAgent].close();await this[kClient].close()}async[kDestroy](){await this[kAgent].destroy();await this[kClient].destroy()}}function buildHeaders(headers){if(Array.isArray(headers)){const headersPair={};for(let i=0;i<headers.length;i+=2){headersPair[headers[i]]=headers[i+1]}return headersPair}return headers}__name(buildHeaders,\"buildHeaders\");function throwIfProxyAuthIsSent(headers){const existProxyAuth=headers&&Object.keys(headers).find(key=>key.toLowerCase()===\"proxy-authorization\");if(existProxyAuth){throw new InvalidArgumentError(\"Proxy-Authorization should be sent in ProxyAgent constructor\")}}__name(throwIfProxyAuthIsSent,\"throwIfProxyAuthIsSent\");module.exports=ProxyAgent;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["opts"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/dispatcher/proxy-agent.js"],"sourcesContent":["'use strict'\n\nconst { kProxy, kClose, kDestroy, kInterceptors } = require('../core/symbols')\nconst { URL } = require('node:url')\nconst Agent = require('./agent')\nconst Pool = require('./pool')\nconst DispatcherBase = require('./dispatcher-base')\nconst { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = require('../core/errors')\nconst buildConnector = require('../core/connect')\n\nconst kAgent = Symbol('proxy agent')\nconst kClient = Symbol('proxy client')\nconst kProxyHeaders = Symbol('proxy headers')\nconst kRequestTls = Symbol('request tls settings')\nconst kProxyTls = Symbol('proxy tls settings')\nconst kConnectEndpoint = Symbol('connect endpoint function')\n\nfunction defaultProtocolPort (protocol) {\n  return protocol === 'https:' ? 443 : 80\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nconst noop = () => {}\n\nclass ProxyAgent extends DispatcherBase {\n  constructor (opts) {\n    super()\n\n    if (!opts || (typeof opts === 'object' && !(opts instanceof URL) && !opts.uri)) {\n      throw new InvalidArgumentError('Proxy uri is mandatory')\n    }\n\n    const { clientFactory = defaultFactory } = opts\n    if (typeof clientFactory !== 'function') {\n      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.')\n    }\n\n    const url = this.#getUrl(opts)\n    const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url\n\n    this[kProxy] = { uri: href, protocol }\n    this[kInterceptors] = opts.interceptors?.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent)\n      ? opts.interceptors.ProxyAgent\n      : []\n    this[kRequestTls] = opts.requestTls\n    this[kProxyTls] = opts.proxyTls\n    this[kProxyHeaders] = opts.headers || {}\n\n    if (opts.auth && opts.token) {\n      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token')\n    } else if (opts.auth) {\n      /* @deprecated in favour of opts.token */\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`\n    } else if (opts.token) {\n      this[kProxyHeaders]['proxy-authorization'] = opts.token\n    } else if (username && password) {\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`\n    }\n\n    const connect = buildConnector({ ...opts.proxyTls })\n    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls })\n    this[kClient] = clientFactory(url, { connect })\n    this[kAgent] = new Agent({\n      ...opts,\n      connect: async (opts, callback) => {\n        let requestedPath = opts.host\n        if (!opts.port) {\n          requestedPath += `:${defaultProtocolPort(opts.protocol)}`\n        }\n        try {\n          const { socket, statusCode } = await this[kClient].connect({\n            origin,\n            port,\n            path: requestedPath,\n            signal: opts.signal,\n            headers: {\n              ...this[kProxyHeaders],\n              host: opts.host\n            },\n            servername: this[kProxyTls]?.servername || proxyHostname\n          })\n          if (statusCode !== 200) {\n            socket.on('error', noop).destroy()\n            callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`))\n          }\n          if (opts.protocol !== 'https:') {\n            callback(null, socket)\n            return\n          }\n          let servername\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername\n          } else {\n            servername = opts.servername\n          }\n          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback)\n        } catch (err) {\n          if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n            // Throw a custom error to avoid loop in client.js#connect\n            callback(new SecureProxyConnectionError(err))\n          } else {\n            callback(err)\n          }\n        }\n      }\n    })\n  }\n\n  dispatch (opts, handler) {\n    const headers = buildHeaders(opts.headers)\n    throwIfProxyAuthIsSent(headers)\n\n    if (headers && !('host' in headers) && !('Host' in headers)) {\n      const { host } = new URL(opts.origin)\n      headers.host = host\n    }\n\n    return this[kAgent].dispatch(\n      {\n        ...opts,\n        headers\n      },\n      handler\n    )\n  }\n\n  /**\n   * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts\n   * @returns {URL}\n   */\n  #getUrl (opts) {\n    if (typeof opts === 'string') {\n      return new URL(opts)\n    } else if (opts instanceof URL) {\n      return opts\n    } else {\n      return new URL(opts.uri)\n    }\n  }\n\n  async [kClose] () {\n    await this[kAgent].close()\n    await this[kClient].close()\n  }\n\n  async [kDestroy] () {\n    await this[kAgent].destroy()\n    await this[kClient].destroy()\n  }\n}\n\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\nfunction buildHeaders (headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {}\n\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1]\n    }\n\n    return headersPair\n  }\n\n  return headers\n}\n\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\nfunction throwIfProxyAuthIsSent (headers) {\n  const existProxyAuth = headers && Object.keys(headers)\n    .find((key) => key.toLowerCase() === 'proxy-authorization')\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')\n  }\n}\n\nmodule.exports = ProxyAgent\n"]}}