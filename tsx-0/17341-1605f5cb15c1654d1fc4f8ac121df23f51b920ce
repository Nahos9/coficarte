{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const DispatcherBase=require(\"./dispatcher-base\");const FixedQueue=require(\"./fixed-queue\");const{kConnected,kSize,kRunning,kPending,kQueued,kBusy,kFree,kUrl,kClose,kDestroy,kDispatch}=require(\"../core/symbols\");const PoolStats=require(\"./pool-stats\");const kClients=Symbol(\"clients\");const kNeedDrain=Symbol(\"needDrain\");const kQueue=Symbol(\"queue\");const kClosedResolve=Symbol(\"closed resolve\");const kOnDrain=Symbol(\"onDrain\");const kOnConnect=Symbol(\"onConnect\");const kOnDisconnect=Symbol(\"onDisconnect\");const kOnConnectionError=Symbol(\"onConnectionError\");const kGetDispatcher=Symbol(\"get dispatcher\");const kAddClient=Symbol(\"add client\");const kRemoveClient=Symbol(\"remove client\");const kStats=Symbol(\"stats\");class PoolBase extends DispatcherBase{static{__name(this,\"PoolBase\")}constructor(){super();this[kQueue]=new FixedQueue;this[kClients]=[];this[kQueued]=0;const pool=this;this[kOnDrain]=__name(function onDrain(origin,targets){const queue=pool[kQueue];let needDrain=false;while(!needDrain){const item=queue.shift();if(!item){break}pool[kQueued]--;needDrain=!this.dispatch(item.opts,item.handler)}this[kNeedDrain]=needDrain;if(!this[kNeedDrain]&&pool[kNeedDrain]){pool[kNeedDrain]=false;pool.emit(\"drain\",origin,[pool,...targets])}if(pool[kClosedResolve]&&queue.isEmpty()){Promise.all(pool[kClients].map(c=>c.close())).then(pool[kClosedResolve])}},\"onDrain\");this[kOnConnect]=(origin,targets)=>{pool.emit(\"connect\",origin,[pool,...targets])};this[kOnDisconnect]=(origin,targets,err)=>{pool.emit(\"disconnect\",origin,[pool,...targets],err)};this[kOnConnectionError]=(origin,targets,err)=>{pool.emit(\"connectionError\",origin,[pool,...targets],err)};this[kStats]=new PoolStats(this)}get[kBusy](){return this[kNeedDrain]}get[kConnected](){return this[kClients].filter(client=>client[kConnected]).length}get[kFree](){return this[kClients].filter(client=>client[kConnected]&&!client[kNeedDrain]).length}get[kPending](){let ret=this[kQueued];for(const{[kPending]:pending}of this[kClients]){ret+=pending}return ret}get[kRunning](){let ret=0;for(const{[kRunning]:running}of this[kClients]){ret+=running}return ret}get[kSize](){let ret=this[kQueued];for(const{[kSize]:size}of this[kClients]){ret+=size}return ret}get stats(){return this[kStats]}async[kClose](){if(this[kQueue].isEmpty()){await Promise.all(this[kClients].map(c=>c.close()))}else{await new Promise(resolve=>{this[kClosedResolve]=resolve})}}async[kDestroy](err){while(true){const item=this[kQueue].shift();if(!item){break}item.handler.onError(err)}await Promise.all(this[kClients].map(c=>c.destroy(err)))}[kDispatch](opts,handler){const dispatcher=this[kGetDispatcher]();if(!dispatcher){this[kNeedDrain]=true;this[kQueue].push({opts,handler});this[kQueued]++}else if(!dispatcher.dispatch(opts,handler)){dispatcher[kNeedDrain]=true;this[kNeedDrain]=!this[kGetDispatcher]()}return!this[kNeedDrain]}[kAddClient](client){client.on(\"drain\",this[kOnDrain]).on(\"connect\",this[kOnConnect]).on(\"disconnect\",this[kOnDisconnect]).on(\"connectionError\",this[kOnConnectionError]);this[kClients].push(client);if(this[kNeedDrain]){queueMicrotask(()=>{if(this[kNeedDrain]){this[kOnDrain](client[kUrl],[this,client])}})}return this}[kRemoveClient](client){client.close(()=>{const idx=this[kClients].indexOf(client);if(idx!==-1){this[kClients].splice(idx,1)}});this[kNeedDrain]=this[kClients].some(dispatcher=>!dispatcher[kNeedDrain]&&dispatcher.closed!==true&&dispatcher.destroyed!==true)}}module.exports={PoolBase,kClients,kNeedDrain,kAddClient,kRemoveClient,kGetDispatcher};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/dispatcher/pool-base.js"],"sourcesContent":["'use strict'\n\nconst DispatcherBase = require('./dispatcher-base')\nconst FixedQueue = require('./fixed-queue')\nconst { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require('../core/symbols')\nconst PoolStats = require('./pool-stats')\n\nconst kClients = Symbol('clients')\nconst kNeedDrain = Symbol('needDrain')\nconst kQueue = Symbol('queue')\nconst kClosedResolve = Symbol('closed resolve')\nconst kOnDrain = Symbol('onDrain')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kGetDispatcher = Symbol('get dispatcher')\nconst kAddClient = Symbol('add client')\nconst kRemoveClient = Symbol('remove client')\nconst kStats = Symbol('stats')\n\nclass PoolBase extends DispatcherBase {\n  constructor () {\n    super()\n\n    this[kQueue] = new FixedQueue()\n    this[kClients] = []\n    this[kQueued] = 0\n\n    const pool = this\n\n    this[kOnDrain] = function onDrain (origin, targets) {\n      const queue = pool[kQueue]\n\n      let needDrain = false\n\n      while (!needDrain) {\n        const item = queue.shift()\n        if (!item) {\n          break\n        }\n        pool[kQueued]--\n        needDrain = !this.dispatch(item.opts, item.handler)\n      }\n\n      this[kNeedDrain] = needDrain\n\n      if (!this[kNeedDrain] && pool[kNeedDrain]) {\n        pool[kNeedDrain] = false\n        pool.emit('drain', origin, [pool, ...targets])\n      }\n\n      if (pool[kClosedResolve] && queue.isEmpty()) {\n        Promise\n          .all(pool[kClients].map(c => c.close()))\n          .then(pool[kClosedResolve])\n      }\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      pool.emit('connect', origin, [pool, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      pool.emit('disconnect', origin, [pool, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      pool.emit('connectionError', origin, [pool, ...targets], err)\n    }\n\n    this[kStats] = new PoolStats(this)\n  }\n\n  get [kBusy] () {\n    return this[kNeedDrain]\n  }\n\n  get [kConnected] () {\n    return this[kClients].filter(client => client[kConnected]).length\n  }\n\n  get [kFree] () {\n    return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length\n  }\n\n  get [kPending] () {\n    let ret = this[kQueued]\n    for (const { [kPending]: pending } of this[kClients]) {\n      ret += pending\n    }\n    return ret\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { [kRunning]: running } of this[kClients]) {\n      ret += running\n    }\n    return ret\n  }\n\n  get [kSize] () {\n    let ret = this[kQueued]\n    for (const { [kSize]: size } of this[kClients]) {\n      ret += size\n    }\n    return ret\n  }\n\n  get stats () {\n    return this[kStats]\n  }\n\n  async [kClose] () {\n    if (this[kQueue].isEmpty()) {\n      await Promise.all(this[kClients].map(c => c.close()))\n    } else {\n      await new Promise((resolve) => {\n        this[kClosedResolve] = resolve\n      })\n    }\n  }\n\n  async [kDestroy] (err) {\n    while (true) {\n      const item = this[kQueue].shift()\n      if (!item) {\n        break\n      }\n      item.handler.onError(err)\n    }\n\n    await Promise.all(this[kClients].map(c => c.destroy(err)))\n  }\n\n  [kDispatch] (opts, handler) {\n    const dispatcher = this[kGetDispatcher]()\n\n    if (!dispatcher) {\n      this[kNeedDrain] = true\n      this[kQueue].push({ opts, handler })\n      this[kQueued]++\n    } else if (!dispatcher.dispatch(opts, handler)) {\n      dispatcher[kNeedDrain] = true\n      this[kNeedDrain] = !this[kGetDispatcher]()\n    }\n\n    return !this[kNeedDrain]\n  }\n\n  [kAddClient] (client) {\n    client\n      .on('drain', this[kOnDrain])\n      .on('connect', this[kOnConnect])\n      .on('disconnect', this[kOnDisconnect])\n      .on('connectionError', this[kOnConnectionError])\n\n    this[kClients].push(client)\n\n    if (this[kNeedDrain]) {\n      queueMicrotask(() => {\n        if (this[kNeedDrain]) {\n          this[kOnDrain](client[kUrl], [this, client])\n        }\n      })\n    }\n\n    return this\n  }\n\n  [kRemoveClient] (client) {\n    client.close(() => {\n      const idx = this[kClients].indexOf(client)\n      if (idx !== -1) {\n        this[kClients].splice(idx, 1)\n      }\n    })\n\n    this[kNeedDrain] = this[kClients].some(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n  }\n}\n\nmodule.exports = {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n}\n"]}}