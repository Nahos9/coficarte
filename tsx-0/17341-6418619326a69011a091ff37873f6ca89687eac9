{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{uid,states,sentCloseFrameState,emptyBuffer,opcodes}=require(\"./constants\");const{kReadyState,kSentClose,kByteParser,kReceivedClose,kResponse}=require(\"./symbols\");const{fireEvent,failWebsocketConnection,isClosing,isClosed,isEstablished,parseExtensions}=require(\"./util\");const{channels}=require(\"../../core/diagnostics\");const{CloseEvent}=require(\"./events\");const{makeRequest}=require(\"../fetch/request\");const{fetching}=require(\"../fetch/index\");const{Headers,getHeadersList}=require(\"../fetch/headers\");const{getDecodeSplit}=require(\"../fetch/util\");const{WebsocketFrameSend}=require(\"./frame\");let crypto;try{crypto=require(\"node:crypto\")}catch{}function establishWebSocketConnection(url,protocols,client,ws,onEstablish,options){const requestURL=url;requestURL.protocol=url.protocol===\"ws:\"?\"http:\":\"https:\";const request=makeRequest({urlList:[requestURL],client,serviceWorkers:\"none\",referrer:\"no-referrer\",mode:\"websocket\",credentials:\"include\",cache:\"no-store\",redirect:\"error\"});if(options.headers){const headersList=getHeadersList(new Headers(options.headers));request.headersList=headersList}const keyValue=crypto.randomBytes(16).toString(\"base64\");request.headersList.append(\"sec-websocket-key\",keyValue);request.headersList.append(\"sec-websocket-version\",\"13\");for(const protocol of protocols){request.headersList.append(\"sec-websocket-protocol\",protocol)}const permessageDeflate=\"permessage-deflate; client_max_window_bits\";request.headersList.append(\"sec-websocket-extensions\",permessageDeflate);const controller=fetching({request,useParallelQueue:true,dispatcher:options.dispatcher,processResponse(response){if(response.type===\"error\"||response.status!==101){failWebsocketConnection(ws,\"Received network error or non-101 status code.\");return}if(protocols.length!==0&&!response.headersList.get(\"Sec-WebSocket-Protocol\")){failWebsocketConnection(ws,\"Server did not respond with sent protocols.\");return}if(response.headersList.get(\"Upgrade\")?.toLowerCase()!==\"websocket\"){failWebsocketConnection(ws,'Server did not set Upgrade header to \"websocket\".');return}if(response.headersList.get(\"Connection\")?.toLowerCase()!==\"upgrade\"){failWebsocketConnection(ws,'Server did not set Connection header to \"upgrade\".');return}const secWSAccept=response.headersList.get(\"Sec-WebSocket-Accept\");const digest=crypto.createHash(\"sha1\").update(keyValue+uid).digest(\"base64\");if(secWSAccept!==digest){failWebsocketConnection(ws,\"Incorrect hash received in Sec-WebSocket-Accept header.\");return}const secExtension=response.headersList.get(\"Sec-WebSocket-Extensions\");let extensions;if(secExtension!==null){extensions=parseExtensions(secExtension);if(!extensions.has(\"permessage-deflate\")){failWebsocketConnection(ws,\"Sec-WebSocket-Extensions header does not match.\");return}}const secProtocol=response.headersList.get(\"Sec-WebSocket-Protocol\");if(secProtocol!==null){const requestProtocols=getDecodeSplit(\"sec-websocket-protocol\",request.headersList);if(!requestProtocols.includes(secProtocol)){failWebsocketConnection(ws,\"Protocol was not set in the opening handshake.\");return}}response.socket.on(\"data\",onSocketData);response.socket.on(\"close\",onSocketClose);response.socket.on(\"error\",onSocketError);if(channels.open.hasSubscribers){channels.open.publish({address:response.socket.address(),protocol:secProtocol,extensions:secExtension})}onEstablish(response,extensions)}});return controller}__name(establishWebSocketConnection,\"establishWebSocketConnection\");function closeWebSocketConnection(ws,code,reason,reasonByteLength){if(isClosing(ws)||isClosed(ws)){}else if(!isEstablished(ws)){failWebsocketConnection(ws,\"Connection was closed before it was established.\");ws[kReadyState]=states.CLOSING}else if(ws[kSentClose]===sentCloseFrameState.NOT_SENT){ws[kSentClose]=sentCloseFrameState.PROCESSING;const frame=new WebsocketFrameSend;if(code!==void 0&&reason===void 0){frame.frameData=Buffer.allocUnsafe(2);frame.frameData.writeUInt16BE(code,0)}else if(code!==void 0&&reason!==void 0){frame.frameData=Buffer.allocUnsafe(2+reasonByteLength);frame.frameData.writeUInt16BE(code,0);frame.frameData.write(reason,2,\"utf-8\")}else{frame.frameData=emptyBuffer}const socket=ws[kResponse].socket;socket.write(frame.createFrame(opcodes.CLOSE));ws[kSentClose]=sentCloseFrameState.SENT;ws[kReadyState]=states.CLOSING}else{ws[kReadyState]=states.CLOSING}}__name(closeWebSocketConnection,\"closeWebSocketConnection\");function onSocketData(chunk){if(!this.ws[kByteParser].write(chunk)){this.pause()}}__name(onSocketData,\"onSocketData\");function onSocketClose(){const{ws}=this;const{[kResponse]:response}=ws;response.socket.off(\"data\",onSocketData);response.socket.off(\"close\",onSocketClose);response.socket.off(\"error\",onSocketError);const wasClean=ws[kSentClose]===sentCloseFrameState.SENT&&ws[kReceivedClose];let code=1005;let reason=\"\";const result=ws[kByteParser].closingInfo;if(result&&!result.error){code=result.code??1005;reason=result.reason}else if(!ws[kReceivedClose]){code=1006}ws[kReadyState]=states.CLOSED;fireEvent(\"close\",ws,(type,init)=>new CloseEvent(type,init),{wasClean,code,reason});if(channels.close.hasSubscribers){channels.close.publish({websocket:ws,code,reason})}}__name(onSocketClose,\"onSocketClose\");function onSocketError(error){const{ws}=this;ws[kReadyState]=states.CLOSING;if(channels.socketError.hasSubscribers){channels.socketError.publish(error)}this.destroy()}__name(onSocketError,\"onSocketError\");module.exports={establishWebSocketConnection,closeWebSocketConnection};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/websocket/connection.js"],"sourcesContent":["'use strict'\n\nconst { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = require('./constants')\nconst {\n  kReadyState,\n  kSentClose,\n  kByteParser,\n  kReceivedClose,\n  kResponse\n} = require('./symbols')\nconst { fireEvent, failWebsocketConnection, isClosing, isClosed, isEstablished, parseExtensions } = require('./util')\nconst { channels } = require('../../core/diagnostics')\nconst { CloseEvent } = require('./events')\nconst { makeRequest } = require('../fetch/request')\nconst { fetching } = require('../fetch/index')\nconst { Headers, getHeadersList } = require('../fetch/headers')\nconst { getDecodeSplit } = require('../fetch/util')\nconst { WebsocketFrameSend } = require('./frame')\n\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = require('node:crypto')\n/* c8 ignore next 3 */\n} catch {\n\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any, extensions: string[] | undefined) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */\nfunction establishWebSocketConnection (url, protocols, client, ws, onEstablish, options) {\n  // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if url’s\n  //    scheme is \"ws\", and to \"https\" otherwise.\n  const requestURL = url\n\n  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:'\n\n  // 2. Let request be a new request, whose URL is requestURL, client is client,\n  //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n  //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n  //    and redirect mode is \"error\".\n  const request = makeRequest({\n    urlList: [requestURL],\n    client,\n    serviceWorkers: 'none',\n    referrer: 'no-referrer',\n    mode: 'websocket',\n    credentials: 'include',\n    cache: 'no-store',\n    redirect: 'error'\n  })\n\n  // Note: undici extension, allow setting custom headers.\n  if (options.headers) {\n    const headersList = getHeadersList(new Headers(options.headers))\n\n    request.headersList = headersList\n  }\n\n  // 3. Append (`Upgrade`, `websocket`) to request’s header list.\n  // 4. Append (`Connection`, `Upgrade`) to request’s header list.\n  // Note: both of these are handled by undici currently.\n  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n\n  // 5. Let keyValue be a nonce consisting of a randomly selected\n  //    16-byte value that has been forgiving-base64-encoded and\n  //    isomorphic encoded.\n  const keyValue = crypto.randomBytes(16).toString('base64')\n\n  // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-key', keyValue)\n\n  // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-version', '13')\n\n  // 8. For each protocol in protocols, combine\n  //    (`Sec-WebSocket-Protocol`, protocol) in request’s header\n  //    list.\n  for (const protocol of protocols) {\n    request.headersList.append('sec-websocket-protocol', protocol)\n  }\n\n  // 9. Let permessageDeflate be a user-agent defined\n  //    \"permessage-deflate\" extension header value.\n  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n  const permessageDeflate = 'permessage-deflate; client_max_window_bits'\n\n  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n  //     request’s header list.\n  request.headersList.append('sec-websocket-extensions', permessageDeflate)\n\n  // 11. Fetch request with useParallelQueue set to true, and\n  //     processResponse given response being these steps:\n  const controller = fetching({\n    request,\n    useParallelQueue: true,\n    dispatcher: options.dispatcher,\n    processResponse (response) {\n      // 1. If response is a network error or its status is not 101,\n      //    fail the WebSocket connection.\n      if (response.type === 'error' || response.status !== 101) {\n        failWebsocketConnection(ws, 'Received network error or non-101 status code.')\n        return\n      }\n\n      // 2. If protocols is not the empty list and extracting header\n      //    list values given `Sec-WebSocket-Protocol` and response’s\n      //    header list results in null, failure, or the empty byte\n      //    sequence, then fail the WebSocket connection.\n      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Server did not respond with sent protocols.')\n        return\n      }\n\n      // 3. Follow the requirements stated step 2 to step 6, inclusive,\n      //    of the last set of steps in section 4.1 of The WebSocket\n      //    Protocol to validate response. This either results in fail\n      //    the WebSocket connection or the WebSocket connection is\n      //    established.\n\n      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n      //    header field contains a value that is not an ASCII case-\n      //    insensitive match for the value \"websocket\", the client MUST\n      //    _Fail the WebSocket Connection_.\n      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n        failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".')\n        return\n      }\n\n      // 3. If the response lacks a |Connection| header field or the\n      //    |Connection| header field doesn't contain a token that is an\n      //    ASCII case-insensitive match for the value \"Upgrade\", the client\n      //    MUST _Fail the WebSocket Connection_.\n      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n        failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".')\n        return\n      }\n\n      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n      //    the |Sec-WebSocket-Accept| contains a value other than the\n      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n      //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n      //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n      //    trailing whitespace, the client MUST _Fail the WebSocket\n      //    Connection_.\n      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept')\n      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64')\n      if (secWSAccept !== digest) {\n        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.')\n        return\n      }\n\n      // 5. If the response includes a |Sec-WebSocket-Extensions| header\n      //    field and this header field indicates the use of an extension\n      //    that was not present in the client's handshake (the server has\n      //    indicated an extension not requested by the client), the client\n      //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n      //    header field to determine which extensions are requested is\n      //    discussed in Section 9.1.)\n      const secExtension = response.headersList.get('Sec-WebSocket-Extensions')\n      let extensions\n\n      if (secExtension !== null) {\n        extensions = parseExtensions(secExtension)\n\n        if (!extensions.has('permessage-deflate')) {\n          failWebsocketConnection(ws, 'Sec-WebSocket-Extensions header does not match.')\n          return\n        }\n      }\n\n      // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n      //    and this header field indicates the use of a subprotocol that was\n      //    not present in the client's handshake (the server has indicated a\n      //    subprotocol not requested by the client), the client MUST _Fail\n      //    the WebSocket Connection_.\n      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol')\n\n      if (secProtocol !== null) {\n        const requestProtocols = getDecodeSplit('sec-websocket-protocol', request.headersList)\n\n        // The client can request that the server use a specific subprotocol by\n        // including the |Sec-WebSocket-Protocol| field in its handshake.  If it\n        // is specified, the server needs to include the same field and one of\n        // the selected subprotocol values in its response for the connection to\n        // be established.\n        if (!requestProtocols.includes(secProtocol)) {\n          failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.')\n          return\n        }\n      }\n\n      response.socket.on('data', onSocketData)\n      response.socket.on('close', onSocketClose)\n      response.socket.on('error', onSocketError)\n\n      if (channels.open.hasSubscribers) {\n        channels.open.publish({\n          address: response.socket.address(),\n          protocol: secProtocol,\n          extensions: secExtension\n        })\n      }\n\n      onEstablish(response, extensions)\n    }\n  })\n\n  return controller\n}\n\nfunction closeWebSocketConnection (ws, code, reason, reasonByteLength) {\n  if (isClosing(ws) || isClosed(ws)) {\n    // If this's ready state is CLOSING (2) or CLOSED (3)\n    // Do nothing.\n  } else if (!isEstablished(ws)) {\n    // If the WebSocket connection is not yet established\n    // Fail the WebSocket connection and set this's ready state\n    // to CLOSING (2).\n    failWebsocketConnection(ws, 'Connection was closed before it was established.')\n    ws[kReadyState] = states.CLOSING\n  } else if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {\n    // If the WebSocket closing handshake has not yet been started\n    // Start the WebSocket closing handshake and set this's ready\n    // state to CLOSING (2).\n    // - If neither code nor reason is present, the WebSocket Close\n    //   message must not have a body.\n    // - If code is present, then the status code to use in the\n    //   WebSocket Close message must be the integer given by code.\n    // - If reason is also present, then reasonBytes must be\n    //   provided in the Close message after the status code.\n\n    ws[kSentClose] = sentCloseFrameState.PROCESSING\n\n    const frame = new WebsocketFrameSend()\n\n    // If neither code nor reason is present, the WebSocket Close\n    // message must not have a body.\n\n    // If code is present, then the status code to use in the\n    // WebSocket Close message must be the integer given by code.\n    if (code !== undefined && reason === undefined) {\n      frame.frameData = Buffer.allocUnsafe(2)\n      frame.frameData.writeUInt16BE(code, 0)\n    } else if (code !== undefined && reason !== undefined) {\n      // If reason is also present, then reasonBytes must be\n      // provided in the Close message after the status code.\n      frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength)\n      frame.frameData.writeUInt16BE(code, 0)\n      // the body MAY contain UTF-8-encoded data with value /reason/\n      frame.frameData.write(reason, 2, 'utf-8')\n    } else {\n      frame.frameData = emptyBuffer\n    }\n\n    /** @type {import('stream').Duplex} */\n    const socket = ws[kResponse].socket\n\n    socket.write(frame.createFrame(opcodes.CLOSE))\n\n    ws[kSentClose] = sentCloseFrameState.SENT\n\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n    ws[kReadyState] = states.CLOSING\n  } else {\n    // Otherwise\n    // Set this's ready state to CLOSING (2).\n    ws[kReadyState] = states.CLOSING\n  }\n}\n\n/**\n * @param {Buffer} chunk\n */\nfunction onSocketData (chunk) {\n  if (!this.ws[kByteParser].write(chunk)) {\n    this.pause()\n  }\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */\nfunction onSocketClose () {\n  const { ws } = this\n  const { [kResponse]: response } = ws\n\n  response.socket.off('data', onSocketData)\n  response.socket.off('close', onSocketClose)\n  response.socket.off('error', onSocketError)\n\n  // If the TCP connection was closed after the\n  // WebSocket closing handshake was completed, the WebSocket connection\n  // is said to have been closed _cleanly_.\n  const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose]\n\n  let code = 1005\n  let reason = ''\n\n  const result = ws[kByteParser].closingInfo\n\n  if (result && !result.error) {\n    code = result.code ?? 1005\n    reason = result.reason\n  } else if (!ws[kReceivedClose]) {\n    // If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    code = 1006\n  }\n\n  // 1. Change the ready state to CLOSED (3).\n  ws[kReadyState] = states.CLOSED\n\n  // 2. If the user agent was required to fail the WebSocket\n  //    connection, or if the WebSocket connection was closed\n  //    after being flagged as full, fire an event named error\n  //    at the WebSocket object.\n  // TODO\n\n  // 3. Fire an event named close at the WebSocket object,\n  //    using CloseEvent, with the wasClean attribute\n  //    initialized to true if the connection closed cleanly\n  //    and false otherwise, the code attribute initialized to\n  //    the WebSocket connection close code, and the reason\n  //    attribute initialized to the result of applying UTF-8\n  //    decode without BOM to the WebSocket connection close\n  //    reason.\n  // TODO: process.nextTick\n  fireEvent('close', ws, (type, init) => new CloseEvent(type, init), {\n    wasClean, code, reason\n  })\n\n  if (channels.close.hasSubscribers) {\n    channels.close.publish({\n      websocket: ws,\n      code,\n      reason\n    })\n  }\n}\n\nfunction onSocketError (error) {\n  const { ws } = this\n\n  ws[kReadyState] = states.CLOSING\n\n  if (channels.socketError.hasSubscribers) {\n    channels.socketError.publish(error)\n  }\n\n  this.destroy()\n}\n\nmodule.exports = {\n  establishWebSocketConnection,\n  closeWebSocketConnection\n}\n"]}}