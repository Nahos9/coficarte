{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{webidl}=require(\"../fetch/webidl\");const{URLSerializer}=require(\"../fetch/data-url\");const{environmentSettingsObject}=require(\"../fetch/util\");const{staticPropertyDescriptors,states,sentCloseFrameState,sendHints}=require(\"./constants\");const{kWebSocketURL,kReadyState,kController,kBinaryType,kResponse,kSentClose,kByteParser}=require(\"./symbols\");const{isConnecting,isEstablished,isClosing,isValidSubprotocol,fireEvent}=require(\"./util\");const{establishWebSocketConnection,closeWebSocketConnection}=require(\"./connection\");const{ByteParser}=require(\"./receiver\");const{kEnumerableProperty,isBlobLike}=require(\"../../core/util\");const{getGlobalDispatcher}=require(\"../../global\");const{types}=require(\"node:util\");const{ErrorEvent,CloseEvent}=require(\"./events\");const{SendQueue}=require(\"./sender\");class WebSocket extends EventTarget{static{__name(this,\"WebSocket\")}#events={open:null,error:null,close:null,message:null};#bufferedAmount=0;#protocol=\"\";#extensions=\"\";#sendQueue;constructor(url,protocols=[]){super();webidl.util.markAsUncloneable(this);const prefix=\"WebSocket constructor\";webidl.argumentLengthCheck(arguments,1,prefix);const options=webidl.converters[\"DOMString or sequence<DOMString> or WebSocketInit\"](protocols,prefix,\"options\");url=webidl.converters.USVString(url,prefix,\"url\");protocols=options.protocols;const baseURL=environmentSettingsObject.settingsObject.baseUrl;let urlRecord;try{urlRecord=new URL(url,baseURL)}catch(e){throw new DOMException(e,\"SyntaxError\")}if(urlRecord.protocol===\"http:\"){urlRecord.protocol=\"ws:\"}else if(urlRecord.protocol===\"https:\"){urlRecord.protocol=\"wss:\"}if(urlRecord.protocol!==\"ws:\"&&urlRecord.protocol!==\"wss:\"){throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,\"SyntaxError\")}if(urlRecord.hash||urlRecord.href.endsWith(\"#\")){throw new DOMException(\"Got fragment\",\"SyntaxError\")}if(typeof protocols===\"string\"){protocols=[protocols]}if(protocols.length!==new Set(protocols.map(p=>p.toLowerCase())).size){throw new DOMException(\"Invalid Sec-WebSocket-Protocol value\",\"SyntaxError\")}if(protocols.length>0&&!protocols.every(p=>isValidSubprotocol(p))){throw new DOMException(\"Invalid Sec-WebSocket-Protocol value\",\"SyntaxError\")}this[kWebSocketURL]=new URL(urlRecord.href);const client=environmentSettingsObject.settingsObject;this[kController]=establishWebSocketConnection(urlRecord,protocols,client,this,(response,extensions)=>this.#onConnectionEstablished(response,extensions),options);this[kReadyState]=WebSocket.CONNECTING;this[kSentClose]=sentCloseFrameState.NOT_SENT;this[kBinaryType]=\"blob\"}close(code=void 0,reason=void 0){webidl.brandCheck(this,WebSocket);const prefix=\"WebSocket.close\";if(code!==void 0){code=webidl.converters[\"unsigned short\"](code,prefix,\"code\",{clamp:true})}if(reason!==void 0){reason=webidl.converters.USVString(reason,prefix,\"reason\")}if(code!==void 0){if(code!==1e3&&(code<3e3||code>4999)){throw new DOMException(\"invalid code\",\"InvalidAccessError\")}}let reasonByteLength=0;if(reason!==void 0){reasonByteLength=Buffer.byteLength(reason);if(reasonByteLength>123){throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`,\"SyntaxError\")}}closeWebSocketConnection(this,code,reason,reasonByteLength)}send(data){webidl.brandCheck(this,WebSocket);const prefix=\"WebSocket.send\";webidl.argumentLengthCheck(arguments,1,prefix);data=webidl.converters.WebSocketSendData(data,prefix,\"data\");if(isConnecting(this)){throw new DOMException(\"Sent before connected.\",\"InvalidStateError\")}if(!isEstablished(this)||isClosing(this)){return}if(typeof data===\"string\"){const length=Buffer.byteLength(data);this.#bufferedAmount+=length;this.#sendQueue.add(data,()=>{this.#bufferedAmount-=length},sendHints.string)}else if(types.isArrayBuffer(data)){this.#bufferedAmount+=data.byteLength;this.#sendQueue.add(data,()=>{this.#bufferedAmount-=data.byteLength},sendHints.arrayBuffer)}else if(ArrayBuffer.isView(data)){this.#bufferedAmount+=data.byteLength;this.#sendQueue.add(data,()=>{this.#bufferedAmount-=data.byteLength},sendHints.typedArray)}else if(isBlobLike(data)){this.#bufferedAmount+=data.size;this.#sendQueue.add(data,()=>{this.#bufferedAmount-=data.size},sendHints.blob)}}get readyState(){webidl.brandCheck(this,WebSocket);return this[kReadyState]}get bufferedAmount(){webidl.brandCheck(this,WebSocket);return this.#bufferedAmount}get url(){webidl.brandCheck(this,WebSocket);return URLSerializer(this[kWebSocketURL])}get extensions(){webidl.brandCheck(this,WebSocket);return this.#extensions}get protocol(){webidl.brandCheck(this,WebSocket);return this.#protocol}get onopen(){webidl.brandCheck(this,WebSocket);return this.#events.open}set onopen(fn){webidl.brandCheck(this,WebSocket);if(this.#events.open){this.removeEventListener(\"open\",this.#events.open)}if(typeof fn===\"function\"){this.#events.open=fn;this.addEventListener(\"open\",fn)}else{this.#events.open=null}}get onerror(){webidl.brandCheck(this,WebSocket);return this.#events.error}set onerror(fn){webidl.brandCheck(this,WebSocket);if(this.#events.error){this.removeEventListener(\"error\",this.#events.error)}if(typeof fn===\"function\"){this.#events.error=fn;this.addEventListener(\"error\",fn)}else{this.#events.error=null}}get onclose(){webidl.brandCheck(this,WebSocket);return this.#events.close}set onclose(fn){webidl.brandCheck(this,WebSocket);if(this.#events.close){this.removeEventListener(\"close\",this.#events.close)}if(typeof fn===\"function\"){this.#events.close=fn;this.addEventListener(\"close\",fn)}else{this.#events.close=null}}get onmessage(){webidl.brandCheck(this,WebSocket);return this.#events.message}set onmessage(fn){webidl.brandCheck(this,WebSocket);if(this.#events.message){this.removeEventListener(\"message\",this.#events.message)}if(typeof fn===\"function\"){this.#events.message=fn;this.addEventListener(\"message\",fn)}else{this.#events.message=null}}get binaryType(){webidl.brandCheck(this,WebSocket);return this[kBinaryType]}set binaryType(type){webidl.brandCheck(this,WebSocket);if(type!==\"blob\"&&type!==\"arraybuffer\"){this[kBinaryType]=\"blob\"}else{this[kBinaryType]=type}}#onConnectionEstablished(response,parsedExtensions){this[kResponse]=response;const parser=new ByteParser(this,parsedExtensions);parser.on(\"drain\",onParserDrain);parser.on(\"error\",onParserError.bind(this));response.socket.ws=this;this[kByteParser]=parser;this.#sendQueue=new SendQueue(response.socket);this[kReadyState]=states.OPEN;const extensions=response.headersList.get(\"sec-websocket-extensions\");if(extensions!==null){this.#extensions=extensions}const protocol=response.headersList.get(\"sec-websocket-protocol\");if(protocol!==null){this.#protocol=protocol}fireEvent(\"open\",this)}}WebSocket.CONNECTING=WebSocket.prototype.CONNECTING=states.CONNECTING;WebSocket.OPEN=WebSocket.prototype.OPEN=states.OPEN;WebSocket.CLOSING=WebSocket.prototype.CLOSING=states.CLOSING;WebSocket.CLOSED=WebSocket.prototype.CLOSED=states.CLOSED;Object.defineProperties(WebSocket.prototype,{CONNECTING:staticPropertyDescriptors,OPEN:staticPropertyDescriptors,CLOSING:staticPropertyDescriptors,CLOSED:staticPropertyDescriptors,url:kEnumerableProperty,readyState:kEnumerableProperty,bufferedAmount:kEnumerableProperty,onopen:kEnumerableProperty,onerror:kEnumerableProperty,onclose:kEnumerableProperty,close:kEnumerableProperty,onmessage:kEnumerableProperty,binaryType:kEnumerableProperty,send:kEnumerableProperty,extensions:kEnumerableProperty,protocol:kEnumerableProperty,[Symbol.toStringTag]:{value:\"WebSocket\",writable:false,enumerable:false,configurable:true}});Object.defineProperties(WebSocket,{CONNECTING:staticPropertyDescriptors,OPEN:staticPropertyDescriptors,CLOSING:staticPropertyDescriptors,CLOSED:staticPropertyDescriptors});webidl.converters[\"sequence<DOMString>\"]=webidl.sequenceConverter(webidl.converters.DOMString);webidl.converters[\"DOMString or sequence<DOMString>\"]=function(V,prefix,argument){if(webidl.util.Type(V)===\"Object\"&&Symbol.iterator in V){return webidl.converters[\"sequence<DOMString>\"](V)}return webidl.converters.DOMString(V,prefix,argument)};webidl.converters.WebSocketInit=webidl.dictionaryConverter([{key:\"protocols\",converter:webidl.converters[\"DOMString or sequence<DOMString>\"],defaultValue:()=>new Array(0)},{key:\"dispatcher\",converter:webidl.converters.any,defaultValue:()=>getGlobalDispatcher()},{key:\"headers\",converter:webidl.nullableConverter(webidl.converters.HeadersInit)}]);webidl.converters[\"DOMString or sequence<DOMString> or WebSocketInit\"]=function(V){if(webidl.util.Type(V)===\"Object\"&&!(Symbol.iterator in V)){return webidl.converters.WebSocketInit(V)}return{protocols:webidl.converters[\"DOMString or sequence<DOMString>\"](V)}};webidl.converters.WebSocketSendData=function(V){if(webidl.util.Type(V)===\"Object\"){if(isBlobLike(V)){return webidl.converters.Blob(V,{strict:false})}if(ArrayBuffer.isView(V)||types.isArrayBuffer(V)){return webidl.converters.BufferSource(V)}}return webidl.converters.USVString(V)};function onParserDrain(){this.ws[kResponse].socket.resume()}__name(onParserDrain,\"onParserDrain\");function onParserError(err){let message;let code;if(err instanceof CloseEvent){message=err.reason;code=err.code}else{message=err.message}fireEvent(\"error\",this,()=>new ErrorEvent(\"error\",{error:err,message}));closeWebSocketConnection(this,code)}__name(onParserError,\"onParserError\");module.exports={WebSocket};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/websocket/websocket.js"],"sourcesContent":["'use strict'\n\nconst { webidl } = require('../fetch/webidl')\nconst { URLSerializer } = require('../fetch/data-url')\nconst { environmentSettingsObject } = require('../fetch/util')\nconst { staticPropertyDescriptors, states, sentCloseFrameState, sendHints } = require('./constants')\nconst {\n  kWebSocketURL,\n  kReadyState,\n  kController,\n  kBinaryType,\n  kResponse,\n  kSentClose,\n  kByteParser\n} = require('./symbols')\nconst {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isValidSubprotocol,\n  fireEvent\n} = require('./util')\nconst { establishWebSocketConnection, closeWebSocketConnection } = require('./connection')\nconst { ByteParser } = require('./receiver')\nconst { kEnumerableProperty, isBlobLike } = require('../../core/util')\nconst { getGlobalDispatcher } = require('../../global')\nconst { types } = require('node:util')\nconst { ErrorEvent, CloseEvent } = require('./events')\nconst { SendQueue } = require('./sender')\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  }\n\n  #bufferedAmount = 0\n  #protocol = ''\n  #extensions = ''\n\n  /** @type {SendQueue} */\n  #sendQueue\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor (url, protocols = []) {\n    super()\n\n    webidl.util.markAsUncloneable(this)\n\n    const prefix = 'WebSocket constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols, prefix, 'options')\n\n    url = webidl.converters.USVString(url, prefix, 'url')\n    protocols = options.protocols\n\n    // 1. Let baseURL be this's relevant settings object's API base URL.\n    const baseURL = environmentSettingsObject.settingsObject.baseUrl\n\n    // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n    let urlRecord\n\n    try {\n      urlRecord = new URL(url, baseURL)\n    } catch (e) {\n      // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 4. If urlRecord’s scheme is \"http\", then set urlRecord’s scheme to \"ws\".\n    if (urlRecord.protocol === 'http:') {\n      urlRecord.protocol = 'ws:'\n    } else if (urlRecord.protocol === 'https:') {\n      // 5. Otherwise, if urlRecord’s scheme is \"https\", set urlRecord’s scheme to \"wss\".\n      urlRecord.protocol = 'wss:'\n    }\n\n    // 6. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n      throw new DOMException(\n        `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,\n        'SyntaxError'\n      )\n    }\n\n    // 7. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n    //    DOMException.\n    if (urlRecord.hash || urlRecord.href.endsWith('#')) {\n      throw new DOMException('Got fragment', 'SyntaxError')\n    }\n\n    // 8. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols]\n    }\n\n    // 9. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 10. Set this's url to urlRecord.\n    this[kWebSocketURL] = new URL(urlRecord.href)\n\n    // 11. Let client be this's relevant settings object.\n    const client = environmentSettingsObject.settingsObject\n\n    // 12. Run this step in parallel:\n\n    //    1. Establish a WebSocket connection given urlRecord, protocols,\n    //       and client.\n    this[kController] = establishWebSocketConnection(\n      urlRecord,\n      protocols,\n      client,\n      this,\n      (response, extensions) => this.#onConnectionEstablished(response, extensions),\n      options\n    )\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this[kReadyState] = WebSocket.CONNECTING\n\n    this[kSentClose] = sentCloseFrameState.NOT_SENT\n\n    // The extensions attribute must initially return the empty string.\n\n    // The protocol attribute must initially return the empty string.\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this[kBinaryType] = 'blob'\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close (code = undefined, reason = undefined) {\n    webidl.brandCheck(this, WebSocket)\n\n    const prefix = 'WebSocket.close'\n\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, prefix, 'code', { clamp: true })\n    }\n\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason, prefix, 'reason')\n    }\n\n    // 1. If code is present, but is neither an integer equal to 1000 nor an\n    //    integer in the range 3000 to 4999, inclusive, throw an\n    //    \"InvalidAccessError\" DOMException.\n    if (code !== undefined) {\n      if (code !== 1000 && (code < 3000 || code > 4999)) {\n        throw new DOMException('invalid code', 'InvalidAccessError')\n      }\n    }\n\n    let reasonByteLength = 0\n\n    // 2. If reason is present, then run these substeps:\n    if (reason !== undefined) {\n      // 1. Let reasonBytes be the result of encoding reason.\n      // 2. If reasonBytes is longer than 123 bytes, then throw a\n      //    \"SyntaxError\" DOMException.\n      reasonByteLength = Buffer.byteLength(reason)\n\n      if (reasonByteLength > 123) {\n        throw new DOMException(\n          `Reason must be less than 123 bytes; received ${reasonByteLength}`,\n          'SyntaxError'\n        )\n      }\n    }\n\n    // 3. Run the first matching steps from the following list:\n    closeWebSocketConnection(this, code, reason, reasonByteLength)\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send (data) {\n    webidl.brandCheck(this, WebSocket)\n\n    const prefix = 'WebSocket.send'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    data = webidl.converters.WebSocketSendData(data, prefix, 'data')\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (isConnecting(this)) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError')\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this) || isClosing(this)) {\n      return\n    }\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const length = Buffer.byteLength(data)\n\n      this.#bufferedAmount += length\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= length\n      }, sendHints.string)\n    } else if (types.isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      this.#bufferedAmount += data.byteLength\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength\n      }, sendHints.arrayBuffer)\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of data’s buffer in bytes.\n\n      this.#bufferedAmount += data.byteLength\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength\n      }, sendHints.typedArray)\n    } else if (isBlobLike(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob object’s raw data, in bytes.\n\n      this.#bufferedAmount += data.size\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.size\n      }, sendHints.blob)\n    }\n  }\n\n  get readyState () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The readyState getter steps are to return this's ready state.\n    return this[kReadyState]\n  }\n\n  get bufferedAmount () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#bufferedAmount\n  }\n\n  get url () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this[kWebSocketURL])\n  }\n\n  get extensions () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#extensions\n  }\n\n  get protocol () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#protocol\n  }\n\n  get onopen () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.open = fn\n      this.addEventListener('open', fn)\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this.#events.error = null\n    }\n  }\n\n  get onclose () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.close\n  }\n\n  set onclose (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.close = fn\n      this.addEventListener('close', fn)\n    } else {\n      this.#events.close = null\n    }\n  }\n\n  get onmessage () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.message = fn\n      this.addEventListener('message', fn)\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get binaryType () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this[kBinaryType]\n  }\n\n  set binaryType (type) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this[kBinaryType] = 'blob'\n    } else {\n      this[kBinaryType] = type\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */\n  #onConnectionEstablished (response, parsedExtensions) {\n    // processResponse is called when the \"response’s header list has been received and initialized.\"\n    // once this happens, the connection is open\n    this[kResponse] = response\n\n    const parser = new ByteParser(this, parsedExtensions)\n    parser.on('drain', onParserDrain)\n    parser.on('error', onParserError.bind(this))\n\n    response.socket.ws = this\n    this[kByteParser] = parser\n\n    this.#sendQueue = new SendQueue(response.socket)\n\n    // 1. Change the ready state to OPEN (1).\n    this[kReadyState] = states.OPEN\n\n    // 2. Change the extensions attribute’s value to the extensions in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n    const extensions = response.headersList.get('sec-websocket-extensions')\n\n    if (extensions !== null) {\n      this.#extensions = extensions\n    }\n\n    // 3. Change the protocol attribute’s value to the subprotocol in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n    const protocol = response.headersList.get('sec-websocket-protocol')\n\n    if (protocol !== null) {\n      this.#protocol = protocol\n    }\n\n    // 4. Fire an event named open at the WebSocket object.\n    fireEvent('open', this)\n  }\n}\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED\n\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n})\n\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(\n  webidl.converters.DOMString\n)\n\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V, prefix, argument) {\n  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V)\n  }\n\n  return webidl.converters.DOMString(V, prefix, argument)\n}\n\n// This implements the proposal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n  {\n    key: 'protocols',\n    converter: webidl.converters['DOMString or sequence<DOMString>'],\n    defaultValue: () => new Array(0)\n  },\n  {\n    key: 'dispatcher',\n    converter: webidl.converters.any,\n    defaultValue: () => getGlobalDispatcher()\n  },\n  {\n    key: 'headers',\n    converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n  }\n])\n\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {\n    return webidl.converters.WebSocketInit(V)\n  }\n\n  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }\n}\n\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (isBlobLike(V)) {\n      return webidl.converters.Blob(V, { strict: false })\n    }\n\n    if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {\n      return webidl.converters.BufferSource(V)\n    }\n  }\n\n  return webidl.converters.USVString(V)\n}\n\nfunction onParserDrain () {\n  this.ws[kResponse].socket.resume()\n}\n\nfunction onParserError (err) {\n  let message\n  let code\n\n  if (err instanceof CloseEvent) {\n    message = err.reason\n    code = err.code\n  } else {\n    message = err.message\n  }\n\n  fireEvent('error', this, () => new ErrorEvent('error', { error: err, message }))\n\n  closeWebSocketConnection(this, code)\n}\n\nmodule.exports = {\n  WebSocket\n}\n"]}}