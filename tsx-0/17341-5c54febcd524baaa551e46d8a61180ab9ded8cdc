{"code":"(()=>{\nvar __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const assert=require(\"node:assert\");const{ResponseStatusCodeError}=require(\"../core/errors\");const{chunksDecode}=require(\"./readable\");const CHUNK_LIMIT=128*1024;async function getResolveErrorBodyCallback({callback,body,contentType,statusCode,statusMessage,headers}){assert(body);let chunks=[];let length=0;try{for await(const chunk of body){chunks.push(chunk);length+=chunk.length;if(length>CHUNK_LIMIT){chunks=[];length=0;break}}}catch{chunks=[];length=0}const message=`Response status code ${statusCode}${statusMessage?`: ${statusMessage}`:\"\"}`;if(statusCode===204||!contentType||!length){queueMicrotask(()=>callback(new ResponseStatusCodeError(message,statusCode,headers)));return}const stackTraceLimit=Error.stackTraceLimit;Error.stackTraceLimit=0;let payload;try{if(isContentTypeApplicationJson(contentType)){payload=JSON.parse(chunksDecode(chunks,length))}else if(isContentTypeText(contentType)){payload=chunksDecode(chunks,length)}}catch{}finally{Error.stackTraceLimit=stackTraceLimit}queueMicrotask(()=>callback(new ResponseStatusCodeError(message,statusCode,headers,payload)))}__name(getResolveErrorBodyCallback,\"getResolveErrorBodyCallback\");const isContentTypeApplicationJson=__name(contentType=>{return contentType.length>15&&contentType[11]===\"/\"&&contentType[0]===\"a\"&&contentType[1]===\"p\"&&contentType[2]===\"p\"&&contentType[3]===\"l\"&&contentType[4]===\"i\"&&contentType[5]===\"c\"&&contentType[6]===\"a\"&&contentType[7]===\"t\"&&contentType[8]===\"i\"&&contentType[9]===\"o\"&&contentType[10]===\"n\"&&contentType[12]===\"j\"&&contentType[13]===\"s\"&&contentType[14]===\"o\"&&contentType[15]===\"n\"},\"isContentTypeApplicationJson\");const isContentTypeText=__name(contentType=>{return contentType.length>4&&contentType[4]===\"/\"&&contentType[0]===\"t\"&&contentType[1]===\"e\"&&contentType[2]===\"x\"&&contentType[3]===\"t\"},\"isContentTypeText\");module.exports={getResolveErrorBodyCallback,isContentTypeApplicationJson,isContentTypeText};\n})()\n","warnings":[],"map":{"version":3,"mappings":";kHAAA,MAAM,OAAS,QAAQ,aAAa,EACpC,KAAM,CACJ,uBACF,EAAI,QAAQ,gBAAgB,EAE5B,KAAM,CAAE,YAAa,EAAI,QAAQ,YAAY,EAC7C,MAAM,YAAc,IAAM,KAE1B,eAAe,4BAA6B,CAAE,SAAU,KAAM,YAAa,WAAY,cAAe,OAAQ,EAAG,CAC/G,OAAO,IAAI,EAEX,IAAI,OAAS,CAAC,EACd,IAAI,OAAS,EAEb,GAAI,CACF,gBAAiB,SAAS,KAAM,CAC9B,OAAO,KAAK,KAAK,EACjB,QAAU,MAAM,OAChB,GAAI,OAAS,YAAa,CACxB,OAAS,CAAC,EACV,OAAS,EACT,KACF,CACF,CACF,MAAQ,CACN,OAAS,CAAC,EACV,OAAS,CAEX,CAEA,MAAM,QAAU,wBAAwB,UAAU,GAAG,cAAgB,KAAK,aAAa,GAAK,EAAE,GAE9F,GAAI,aAAe,KAAO,CAAC,aAAe,CAAC,OAAQ,CACjD,eAAe,IAAM,SAAS,IAAI,wBAAwB,QAAS,WAAY,OAAO,CAAC,CAAC,EACxF,MACF,CAEA,MAAM,gBAAkB,MAAM,gBAC9B,MAAM,gBAAkB,EACxB,IAAI,QAEJ,GAAI,CACF,GAAI,6BAA6B,WAAW,EAAG,CAC7C,QAAU,KAAK,MAAM,aAAa,OAAQ,MAAM,CAAC,CACnD,SAAW,kBAAkB,WAAW,EAAG,CACzC,QAAU,aAAa,OAAQ,MAAM,CACvC,CACF,MAAQ,CAER,QAAE,CACA,MAAM,gBAAkB,eAC1B,CACA,eAAe,IAAM,SAAS,IAAI,wBAAwB,QAAS,WAAY,QAAS,OAAO,CAAC,CAAC,CACnG,CA7Ce,kEA+Cf,MAAM,6BAA+B,OAAC,aAAgB,CACpD,OACE,YAAY,OAAS,IACrB,YAAY,EAAE,IAAM,KACpB,YAAY,CAAC,IAAM,KACnB,YAAY,CAAC,IAAM,KACnB,YAAY,CAAC,IAAM,KACnB,YAAY,CAAC,IAAM,KACnB,YAAY,CAAC,IAAM,KACnB,YAAY,CAAC,IAAM,KACnB,YAAY,CAAC,IAAM,KACnB,YAAY,CAAC,IAAM,KACnB,YAAY,CAAC,IAAM,KACnB,YAAY,CAAC,IAAM,KACnB,YAAY,EAAE,IAAM,KACpB,YAAY,EAAE,IAAM,KACpB,YAAY,EAAE,IAAM,KACpB,YAAY,EAAE,IAAM,KACpB,YAAY,EAAE,IAAM,GAExB,EApBqC,gCAsBrC,MAAM,kBAAoB,OAAC,aAAgB,CACzC,OACE,YAAY,OAAS,GACrB,YAAY,CAAC,IAAM,KACnB,YAAY,CAAC,IAAM,KACnB,YAAY,CAAC,IAAM,KACnB,YAAY,CAAC,IAAM,KACnB,YAAY,CAAC,IAAM,GAEvB,EAT0B,qBAW1B,OAAO,QAAU,CACf,4BACA,6BACA,iBACF","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/api/util.js"],"sourcesContent":["const assert = require('node:assert')\nconst {\n  ResponseStatusCodeError\n} = require('../core/errors')\n\nconst { chunksDecode } = require('./readable')\nconst CHUNK_LIMIT = 128 * 1024\n\nasync function getResolveErrorBodyCallback ({ callback, body, contentType, statusCode, statusMessage, headers }) {\n  assert(body)\n\n  let chunks = []\n  let length = 0\n\n  try {\n    for await (const chunk of body) {\n      chunks.push(chunk)\n      length += chunk.length\n      if (length > CHUNK_LIMIT) {\n        chunks = []\n        length = 0\n        break\n      }\n    }\n  } catch {\n    chunks = []\n    length = 0\n    // Do nothing....\n  }\n\n  const message = `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`\n\n  if (statusCode === 204 || !contentType || !length) {\n    queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers)))\n    return\n  }\n\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  let payload\n\n  try {\n    if (isContentTypeApplicationJson(contentType)) {\n      payload = JSON.parse(chunksDecode(chunks, length))\n    } else if (isContentTypeText(contentType)) {\n      payload = chunksDecode(chunks, length)\n    }\n  } catch {\n    // process in a callback to avoid throwing in the microtask queue\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n  queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers, payload)))\n}\n\nconst isContentTypeApplicationJson = (contentType) => {\n  return (\n    contentType.length > 15 &&\n    contentType[11] === '/' &&\n    contentType[0] === 'a' &&\n    contentType[1] === 'p' &&\n    contentType[2] === 'p' &&\n    contentType[3] === 'l' &&\n    contentType[4] === 'i' &&\n    contentType[5] === 'c' &&\n    contentType[6] === 'a' &&\n    contentType[7] === 't' &&\n    contentType[8] === 'i' &&\n    contentType[9] === 'o' &&\n    contentType[10] === 'n' &&\n    contentType[12] === 'j' &&\n    contentType[13] === 's' &&\n    contentType[14] === 'o' &&\n    contentType[15] === 'n'\n  )\n}\n\nconst isContentTypeText = (contentType) => {\n  return (\n    contentType.length > 4 &&\n    contentType[4] === '/' &&\n    contentType[0] === 't' &&\n    contentType[1] === 'e' &&\n    contentType[2] === 'x' &&\n    contentType[3] === 't'\n  )\n}\n\nmodule.exports = {\n  getResolveErrorBodyCallback,\n  isContentTypeApplicationJson,\n  isContentTypeText\n}\n"]}}