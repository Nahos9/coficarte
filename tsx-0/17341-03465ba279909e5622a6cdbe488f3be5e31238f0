{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const Dispatcher=require(\"./dispatcher\");const{ClientDestroyedError,ClientClosedError,InvalidArgumentError}=require(\"../core/errors\");const{kDestroy,kClose,kClosed,kDestroyed,kDispatch,kInterceptors}=require(\"../core/symbols\");const kOnDestroyed=Symbol(\"onDestroyed\");const kOnClosed=Symbol(\"onClosed\");const kInterceptedDispatch=Symbol(\"Intercepted Dispatch\");class DispatcherBase extends Dispatcher{static{__name(this,\"DispatcherBase\")}constructor(){super();this[kDestroyed]=false;this[kOnDestroyed]=null;this[kClosed]=false;this[kOnClosed]=[]}get destroyed(){return this[kDestroyed]}get closed(){return this[kClosed]}get interceptors(){return this[kInterceptors]}set interceptors(newInterceptors){if(newInterceptors){for(let i=newInterceptors.length-1;i>=0;i--){const interceptor=this[kInterceptors][i];if(typeof interceptor!==\"function\"){throw new InvalidArgumentError(\"interceptor must be an function\")}}}this[kInterceptors]=newInterceptors}close(callback){if(callback===void 0){return new Promise((resolve,reject)=>{this.close((err,data)=>{return err?reject(err):resolve(data)})})}if(typeof callback!==\"function\"){throw new InvalidArgumentError(\"invalid callback\")}if(this[kDestroyed]){queueMicrotask(()=>callback(new ClientDestroyedError,null));return}if(this[kClosed]){if(this[kOnClosed]){this[kOnClosed].push(callback)}else{queueMicrotask(()=>callback(null,null))}return}this[kClosed]=true;this[kOnClosed].push(callback);const onClosed=__name(()=>{const callbacks=this[kOnClosed];this[kOnClosed]=null;for(let i=0;i<callbacks.length;i++){callbacks[i](null,null)}},\"onClosed\");this[kClose]().then(()=>this.destroy()).then(()=>{queueMicrotask(onClosed)})}destroy(err,callback){if(typeof err===\"function\"){callback=err;err=null}if(callback===void 0){return new Promise((resolve,reject)=>{this.destroy(err,(err2,data)=>{return err2?reject(err2):resolve(data)})})}if(typeof callback!==\"function\"){throw new InvalidArgumentError(\"invalid callback\")}if(this[kDestroyed]){if(this[kOnDestroyed]){this[kOnDestroyed].push(callback)}else{queueMicrotask(()=>callback(null,null))}return}if(!err){err=new ClientDestroyedError}this[kDestroyed]=true;this[kOnDestroyed]=this[kOnDestroyed]||[];this[kOnDestroyed].push(callback);const onDestroyed=__name(()=>{const callbacks=this[kOnDestroyed];this[kOnDestroyed]=null;for(let i=0;i<callbacks.length;i++){callbacks[i](null,null)}},\"onDestroyed\");this[kDestroy](err).then(()=>{queueMicrotask(onDestroyed)})}[kInterceptedDispatch](opts,handler){if(!this[kInterceptors]||this[kInterceptors].length===0){this[kInterceptedDispatch]=this[kDispatch];return this[kDispatch](opts,handler)}let dispatch=this[kDispatch].bind(this);for(let i=this[kInterceptors].length-1;i>=0;i--){dispatch=this[kInterceptors][i](dispatch)}this[kInterceptedDispatch]=dispatch;return dispatch(opts,handler)}dispatch(opts,handler){if(!handler||typeof handler!==\"object\"){throw new InvalidArgumentError(\"handler must be an object\")}try{if(!opts||typeof opts!==\"object\"){throw new InvalidArgumentError(\"opts must be an object.\")}if(this[kDestroyed]||this[kOnDestroyed]){throw new ClientDestroyedError}if(this[kClosed]){throw new ClientClosedError}return this[kInterceptedDispatch](opts,handler)}catch(err){if(typeof handler.onError!==\"function\"){throw new InvalidArgumentError(\"invalid onError method\")}handler.onError(err);return false}}}module.exports=DispatcherBase;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["err"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/dispatcher/dispatcher-base.js"],"sourcesContent":["'use strict'\n\nconst Dispatcher = require('./dispatcher')\nconst {\n  ClientDestroyedError,\n  ClientClosedError,\n  InvalidArgumentError\n} = require('../core/errors')\nconst { kDestroy, kClose, kClosed, kDestroyed, kDispatch, kInterceptors } = require('../core/symbols')\n\nconst kOnDestroyed = Symbol('onDestroyed')\nconst kOnClosed = Symbol('onClosed')\nconst kInterceptedDispatch = Symbol('Intercepted Dispatch')\n\nclass DispatcherBase extends Dispatcher {\n  constructor () {\n    super()\n\n    this[kDestroyed] = false\n    this[kOnDestroyed] = null\n    this[kClosed] = false\n    this[kOnClosed] = []\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  get closed () {\n    return this[kClosed]\n  }\n\n  get interceptors () {\n    return this[kInterceptors]\n  }\n\n  set interceptors (newInterceptors) {\n    if (newInterceptors) {\n      for (let i = newInterceptors.length - 1; i >= 0; i--) {\n        const interceptor = this[kInterceptors][i]\n        if (typeof interceptor !== 'function') {\n          throw new InvalidArgumentError('interceptor must be an function')\n        }\n      }\n    }\n\n    this[kInterceptors] = newInterceptors\n  }\n\n  close (callback) {\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.close((err, data) => {\n          return err ? reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      queueMicrotask(() => callback(new ClientDestroyedError(), null))\n      return\n    }\n\n    if (this[kClosed]) {\n      if (this[kOnClosed]) {\n        this[kOnClosed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    this[kClosed] = true\n    this[kOnClosed].push(callback)\n\n    const onClosed = () => {\n      const callbacks = this[kOnClosed]\n      this[kOnClosed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    // Should not error.\n    this[kClose]()\n      .then(() => this.destroy())\n      .then(() => {\n        queueMicrotask(onClosed)\n      })\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.destroy(err, (err, data) => {\n          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      if (this[kOnDestroyed]) {\n        this[kOnDestroyed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    this[kDestroyed] = true\n    this[kOnDestroyed] = this[kOnDestroyed] || []\n    this[kOnDestroyed].push(callback)\n\n    const onDestroyed = () => {\n      const callbacks = this[kOnDestroyed]\n      this[kOnDestroyed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    // Should not error.\n    this[kDestroy](err).then(() => {\n      queueMicrotask(onDestroyed)\n    })\n  }\n\n  [kInterceptedDispatch] (opts, handler) {\n    if (!this[kInterceptors] || this[kInterceptors].length === 0) {\n      this[kInterceptedDispatch] = this[kDispatch]\n      return this[kDispatch](opts, handler)\n    }\n\n    let dispatch = this[kDispatch].bind(this)\n    for (let i = this[kInterceptors].length - 1; i >= 0; i--) {\n      dispatch = this[kInterceptors][i](dispatch)\n    }\n    this[kInterceptedDispatch] = dispatch\n    return dispatch(opts, handler)\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object')\n    }\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.')\n      }\n\n      if (this[kDestroyed] || this[kOnDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      return this[kInterceptedDispatch](opts, handler)\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n\n      return false\n    }\n  }\n}\n\nmodule.exports = DispatcherBase\n"]}}