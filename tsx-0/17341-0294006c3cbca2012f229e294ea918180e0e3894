{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const assert=require(\"node:assert\");const{finished,PassThrough}=require(\"node:stream\");const{InvalidArgumentError,InvalidReturnValueError}=require(\"../core/errors\");const util=require(\"../core/util\");const{getResolveErrorBodyCallback}=require(\"./util\");const{AsyncResource}=require(\"node:async_hooks\");const{addSignal,removeSignal}=require(\"./abort-signal\");class StreamHandler extends AsyncResource{static{__name(this,\"StreamHandler\")}constructor(opts,factory,callback){if(!opts||typeof opts!==\"object\"){throw new InvalidArgumentError(\"invalid opts\")}const{signal,method,opaque,body,onInfo,responseHeaders,throwOnError}=opts;try{if(typeof callback!==\"function\"){throw new InvalidArgumentError(\"invalid callback\")}if(typeof factory!==\"function\"){throw new InvalidArgumentError(\"invalid factory\")}if(signal&&typeof signal.on!==\"function\"&&typeof signal.addEventListener!==\"function\"){throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\")}if(method===\"CONNECT\"){throw new InvalidArgumentError(\"invalid method\")}if(onInfo&&typeof onInfo!==\"function\"){throw new InvalidArgumentError(\"invalid onInfo callback\")}super(\"UNDICI_STREAM\")}catch(err){if(util.isStream(body)){util.destroy(body.on(\"error\",util.nop),err)}throw err}this.responseHeaders=responseHeaders||null;this.opaque=opaque||null;this.factory=factory;this.callback=callback;this.res=null;this.abort=null;this.context=null;this.trailers=null;this.body=body;this.onInfo=onInfo||null;this.throwOnError=throwOnError||false;if(util.isStream(body)){body.on(\"error\",err=>{this.onError(err)})}addSignal(this,signal)}onConnect(abort,context){if(this.reason){abort(this.reason);return}assert(this.callback);this.abort=abort;this.context=context}onHeaders(statusCode,rawHeaders,resume,statusMessage){const{factory,opaque,context,callback,responseHeaders}=this;const headers=responseHeaders===\"raw\"?util.parseRawHeaders(rawHeaders):util.parseHeaders(rawHeaders);if(statusCode<200){if(this.onInfo){this.onInfo({statusCode,headers})}return}this.factory=null;let res;if(this.throwOnError&&statusCode>=400){const parsedHeaders=responseHeaders===\"raw\"?util.parseHeaders(rawHeaders):headers;const contentType=parsedHeaders[\"content-type\"];res=new PassThrough;this.callback=null;this.runInAsyncScope(getResolveErrorBodyCallback,null,{callback,body:res,contentType,statusCode,statusMessage,headers})}else{if(factory===null){return}res=this.runInAsyncScope(factory,null,{statusCode,headers,opaque,context});if(!res||typeof res.write!==\"function\"||typeof res.end!==\"function\"||typeof res.on!==\"function\"){throw new InvalidReturnValueError(\"expected Writable\")}finished(res,{readable:false},err=>{const{callback:callback2,res:res2,opaque:opaque2,trailers,abort}=this;this.res=null;if(err||!res2.readable){util.destroy(res2,err)}this.callback=null;this.runInAsyncScope(callback2,null,err||null,{opaque:opaque2,trailers});if(err){abort()}})}res.on(\"drain\",resume);this.res=res;const needDrain=res.writableNeedDrain!==void 0?res.writableNeedDrain:res._writableState?.needDrain;return needDrain!==true}onData(chunk){const{res}=this;return res?res.write(chunk):true}onComplete(trailers){const{res}=this;removeSignal(this);if(!res){return}this.trailers=util.parseHeaders(trailers);res.end()}onError(err){const{res,callback,opaque,body}=this;removeSignal(this);this.factory=null;if(res){this.res=null;util.destroy(res,err)}else if(callback){this.callback=null;queueMicrotask(()=>{this.runInAsyncScope(callback,null,err,{opaque})})}if(body){this.body=null;util.destroy(body,err)}}}function stream(opts,factory,callback){if(callback===void 0){return new Promise((resolve,reject)=>{stream.call(this,opts,factory,(err,data)=>{return err?reject(err):resolve(data)})})}try{this.dispatch(opts,new StreamHandler(opts,factory,callback))}catch(err){if(typeof callback!==\"function\"){throw err}const opaque=opts?.opaque;queueMicrotask(()=>callback(err,{opaque}))}}__name(stream,\"stream\");module.exports=stream;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAEA,MAAM,OAAS,QAAQ,aAAa,EACpC,KAAM,CAAE,SAAU,WAAY,EAAI,QAAQ,aAAa,EACvD,KAAM,CAAE,qBAAsB,uBAAwB,EAAI,QAAQ,gBAAgB,EAClF,MAAM,KAAO,QAAQ,cAAc,EACnC,KAAM,CAAE,2BAA4B,EAAI,QAAQ,QAAQ,EACxD,KAAM,CAAE,aAAc,EAAI,QAAQ,kBAAkB,EACpD,KAAM,CAAE,UAAW,YAAa,EAAI,QAAQ,gBAAgB,EAE5D,MAAM,sBAAsB,aAAc,CAV1C,MAU0C,8BACxC,YAAa,KAAM,QAAS,SAAU,CACpC,GAAI,CAAC,MAAQ,OAAO,OAAS,SAAU,CACrC,MAAM,IAAI,qBAAqB,cAAc,CAC/C,CAEA,KAAM,CAAE,OAAQ,OAAQ,OAAQ,KAAM,OAAQ,gBAAiB,YAAa,EAAI,KAEhF,GAAI,CACF,GAAI,OAAO,WAAa,WAAY,CAClC,MAAM,IAAI,qBAAqB,kBAAkB,CACnD,CAEA,GAAI,OAAO,UAAY,WAAY,CACjC,MAAM,IAAI,qBAAqB,iBAAiB,CAClD,CAEA,GAAI,QAAU,OAAO,OAAO,KAAO,YAAc,OAAO,OAAO,mBAAqB,WAAY,CAC9F,MAAM,IAAI,qBAAqB,+CAA+C,CAChF,CAEA,GAAI,SAAW,UAAW,CACxB,MAAM,IAAI,qBAAqB,gBAAgB,CACjD,CAEA,GAAI,QAAU,OAAO,SAAW,WAAY,CAC1C,MAAM,IAAI,qBAAqB,yBAAyB,CAC1D,CAEA,MAAM,eAAe,CACvB,OAAS,IAAK,CACZ,GAAI,KAAK,SAAS,IAAI,EAAG,CACvB,KAAK,QAAQ,KAAK,GAAG,QAAS,KAAK,GAAG,EAAG,GAAG,CAC9C,CACA,MAAM,GACR,CAEA,KAAK,gBAAkB,iBAAmB,KAC1C,KAAK,OAAS,QAAU,KACxB,KAAK,QAAU,QACf,KAAK,SAAW,SAChB,KAAK,IAAM,KACX,KAAK,MAAQ,KACb,KAAK,QAAU,KACf,KAAK,SAAW,KAChB,KAAK,KAAO,KACZ,KAAK,OAAS,QAAU,KACxB,KAAK,aAAe,cAAgB,MAEpC,GAAI,KAAK,SAAS,IAAI,EAAG,CACvB,KAAK,GAAG,QAAU,KAAQ,CACxB,KAAK,QAAQ,GAAG,CAClB,CAAC,CACH,CAEA,UAAU,KAAM,MAAM,CACxB,CAEA,UAAW,MAAO,QAAS,CACzB,GAAI,KAAK,OAAQ,CACf,MAAM,KAAK,MAAM,EACjB,MACF,CAEA,OAAO,KAAK,QAAQ,EAEpB,KAAK,MAAQ,MACb,KAAK,QAAU,OACjB,CAEA,UAAW,WAAY,WAAY,OAAQ,cAAe,CACxD,KAAM,CAAE,QAAS,OAAQ,QAAS,SAAU,eAAgB,EAAI,KAEhE,MAAM,QAAU,kBAAoB,MAAQ,KAAK,gBAAgB,UAAU,EAAI,KAAK,aAAa,UAAU,EAE3G,GAAI,WAAa,IAAK,CACpB,GAAI,KAAK,OAAQ,CACf,KAAK,OAAO,CAAE,WAAY,OAAQ,CAAC,CACrC,CACA,MACF,CAEA,KAAK,QAAU,KAEf,IAAI,IAEJ,GAAI,KAAK,cAAgB,YAAc,IAAK,CAC1C,MAAM,cAAgB,kBAAoB,MAAQ,KAAK,aAAa,UAAU,EAAI,QAClF,MAAM,YAAc,cAAc,cAAc,EAChD,IAAM,IAAI,YAEV,KAAK,SAAW,KAChB,KAAK,gBAAgB,4BAA6B,KAChD,CAAE,SAAU,KAAM,IAAK,YAAa,WAAY,cAAe,OAAQ,CACzE,CACF,KAAO,CACL,GAAI,UAAY,KAAM,CACpB,MACF,CAEA,IAAM,KAAK,gBAAgB,QAAS,KAAM,CACxC,WACA,QACA,OACA,OACF,CAAC,EAED,GACE,CAAC,KACD,OAAO,IAAI,QAAU,YACrB,OAAO,IAAI,MAAQ,YACnB,OAAO,IAAI,KAAO,WAClB,CACA,MAAM,IAAI,wBAAwB,mBAAmB,CACvD,CAGA,SAAS,IAAK,CAAE,SAAU,KAAM,EAAI,KAAQ,CAC1C,KAAM,CAAE,SAAAA,UAAU,IAAAC,KAAK,OAAAC,QAAQ,SAAU,KAAM,EAAI,KAEnD,KAAK,IAAM,KACX,GAAI,KAAO,CAACD,KAAI,SAAU,CACxB,KAAK,QAAQA,KAAK,GAAG,CACvB,CAEA,KAAK,SAAW,KAChB,KAAK,gBAAgBD,UAAU,KAAM,KAAO,KAAM,CAAE,OAAAE,QAAQ,QAAS,CAAC,EAEtE,GAAI,IAAK,CACP,MAAM,CACR,CACF,CAAC,CACH,CAEA,IAAI,GAAG,QAAS,MAAM,EAEtB,KAAK,IAAM,IAEX,MAAM,UAAY,IAAI,oBAAsB,OACxC,IAAI,kBACJ,IAAI,gBAAgB,UAExB,OAAO,YAAc,IACvB,CAEA,OAAQ,MAAO,CACb,KAAM,CAAE,GAAI,EAAI,KAEhB,OAAO,IAAM,IAAI,MAAM,KAAK,EAAI,IAClC,CAEA,WAAY,SAAU,CACpB,KAAM,CAAE,GAAI,EAAI,KAEhB,aAAa,IAAI,EAEjB,GAAI,CAAC,IAAK,CACR,MACF,CAEA,KAAK,SAAW,KAAK,aAAa,QAAQ,EAE1C,IAAI,IAAI,CACV,CAEA,QAAS,IAAK,CACZ,KAAM,CAAE,IAAK,SAAU,OAAQ,IAAK,EAAI,KAExC,aAAa,IAAI,EAEjB,KAAK,QAAU,KAEf,GAAI,IAAK,CACP,KAAK,IAAM,KACX,KAAK,QAAQ,IAAK,GAAG,CACvB,SAAW,SAAU,CACnB,KAAK,SAAW,KAChB,eAAe,IAAM,CACnB,KAAK,gBAAgB,SAAU,KAAM,IAAK,CAAE,MAAO,CAAC,CACtD,CAAC,CACH,CAEA,GAAI,KAAM,CACR,KAAK,KAAO,KACZ,KAAK,QAAQ,KAAM,GAAG,CACxB,CACF,CACF,CAEA,SAAS,OAAQ,KAAM,QAAS,SAAU,CACxC,GAAI,WAAa,OAAW,CAC1B,OAAO,IAAI,QAAQ,CAAC,QAAS,SAAW,CACtC,OAAO,KAAK,KAAM,KAAM,QAAS,CAAC,IAAK,OAAS,CAC9C,OAAO,IAAM,OAAO,GAAG,EAAI,QAAQ,IAAI,CACzC,CAAC,CACH,CAAC,CACH,CAEA,GAAI,CACF,KAAK,SAAS,KAAM,IAAI,cAAc,KAAM,QAAS,QAAQ,CAAC,CAChE,OAAS,IAAK,CACZ,GAAI,OAAO,WAAa,WAAY,CAClC,MAAM,GACR,CACA,MAAM,OAAS,MAAM,OACrB,eAAe,IAAM,SAAS,IAAK,CAAE,MAAO,CAAC,CAAC,CAChD,CACF,CAlBS,wBAoBT,OAAO,QAAU","names":["callback","res","opaque"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/api/api-stream.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { finished, PassThrough } = require('node:stream')\nconst { InvalidArgumentError, InvalidReturnValueError } = require('../core/errors')\nconst util = require('../core/util')\nconst { getResolveErrorBodyCallback } = require('./util')\nconst { AsyncResource } = require('node:async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.context = null\n    this.trailers = null\n    this.body = body\n    this.onInfo = onInfo || null\n    this.throwOnError = throwOnError || false\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { factory, opaque, context, callback, responseHeaders } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.factory = null\n\n    let res\n\n    if (this.throwOnError && statusCode >= 400) {\n      const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers\n      const contentType = parsedHeaders['content-type']\n      res = new PassThrough()\n\n      this.callback = null\n      this.runInAsyncScope(getResolveErrorBodyCallback, null,\n        { callback, body: res, contentType, statusCode, statusMessage, headers }\n      )\n    } else {\n      if (factory === null) {\n        return\n      }\n\n      res = this.runInAsyncScope(factory, null, {\n        statusCode,\n        headers,\n        opaque,\n        context\n      })\n\n      if (\n        !res ||\n        typeof res.write !== 'function' ||\n        typeof res.end !== 'function' ||\n        typeof res.on !== 'function'\n      ) {\n        throw new InvalidReturnValueError('expected Writable')\n      }\n\n      // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n      finished(res, { readable: false }, (err) => {\n        const { callback, res, opaque, trailers, abort } = this\n\n        this.res = null\n        if (err || !res.readable) {\n          util.destroy(res, err)\n        }\n\n        this.callback = null\n        this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n        if (err) {\n          abort()\n        }\n      })\n    }\n\n    res.on('drain', resume)\n\n    this.res = res\n\n    const needDrain = res.writableNeedDrain !== undefined\n      ? res.writableNeedDrain\n      : res._writableState?.needDrain\n\n    return needDrain !== true\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res ? res.write(chunk) : true\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    if (!res) {\n      return\n    }\n\n    this.trailers = util.parseHeaders(trailers)\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = stream\n"]}}