{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{maxUnsigned16Bit}=require(\"./constants\");const BUFFER_SIZE=16386;let crypto;let buffer=null;let bufIdx=BUFFER_SIZE;try{crypto=require(\"node:crypto\")}catch{crypto={randomFillSync:__name(function randomFillSync(buffer2,_offset,_size){for(let i=0;i<buffer2.length;++i){buffer2[i]=Math.random()*255|0}return buffer2},\"randomFillSync\")}}function generateMask(){if(bufIdx===BUFFER_SIZE){bufIdx=0;crypto.randomFillSync(buffer??=Buffer.allocUnsafe(BUFFER_SIZE),0,BUFFER_SIZE)}return[buffer[bufIdx++],buffer[bufIdx++],buffer[bufIdx++],buffer[bufIdx++]]}__name(generateMask,\"generateMask\");class WebsocketFrameSend{static{__name(this,\"WebsocketFrameSend\")}constructor(data){this.frameData=data}createFrame(opcode){const frameData=this.frameData;const maskKey=generateMask();const bodyLength=frameData?.byteLength??0;let payloadLength=bodyLength;let offset=6;if(bodyLength>maxUnsigned16Bit){offset+=8;payloadLength=127}else if(bodyLength>125){offset+=2;payloadLength=126}const buffer2=Buffer.allocUnsafe(bodyLength+offset);buffer2[0]=buffer2[1]=0;buffer2[0]|=128;buffer2[0]=(buffer2[0]&240)+opcode;/*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */buffer2[offset-4]=maskKey[0];buffer2[offset-3]=maskKey[1];buffer2[offset-2]=maskKey[2];buffer2[offset-1]=maskKey[3];buffer2[1]=payloadLength;if(payloadLength===126){buffer2.writeUInt16BE(bodyLength,2)}else if(payloadLength===127){buffer2[2]=buffer2[3]=0;buffer2.writeUIntBE(bodyLength,4,6)}buffer2[1]|=128;for(let i=0;i<bodyLength;++i){buffer2[offset+i]=frameData[i]^maskKey[i&3]}return buffer2}}module.exports={WebsocketFrameSend};\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAEA,KAAM,CAAE,gBAAiB,EAAI,QAAQ,aAAa,EAElD,MAAM,YAAc,MAGpB,IAAI,OACJ,IAAI,OAAS,KACb,IAAI,OAAS,YAEb,GAAI,CACF,OAAS,QAAQ,aAAa,CAEhC,MAAQ,CACN,OAAS,CAEP,eAAgB,gBAAS,eAAgBA,QAAQ,QAAS,MAAO,CAC/D,QAAS,EAAI,EAAG,EAAIA,QAAO,OAAQ,EAAE,EAAG,CACtCA,QAAO,CAAC,EAAI,KAAK,OAAO,EAAI,IAAM,CACpC,CACA,OAAOA,OACT,EALgB,iBAMlB,CACF,CAEA,SAAS,cAAgB,CACvB,GAAI,SAAW,YAAa,CAC1B,OAAS,EACT,OAAO,eAAgB,SAAW,OAAO,YAAY,WAAW,EAAI,EAAG,WAAW,CACpF,CACA,MAAO,CAAC,OAAO,QAAQ,EAAG,OAAO,QAAQ,EAAG,OAAO,QAAQ,EAAG,OAAO,QAAQ,CAAC,CAChF,CANS,oCAQT,MAAM,kBAAmB,CAlCzB,MAkCyB,mCAIvB,YAAa,KAAM,CACjB,KAAK,UAAY,IACnB,CAEA,YAAa,OAAQ,CACnB,MAAM,UAAY,KAAK,UACvB,MAAM,QAAU,aAAa,EAC7B,MAAM,WAAa,WAAW,YAAc,EAG5C,IAAI,cAAgB,WACpB,IAAI,OAAS,EAEb,GAAI,WAAa,iBAAkB,CACjC,QAAU,EACV,cAAgB,GAClB,SAAW,WAAa,IAAK,CAC3B,QAAU,EACV,cAAgB,GAClB,CAEA,MAAMA,QAAS,OAAO,YAAY,WAAa,MAAM,EAGrDA,QAAO,CAAC,EAAIA,QAAO,CAAC,EAAI,EACxBA,QAAO,CAAC,GAAK,IACbA,QAAO,CAAC,GAAKA,QAAO,CAAC,EAAI,KAAQ,OAEjC,+DACAA,QAAO,OAAS,CAAC,EAAI,QAAQ,CAAC,EAC9BA,QAAO,OAAS,CAAC,EAAI,QAAQ,CAAC,EAC9BA,QAAO,OAAS,CAAC,EAAI,QAAQ,CAAC,EAC9BA,QAAO,OAAS,CAAC,EAAI,QAAQ,CAAC,EAE9BA,QAAO,CAAC,EAAI,cAEZ,GAAI,gBAAkB,IAAK,CACzBA,QAAO,cAAc,WAAY,CAAC,CACpC,SAAW,gBAAkB,IAAK,CAEhCA,QAAO,CAAC,EAAIA,QAAO,CAAC,EAAI,EACxBA,QAAO,YAAY,WAAY,EAAG,CAAC,CACrC,CAEAA,QAAO,CAAC,GAAK,IAGb,QAAS,EAAI,EAAG,EAAI,WAAY,EAAE,EAAG,CACnCA,QAAO,OAAS,CAAC,EAAI,UAAU,CAAC,EAAI,QAAQ,EAAI,CAAC,CACnD,CAEA,OAAOA,OACT,CACF,CAEA,OAAO,QAAU,CACf,kBACF","names":["buffer"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/websocket/frame.js"],"sourcesContent":["'use strict'\n\nconst { maxUnsigned16Bit } = require('./constants')\n\nconst BUFFER_SIZE = 16386\n\n/** @type {import('crypto')} */\nlet crypto\nlet buffer = null\nlet bufIdx = BUFFER_SIZE\n\ntry {\n  crypto = require('node:crypto')\n/* c8 ignore next 3 */\n} catch {\n  crypto = {\n    // not full compatibility, but minimum.\n    randomFillSync: function randomFillSync (buffer, _offset, _size) {\n      for (let i = 0; i < buffer.length; ++i) {\n        buffer[i] = Math.random() * 255 | 0\n      }\n      return buffer\n    }\n  }\n}\n\nfunction generateMask () {\n  if (bufIdx === BUFFER_SIZE) {\n    bufIdx = 0\n    crypto.randomFillSync((buffer ??= Buffer.allocUnsafe(BUFFER_SIZE)), 0, BUFFER_SIZE)\n  }\n  return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]]\n}\n\nclass WebsocketFrameSend {\n  /**\n   * @param {Buffer|undefined} data\n   */\n  constructor (data) {\n    this.frameData = data\n  }\n\n  createFrame (opcode) {\n    const frameData = this.frameData\n    const maskKey = generateMask()\n    const bodyLength = frameData?.byteLength ?? 0\n\n    /** @type {number} */\n    let payloadLength = bodyLength // 0-125\n    let offset = 6\n\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8 // payload length is next 8 bytes\n      payloadLength = 127\n    } else if (bodyLength > 125) {\n      offset += 2 // payload length is next 2 bytes\n      payloadLength = 126\n    }\n\n    const buffer = Buffer.allocUnsafe(bodyLength + offset)\n\n    // Clear first 2 bytes, everything else is overwritten\n    buffer[0] = buffer[1] = 0\n    buffer[0] |= 0x80 // FIN\n    buffer[0] = (buffer[0] & 0xF0) + opcode // opcode\n\n    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */\n    buffer[offset - 4] = maskKey[0]\n    buffer[offset - 3] = maskKey[1]\n    buffer[offset - 2] = maskKey[2]\n    buffer[offset - 1] = maskKey[3]\n\n    buffer[1] = payloadLength\n\n    if (payloadLength === 126) {\n      buffer.writeUInt16BE(bodyLength, 2)\n    } else if (payloadLength === 127) {\n      // Clear extended payload length\n      buffer[2] = buffer[3] = 0\n      buffer.writeUIntBE(bodyLength, 4, 6)\n    }\n\n    buffer[1] |= 0x80 // MASK\n\n    // mask body\n    for (let i = 0; i < bodyLength; ++i) {\n      buffer[offset + i] = frameData[i] ^ maskKey[i & 3]\n    }\n\n    return buffer\n  }\n}\n\nmodule.exports = {\n  WebsocketFrameSend\n}\n"]}}