{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const kSize=2048;const kMask=kSize-1;class FixedCircularBuffer{static{__name(this,\"FixedCircularBuffer\")}constructor(){this.bottom=0;this.top=0;this.list=new Array(kSize);this.next=null}isEmpty(){return this.top===this.bottom}isFull(){return(this.top+1&kMask)===this.bottom}push(data){this.list[this.top]=data;this.top=this.top+1&kMask}shift(){const nextItem=this.list[this.bottom];if(nextItem===void 0)return null;this.list[this.bottom]=void 0;this.bottom=this.bottom+1&kMask;return nextItem}}module.exports=class FixedQueue{static{__name(this,\"FixedQueue\")}constructor(){this.head=this.tail=new FixedCircularBuffer}isEmpty(){return this.head.isEmpty()}push(data){if(this.head.isFull()){this.head=this.head.next=new FixedCircularBuffer}this.head.push(data)}shift(){const tail=this.tail;const next=tail.shift();if(tail.isEmpty()&&tail.next!==null){this.tail=tail.next}return next}};\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAOA,MAAM,MAAQ,KACd,MAAM,MAAQ,MAAQ,EAkDtB,MAAM,mBAAoB,CA1D1B,MA0D0B,oCACxB,aAAc,CACZ,KAAK,OAAS,EACd,KAAK,IAAM,EACX,KAAK,KAAO,IAAI,MAAM,KAAK,EAC3B,KAAK,KAAO,IACd,CAEA,SAAU,CACR,OAAO,KAAK,MAAQ,KAAK,MAC3B,CAEA,QAAS,CACP,OAAS,KAAK,IAAM,EAAK,SAAW,KAAK,MAC3C,CAEA,KAAK,KAAM,CACT,KAAK,KAAK,KAAK,GAAG,EAAI,KACtB,KAAK,IAAO,KAAK,IAAM,EAAK,KAC9B,CAEA,OAAQ,CACN,MAAM,SAAW,KAAK,KAAK,KAAK,MAAM,EACtC,GAAI,WAAa,OACf,OAAO,KACT,KAAK,KAAK,KAAK,MAAM,EAAI,OACzB,KAAK,OAAU,KAAK,OAAS,EAAK,MAClC,OAAO,QACT,CACF,CAEA,OAAO,QAAU,MAAM,UAAW,CAzFlC,MAyFkC,2BAChC,aAAc,CACZ,KAAK,KAAO,KAAK,KAAO,IAAI,mBAC9B,CAEA,SAAU,CACR,OAAO,KAAK,KAAK,QAAQ,CAC3B,CAEA,KAAK,KAAM,CACT,GAAI,KAAK,KAAK,OAAO,EAAG,CAGtB,KAAK,KAAO,KAAK,KAAK,KAAO,IAAI,mBACnC,CACA,KAAK,KAAK,KAAK,IAAI,CACrB,CAEA,OAAQ,CACN,MAAM,KAAO,KAAK,KAClB,MAAM,KAAO,KAAK,MAAM,EACxB,GAAI,KAAK,QAAQ,GAAK,KAAK,OAAS,KAAM,CAExC,KAAK,KAAO,KAAK,IACnB,CACA,OAAO,IACT,CACF","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/dispatcher/fixed-queue.js"],"sourcesContent":["/* eslint-disable */\n\n'use strict'\n\n// Extracted from node/lib/internal/fixed_queue.js\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n"]}}