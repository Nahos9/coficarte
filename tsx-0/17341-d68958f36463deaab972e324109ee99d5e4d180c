{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{Writable}=require(\"node:stream\");const assert=require(\"node:assert\");const{parserStates,opcodes,states,emptyBuffer,sentCloseFrameState}=require(\"./constants\");const{kReadyState,kSentClose,kResponse,kReceivedClose}=require(\"./symbols\");const{channels}=require(\"../../core/diagnostics\");const{isValidStatusCode,isValidOpcode,failWebsocketConnection,websocketMessageReceived,utf8Decode,isControlFrame,isTextBinaryFrame,isContinuationFrame}=require(\"./util\");const{WebsocketFrameSend}=require(\"./frame\");const{closeWebSocketConnection}=require(\"./connection\");const{PerMessageDeflate}=require(\"./permessage-deflate\");class ByteParser extends Writable{static{__name(this,\"ByteParser\")}#buffers=[];#byteOffset=0;#loop=false;#state=parserStates.INFO;#info={};#fragments=[];#extensions;constructor(ws,extensions){super();this.ws=ws;this.#extensions=extensions==null?new Map:extensions;if(this.#extensions.has(\"permessage-deflate\")){this.#extensions.set(\"permessage-deflate\",new PerMessageDeflate(extensions))}}_write(chunk,_,callback){this.#buffers.push(chunk);this.#byteOffset+=chunk.length;this.#loop=true;this.run(callback)}run(callback){while(this.#loop){if(this.#state===parserStates.INFO){if(this.#byteOffset<2){return callback()}const buffer=this.consume(2);const fin=(buffer[0]&128)!==0;const opcode=buffer[0]&15;const masked=(buffer[1]&128)===128;const fragmented=!fin&&opcode!==opcodes.CONTINUATION;const payloadLength=buffer[1]&127;const rsv1=buffer[0]&64;const rsv2=buffer[0]&32;const rsv3=buffer[0]&16;if(!isValidOpcode(opcode)){failWebsocketConnection(this.ws,\"Invalid opcode received\");return callback()}if(masked){failWebsocketConnection(this.ws,\"Frame cannot be masked\");return callback()}if(rsv1!==0&&!this.#extensions.has(\"permessage-deflate\")){failWebsocketConnection(this.ws,\"Expected RSV1 to be clear.\");return}if(rsv2!==0||rsv3!==0){failWebsocketConnection(this.ws,\"RSV1, RSV2, RSV3 must be clear\");return}if(fragmented&&!isTextBinaryFrame(opcode)){failWebsocketConnection(this.ws,\"Invalid frame type was fragmented.\");return}if(isTextBinaryFrame(opcode)&&this.#fragments.length>0){failWebsocketConnection(this.ws,\"Expected continuation frame\");return}if(this.#info.fragmented&&fragmented){failWebsocketConnection(this.ws,\"Fragmented frame exceeded 125 bytes.\");return}if((payloadLength>125||fragmented)&&isControlFrame(opcode)){failWebsocketConnection(this.ws,\"Control frame either too large or fragmented\");return}if(isContinuationFrame(opcode)&&this.#fragments.length===0&&!this.#info.compressed){failWebsocketConnection(this.ws,\"Unexpected continuation frame\");return}if(payloadLength<=125){this.#info.payloadLength=payloadLength;this.#state=parserStates.READ_DATA}else if(payloadLength===126){this.#state=parserStates.PAYLOADLENGTH_16}else if(payloadLength===127){this.#state=parserStates.PAYLOADLENGTH_64}if(isTextBinaryFrame(opcode)){this.#info.binaryType=opcode;this.#info.compressed=rsv1!==0}this.#info.opcode=opcode;this.#info.masked=masked;this.#info.fin=fin;this.#info.fragmented=fragmented}else if(this.#state===parserStates.PAYLOADLENGTH_16){if(this.#byteOffset<2){return callback()}const buffer=this.consume(2);this.#info.payloadLength=buffer.readUInt16BE(0);this.#state=parserStates.READ_DATA}else if(this.#state===parserStates.PAYLOADLENGTH_64){if(this.#byteOffset<8){return callback()}const buffer=this.consume(8);const upper=buffer.readUInt32BE(0);if(upper>2**31-1){failWebsocketConnection(this.ws,\"Received payload length > 2^31 bytes.\");return}const lower=buffer.readUInt32BE(4);this.#info.payloadLength=(upper<<8)+lower;this.#state=parserStates.READ_DATA}else if(this.#state===parserStates.READ_DATA){if(this.#byteOffset<this.#info.payloadLength){return callback()}const body=this.consume(this.#info.payloadLength);if(isControlFrame(this.#info.opcode)){this.#loop=this.parseControlFrame(body);this.#state=parserStates.INFO}else{if(!this.#info.compressed){this.#fragments.push(body);if(!this.#info.fragmented&&this.#info.fin){const fullMessage=Buffer.concat(this.#fragments);websocketMessageReceived(this.ws,this.#info.binaryType,fullMessage);this.#fragments.length=0}this.#state=parserStates.INFO}else{this.#extensions.get(\"permessage-deflate\").decompress(body,this.#info.fin,(error,data)=>{if(error){closeWebSocketConnection(this.ws,1007,error.message,error.message.length);return}this.#fragments.push(data);if(!this.#info.fin){this.#state=parserStates.INFO;this.#loop=true;this.run(callback);return}websocketMessageReceived(this.ws,this.#info.binaryType,Buffer.concat(this.#fragments));this.#loop=true;this.#state=parserStates.INFO;this.#fragments.length=0;this.run(callback)});this.#loop=false;break}}}}}consume(n){if(n>this.#byteOffset){throw new Error(\"Called consume() before buffers satiated.\")}else if(n===0){return emptyBuffer}if(this.#buffers[0].length===n){this.#byteOffset-=this.#buffers[0].length;return this.#buffers.shift()}const buffer=Buffer.allocUnsafe(n);let offset=0;while(offset!==n){const next=this.#buffers[0];const{length}=next;if(length+offset===n){buffer.set(this.#buffers.shift(),offset);break}else if(length+offset>n){buffer.set(next.subarray(0,n-offset),offset);this.#buffers[0]=next.subarray(n-offset);break}else{buffer.set(this.#buffers.shift(),offset);offset+=next.length}}this.#byteOffset-=n;return buffer}parseCloseBody(data){assert(data.length!==1);let code;if(data.length>=2){code=data.readUInt16BE(0)}if(code!==void 0&&!isValidStatusCode(code)){return{code:1002,reason:\"Invalid status code\",error:true}}let reason=data.subarray(2);if(reason[0]===239&&reason[1]===187&&reason[2]===191){reason=reason.subarray(3)}try{reason=utf8Decode(reason)}catch{return{code:1007,reason:\"Invalid UTF-8\",error:true}}return{code,reason,error:false}}parseControlFrame(body){const{opcode,payloadLength}=this.#info;if(opcode===opcodes.CLOSE){if(payloadLength===1){failWebsocketConnection(this.ws,\"Received close frame with a 1-byte body.\");return false}this.#info.closeInfo=this.parseCloseBody(body);if(this.#info.closeInfo.error){const{code,reason}=this.#info.closeInfo;closeWebSocketConnection(this.ws,code,reason,reason.length);failWebsocketConnection(this.ws,reason);return false}if(this.ws[kSentClose]!==sentCloseFrameState.SENT){let body2=emptyBuffer;if(this.#info.closeInfo.code){body2=Buffer.allocUnsafe(2);body2.writeUInt16BE(this.#info.closeInfo.code,0)}const closeFrame=new WebsocketFrameSend(body2);this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE),err=>{if(!err){this.ws[kSentClose]=sentCloseFrameState.SENT}})}this.ws[kReadyState]=states.CLOSING;this.ws[kReceivedClose]=true;return false}else if(opcode===opcodes.PING){if(!this.ws[kReceivedClose]){const frame=new WebsocketFrameSend(body);this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));if(channels.ping.hasSubscribers){channels.ping.publish({payload:body})}}}else if(opcode===opcodes.PONG){if(channels.pong.hasSubscribers){channels.pong.publish({payload:body})}}return true}get closingInfo(){return this.#info.closeInfo}}module.exports={ByteParser};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["body"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/websocket/receiver.js"],"sourcesContent":["'use strict'\n\nconst { Writable } = require('node:stream')\nconst assert = require('node:assert')\nconst { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = require('./constants')\nconst { kReadyState, kSentClose, kResponse, kReceivedClose } = require('./symbols')\nconst { channels } = require('../../core/diagnostics')\nconst {\n  isValidStatusCode,\n  isValidOpcode,\n  failWebsocketConnection,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isTextBinaryFrame,\n  isContinuationFrame\n} = require('./util')\nconst { WebsocketFrameSend } = require('./frame')\nconst { closeWebSocketConnection } = require('./connection')\nconst { PerMessageDeflate } = require('./permessage-deflate')\n\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\n\nclass ByteParser extends Writable {\n  #buffers = []\n  #byteOffset = 0\n  #loop = false\n\n  #state = parserStates.INFO\n\n  #info = {}\n  #fragments = []\n\n  /** @type {Map<string, PerMessageDeflate>} */\n  #extensions\n\n  constructor (ws, extensions) {\n    super()\n\n    this.ws = ws\n    this.#extensions = extensions == null ? new Map() : extensions\n\n    if (this.#extensions.has('permessage-deflate')) {\n      this.#extensions.set('permessage-deflate', new PerMessageDeflate(extensions))\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */\n  _write (chunk, _, callback) {\n    this.#buffers.push(chunk)\n    this.#byteOffset += chunk.length\n    this.#loop = true\n\n    this.run(callback)\n  }\n\n  /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */\n  run (callback) {\n    while (this.#loop) {\n      if (this.#state === parserStates.INFO) {\n        // If there aren't enough bytes to parse the payload length, etc.\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n        const fin = (buffer[0] & 0x80) !== 0\n        const opcode = buffer[0] & 0x0F\n        const masked = (buffer[1] & 0x80) === 0x80\n\n        const fragmented = !fin && opcode !== opcodes.CONTINUATION\n        const payloadLength = buffer[1] & 0x7F\n\n        const rsv1 = buffer[0] & 0x40\n        const rsv2 = buffer[0] & 0x20\n        const rsv3 = buffer[0] & 0x10\n\n        if (!isValidOpcode(opcode)) {\n          failWebsocketConnection(this.ws, 'Invalid opcode received')\n          return callback()\n        }\n\n        if (masked) {\n          failWebsocketConnection(this.ws, 'Frame cannot be masked')\n          return callback()\n        }\n\n        // MUST be 0 unless an extension is negotiated that defines meanings\n        // for non-zero values.  If a nonzero value is received and none of\n        // the negotiated extensions defines the meaning of such a nonzero\n        // value, the receiving endpoint MUST _Fail the WebSocket\n        // Connection_.\n        // This document allocates the RSV1 bit of the WebSocket header for\n        // PMCEs and calls the bit the \"Per-Message Compressed\" bit.  On a\n        // WebSocket connection where a PMCE is in use, this bit indicates\n        // whether a message is compressed or not.\n        if (rsv1 !== 0 && !this.#extensions.has('permessage-deflate')) {\n          failWebsocketConnection(this.ws, 'Expected RSV1 to be clear.')\n          return\n        }\n\n        if (rsv2 !== 0 || rsv3 !== 0) {\n          failWebsocketConnection(this.ws, 'RSV1, RSV2, RSV3 must be clear')\n          return\n        }\n\n        if (fragmented && !isTextBinaryFrame(opcode)) {\n          // Only text and binary frames can be fragmented\n          failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.')\n          return\n        }\n\n        // If we are already parsing a text/binary frame and do not receive either\n        // a continuation frame or close frame, fail the connection.\n        if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {\n          failWebsocketConnection(this.ws, 'Expected continuation frame')\n          return\n        }\n\n        if (this.#info.fragmented && fragmented) {\n          // A fragmented frame can't be fragmented itself\n          failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.')\n          return\n        }\n\n        // \"All control frames MUST have a payload length of 125 bytes or less\n        // and MUST NOT be fragmented.\"\n        if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {\n          failWebsocketConnection(this.ws, 'Control frame either too large or fragmented')\n          return\n        }\n\n        if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {\n          failWebsocketConnection(this.ws, 'Unexpected continuation frame')\n          return\n        }\n\n        if (payloadLength <= 125) {\n          this.#info.payloadLength = payloadLength\n          this.#state = parserStates.READ_DATA\n        } else if (payloadLength === 126) {\n          this.#state = parserStates.PAYLOADLENGTH_16\n        } else if (payloadLength === 127) {\n          this.#state = parserStates.PAYLOADLENGTH_64\n        }\n\n        if (isTextBinaryFrame(opcode)) {\n          this.#info.binaryType = opcode\n          this.#info.compressed = rsv1 !== 0\n        }\n\n        this.#info.opcode = opcode\n        this.#info.masked = masked\n        this.#info.fin = fin\n        this.#info.fragmented = fragmented\n      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n\n        this.#info.payloadLength = buffer.readUInt16BE(0)\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n        if (this.#byteOffset < 8) {\n          return callback()\n        }\n\n        const buffer = this.consume(8)\n        const upper = buffer.readUInt32BE(0)\n\n        // 2^31 is the maximum bytes an arraybuffer can contain\n        // on 32-bit systems. Although, on 64-bit systems, this is\n        // 2^53-1 bytes.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n        if (upper > 2 ** 31 - 1) {\n          failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.')\n          return\n        }\n\n        const lower = buffer.readUInt32BE(4)\n\n        this.#info.payloadLength = (upper << 8) + lower\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.READ_DATA) {\n        if (this.#byteOffset < this.#info.payloadLength) {\n          return callback()\n        }\n\n        const body = this.consume(this.#info.payloadLength)\n\n        if (isControlFrame(this.#info.opcode)) {\n          this.#loop = this.parseControlFrame(body)\n          this.#state = parserStates.INFO\n        } else {\n          if (!this.#info.compressed) {\n            this.#fragments.push(body)\n\n            // If the frame is not fragmented, a message has been received.\n            // If the frame is fragmented, it will terminate with a fin bit set\n            // and an opcode of 0 (continuation), therefore we handle that when\n            // parsing continuation frames, not here.\n            if (!this.#info.fragmented && this.#info.fin) {\n              const fullMessage = Buffer.concat(this.#fragments)\n              websocketMessageReceived(this.ws, this.#info.binaryType, fullMessage)\n              this.#fragments.length = 0\n            }\n\n            this.#state = parserStates.INFO\n          } else {\n            this.#extensions.get('permessage-deflate').decompress(body, this.#info.fin, (error, data) => {\n              if (error) {\n                closeWebSocketConnection(this.ws, 1007, error.message, error.message.length)\n                return\n              }\n\n              this.#fragments.push(data)\n\n              if (!this.#info.fin) {\n                this.#state = parserStates.INFO\n                this.#loop = true\n                this.run(callback)\n                return\n              }\n\n              websocketMessageReceived(this.ws, this.#info.binaryType, Buffer.concat(this.#fragments))\n\n              this.#loop = true\n              this.#state = parserStates.INFO\n              this.#fragments.length = 0\n              this.run(callback)\n            })\n\n            this.#loop = false\n            break\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer}\n   */\n  consume (n) {\n    if (n > this.#byteOffset) {\n      throw new Error('Called consume() before buffers satiated.')\n    } else if (n === 0) {\n      return emptyBuffer\n    }\n\n    if (this.#buffers[0].length === n) {\n      this.#byteOffset -= this.#buffers[0].length\n      return this.#buffers.shift()\n    }\n\n    const buffer = Buffer.allocUnsafe(n)\n    let offset = 0\n\n    while (offset !== n) {\n      const next = this.#buffers[0]\n      const { length } = next\n\n      if (length + offset === n) {\n        buffer.set(this.#buffers.shift(), offset)\n        break\n      } else if (length + offset > n) {\n        buffer.set(next.subarray(0, n - offset), offset)\n        this.#buffers[0] = next.subarray(n - offset)\n        break\n      } else {\n        buffer.set(this.#buffers.shift(), offset)\n        offset += next.length\n      }\n    }\n\n    this.#byteOffset -= n\n\n    return buffer\n  }\n\n  parseCloseBody (data) {\n    assert(data.length !== 1)\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    /** @type {number|undefined} */\n    let code\n\n    if (data.length >= 2) {\n      // _The WebSocket Connection Close Code_ is\n      // defined as the status code (Section 7.4) contained in the first Close\n      // control frame received by the application\n      code = data.readUInt16BE(0)\n    }\n\n    if (code !== undefined && !isValidStatusCode(code)) {\n      return { code: 1002, reason: 'Invalid status code', error: true }\n    }\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n    /** @type {Buffer} */\n    let reason = data.subarray(2)\n\n    // Remove BOM\n    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n      reason = reason.subarray(3)\n    }\n\n    try {\n      reason = utf8Decode(reason)\n    } catch {\n      return { code: 1007, reason: 'Invalid UTF-8', error: true }\n    }\n\n    return { code, reason, error: false }\n  }\n\n  /**\n   * Parses control frames.\n   * @param {Buffer} body\n   */\n  parseControlFrame (body) {\n    const { opcode, payloadLength } = this.#info\n\n    if (opcode === opcodes.CLOSE) {\n      if (payloadLength === 1) {\n        failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.')\n        return false\n      }\n\n      this.#info.closeInfo = this.parseCloseBody(body)\n\n      if (this.#info.closeInfo.error) {\n        const { code, reason } = this.#info.closeInfo\n\n        closeWebSocketConnection(this.ws, code, reason, reason.length)\n        failWebsocketConnection(this.ws, reason)\n        return false\n      }\n\n      if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {\n        // If an endpoint receives a Close frame and did not previously send a\n        // Close frame, the endpoint MUST send a Close frame in response.  (When\n        // sending a Close frame in response, the endpoint typically echos the\n        // status code it received.)\n        let body = emptyBuffer\n        if (this.#info.closeInfo.code) {\n          body = Buffer.allocUnsafe(2)\n          body.writeUInt16BE(this.#info.closeInfo.code, 0)\n        }\n        const closeFrame = new WebsocketFrameSend(body)\n\n        this.ws[kResponse].socket.write(\n          closeFrame.createFrame(opcodes.CLOSE),\n          (err) => {\n            if (!err) {\n              this.ws[kSentClose] = sentCloseFrameState.SENT\n            }\n          }\n        )\n      }\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this.ws[kReadyState] = states.CLOSING\n      this.ws[kReceivedClose] = true\n\n      return false\n    } else if (opcode === opcodes.PING) {\n      // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n      // response, unless it already received a Close frame.\n      // A Pong frame sent in response to a Ping frame must have identical\n      // \"Application data\"\n\n      if (!this.ws[kReceivedClose]) {\n        const frame = new WebsocketFrameSend(body)\n\n        this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG))\n\n        if (channels.ping.hasSubscribers) {\n          channels.ping.publish({\n            payload: body\n          })\n        }\n      }\n    } else if (opcode === opcodes.PONG) {\n      // A Pong frame MAY be sent unsolicited.  This serves as a\n      // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n      // not expected.\n\n      if (channels.pong.hasSubscribers) {\n        channels.pong.publish({\n          payload: body\n        })\n      }\n    }\n\n    return true\n  }\n\n  get closingInfo () {\n    return this.#info.closeInfo\n  }\n}\n\nmodule.exports = {\n  ByteParser\n}\n"]}}