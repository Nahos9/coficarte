{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{Transform}=require(\"node:stream\");const{isASCIINumber,isValidLastEventId}=require(\"./util\");const BOM=[239,187,191];const LF=10;const CR=13;const COLON=58;const SPACE=32;class EventSourceStream extends Transform{static{__name(this,\"EventSourceStream\")}state=null;checkBOM=true;crlfCheck=false;eventEndCheck=false;buffer=null;pos=0;event={data:void 0,event:void 0,id:void 0,retry:void 0};constructor(options={}){options.readableObjectMode=true;super(options);this.state=options.eventSourceSettings||{};if(options.push){this.push=options.push}}_transform(chunk,_encoding,callback){if(chunk.length===0){callback();return}if(this.buffer){this.buffer=Buffer.concat([this.buffer,chunk])}else{this.buffer=chunk}if(this.checkBOM){switch(this.buffer.length){case 1:if(this.buffer[0]===BOM[0]){callback();return}this.checkBOM=false;callback();return;case 2:if(this.buffer[0]===BOM[0]&&this.buffer[1]===BOM[1]){callback();return}this.checkBOM=false;break;case 3:if(this.buffer[0]===BOM[0]&&this.buffer[1]===BOM[1]&&this.buffer[2]===BOM[2]){this.buffer=Buffer.alloc(0);this.checkBOM=false;callback();return}this.checkBOM=false;break;default:if(this.buffer[0]===BOM[0]&&this.buffer[1]===BOM[1]&&this.buffer[2]===BOM[2]){this.buffer=this.buffer.subarray(3)}this.checkBOM=false;break}}while(this.pos<this.buffer.length){if(this.eventEndCheck){if(this.crlfCheck){if(this.buffer[this.pos]===LF){this.buffer=this.buffer.subarray(this.pos+1);this.pos=0;this.crlfCheck=false;continue}this.crlfCheck=false}if(this.buffer[this.pos]===LF||this.buffer[this.pos]===CR){if(this.buffer[this.pos]===CR){this.crlfCheck=true}this.buffer=this.buffer.subarray(this.pos+1);this.pos=0;if(this.event.data!==void 0||this.event.event||this.event.id||this.event.retry){this.processEvent(this.event)}this.clearEvent();continue}this.eventEndCheck=false;continue}if(this.buffer[this.pos]===LF||this.buffer[this.pos]===CR){if(this.buffer[this.pos]===CR){this.crlfCheck=true}this.parseLine(this.buffer.subarray(0,this.pos),this.event);this.buffer=this.buffer.subarray(this.pos+1);this.pos=0;this.eventEndCheck=true;continue}this.pos++}callback()}parseLine(line,event){if(line.length===0){return}const colonPosition=line.indexOf(COLON);if(colonPosition===0){return}let field=\"\";let value=\"\";if(colonPosition!==-1){field=line.subarray(0,colonPosition).toString(\"utf8\");let valueStart=colonPosition+1;if(line[valueStart]===SPACE){++valueStart}value=line.subarray(valueStart).toString(\"utf8\")}else{field=line.toString(\"utf8\");value=\"\"}switch(field){case\"data\":if(event[field]===void 0){event[field]=value}else{event[field]+=`\n${value}`}break;case\"retry\":if(isASCIINumber(value)){event[field]=value}break;case\"id\":if(isValidLastEventId(value)){event[field]=value}break;case\"event\":if(value.length>0){event[field]=value}break}}processEvent(event){if(event.retry&&isASCIINumber(event.retry)){this.state.reconnectionTime=parseInt(event.retry,10)}if(event.id&&isValidLastEventId(event.id)){this.state.lastEventId=event.id}if(event.data!==void 0){this.push({type:event.event||\"message\",options:{data:event.data,lastEventId:this.state.lastEventId,origin:this.state.origin}})}}clearEvent(){this.event={data:void 0,event:void 0,id:void 0,retry:void 0}}}module.exports={EventSourceStream};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/eventsource/eventsource-stream.js"],"sourcesContent":["'use strict'\nconst { Transform } = require('node:stream')\nconst { isASCIINumber, isValidLastEventId } = require('./util')\n\n/**\n * @type {number[]} BOM\n */\nconst BOM = [0xEF, 0xBB, 0xBF]\n/**\n * @type {10} LF\n */\nconst LF = 0x0A\n/**\n * @type {13} CR\n */\nconst CR = 0x0D\n/**\n * @type {58} COLON\n */\nconst COLON = 0x3A\n/**\n * @type {32} SPACE\n */\nconst SPACE = 0x20\n\n/**\n * @typedef {object} EventSourceStreamEvent\n * @type {object}\n * @property {string} [event] The event type.\n * @property {string} [data] The data of the message.\n * @property {string} [id] A unique ID for the event.\n * @property {string} [retry] The reconnection time, in milliseconds.\n */\n\n/**\n * @typedef eventSourceSettings\n * @type {object}\n * @property {string} lastEventId The last event ID received from the server.\n * @property {string} origin The origin of the event source.\n * @property {number} reconnectionTime The reconnection time, in milliseconds.\n */\n\nclass EventSourceStream extends Transform {\n  /**\n   * @type {eventSourceSettings}\n   */\n  state = null\n\n  /**\n   * Leading byte-order-mark check.\n   * @type {boolean}\n   */\n  checkBOM = true\n\n  /**\n   * @type {boolean}\n   */\n  crlfCheck = false\n\n  /**\n   * @type {boolean}\n   */\n  eventEndCheck = false\n\n  /**\n   * @type {Buffer}\n   */\n  buffer = null\n\n  pos = 0\n\n  event = {\n    data: undefined,\n    event: undefined,\n    id: undefined,\n    retry: undefined\n  }\n\n  /**\n   * @param {object} options\n   * @param {eventSourceSettings} options.eventSourceSettings\n   * @param {Function} [options.push]\n   */\n  constructor (options = {}) {\n    // Enable object mode as EventSourceStream emits objects of shape\n    // EventSourceStreamEvent\n    options.readableObjectMode = true\n\n    super(options)\n\n    this.state = options.eventSourceSettings || {}\n    if (options.push) {\n      this.push = options.push\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {string} _encoding\n   * @param {Function} callback\n   * @returns {void}\n   */\n  _transform (chunk, _encoding, callback) {\n    if (chunk.length === 0) {\n      callback()\n      return\n    }\n\n    // Cache the chunk in the buffer, as the data might not be complete while\n    // processing it\n    // TODO: Investigate if there is a more performant way to handle\n    // incoming chunks\n    // see: https://github.com/nodejs/undici/issues/2630\n    if (this.buffer) {\n      this.buffer = Buffer.concat([this.buffer, chunk])\n    } else {\n      this.buffer = chunk\n    }\n\n    // Strip leading byte-order-mark if we opened the stream and started\n    // the processing of the incoming data\n    if (this.checkBOM) {\n      switch (this.buffer.length) {\n        case 1:\n          // Check if the first byte is the same as the first byte of the BOM\n          if (this.buffer[0] === BOM[0]) {\n            // If it is, we need to wait for more data\n            callback()\n            return\n          }\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false\n\n          // The buffer only contains one byte so we need to wait for more data\n          callback()\n          return\n        case 2:\n          // Check if the first two bytes are the same as the first two bytes\n          // of the BOM\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1]\n          ) {\n            // If it is, we need to wait for more data, because the third byte\n            // is needed to determine if it is the BOM or not\n            callback()\n            return\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false\n          break\n        case 3:\n          // Check if the first three bytes are the same as the first three\n          // bytes of the BOM\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1] &&\n            this.buffer[2] === BOM[2]\n          ) {\n            // If it is, we can drop the buffered data, as it is only the BOM\n            this.buffer = Buffer.alloc(0)\n            // Set the checkBOM flag to false as we don't need to check for the\n            // BOM anymore\n            this.checkBOM = false\n\n            // Await more data\n            callback()\n            return\n          }\n          // If it is not the BOM, we can start processing the data\n          this.checkBOM = false\n          break\n        default:\n          // The buffer is longer than 3 bytes, so we can drop the BOM if it is\n          // present\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1] &&\n            this.buffer[2] === BOM[2]\n          ) {\n            // Remove the BOM from the buffer\n            this.buffer = this.buffer.subarray(3)\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          this.checkBOM = false\n          break\n      }\n    }\n\n    while (this.pos < this.buffer.length) {\n      // If the previous line ended with an end-of-line, we need to check\n      // if the next character is also an end-of-line.\n      if (this.eventEndCheck) {\n        // If the the current character is an end-of-line, then the event\n        // is finished and we can process it\n\n        // If the previous line ended with a carriage return, we need to\n        // check if the current character is a line feed and remove it\n        // from the buffer.\n        if (this.crlfCheck) {\n          // If the current character is a line feed, we can remove it\n          // from the buffer and reset the crlfCheck flag\n          if (this.buffer[this.pos] === LF) {\n            this.buffer = this.buffer.subarray(this.pos + 1)\n            this.pos = 0\n            this.crlfCheck = false\n\n            // It is possible that the line feed is not the end of the\n            // event. We need to check if the next character is an\n            // end-of-line character to determine if the event is\n            // finished. We simply continue the loop to check the next\n            // character.\n\n            // As we removed the line feed from the buffer and set the\n            // crlfCheck flag to false, we basically don't make any\n            // distinction between a line feed and a carriage return.\n            continue\n          }\n          this.crlfCheck = false\n        }\n\n        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n          // If the current character is a carriage return, we need to\n          // set the crlfCheck flag to true, as we need to check if the\n          // next character is a line feed so we can remove it from the\n          // buffer\n          if (this.buffer[this.pos] === CR) {\n            this.crlfCheck = true\n          }\n\n          this.buffer = this.buffer.subarray(this.pos + 1)\n          this.pos = 0\n          if (\n            this.event.data !== undefined || this.event.event || this.event.id || this.event.retry) {\n            this.processEvent(this.event)\n          }\n          this.clearEvent()\n          continue\n        }\n        // If the current character is not an end-of-line, then the event\n        // is not finished and we have to reset the eventEndCheck flag\n        this.eventEndCheck = false\n        continue\n      }\n\n      // If the current character is an end-of-line, we can process the\n      // line\n      if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n        // If the current character is a carriage return, we need to\n        // set the crlfCheck flag to true, as we need to check if the\n        // next character is a line feed\n        if (this.buffer[this.pos] === CR) {\n          this.crlfCheck = true\n        }\n\n        // In any case, we can process the line as we reached an\n        // end-of-line character\n        this.parseLine(this.buffer.subarray(0, this.pos), this.event)\n\n        // Remove the processed line from the buffer\n        this.buffer = this.buffer.subarray(this.pos + 1)\n        // Reset the position as we removed the processed line from the buffer\n        this.pos = 0\n        // A line was processed and this could be the end of the event. We need\n        // to check if the next line is empty to determine if the event is\n        // finished.\n        this.eventEndCheck = true\n        continue\n      }\n\n      this.pos++\n    }\n\n    callback()\n  }\n\n  /**\n   * @param {Buffer} line\n   * @param {EventStreamEvent} event\n   */\n  parseLine (line, event) {\n    // If the line is empty (a blank line)\n    // Dispatch the event, as defined below.\n    // This will be handled in the _transform method\n    if (line.length === 0) {\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:)\n    // Ignore the line.\n    const colonPosition = line.indexOf(COLON)\n    if (colonPosition === 0) {\n      return\n    }\n\n    let field = ''\n    let value = ''\n\n    // If the line contains a U+003A COLON character (:)\n    if (colonPosition !== -1) {\n      // Collect the characters on the line before the first U+003A COLON\n      // character (:), and let field be that string.\n      // TODO: Investigate if there is a more performant way to extract the\n      // field\n      // see: https://github.com/nodejs/undici/issues/2630\n      field = line.subarray(0, colonPosition).toString('utf8')\n\n      // Collect the characters on the line after the first U+003A COLON\n      // character (:), and let value be that string.\n      // If value starts with a U+0020 SPACE character, remove it from value.\n      let valueStart = colonPosition + 1\n      if (line[valueStart] === SPACE) {\n        ++valueStart\n      }\n      // TODO: Investigate if there is a more performant way to extract the\n      // value\n      // see: https://github.com/nodejs/undici/issues/2630\n      value = line.subarray(valueStart).toString('utf8')\n\n      // Otherwise, the string is not empty but does not contain a U+003A COLON\n      // character (:)\n    } else {\n      // Process the field using the steps described below, using the whole\n      // line as the field name, and the empty string as the field value.\n      field = line.toString('utf8')\n      value = ''\n    }\n\n    // Modify the event with the field name and value. The value is also\n    // decoded as UTF-8\n    switch (field) {\n      case 'data':\n        if (event[field] === undefined) {\n          event[field] = value\n        } else {\n          event[field] += `\\n${value}`\n        }\n        break\n      case 'retry':\n        if (isASCIINumber(value)) {\n          event[field] = value\n        }\n        break\n      case 'id':\n        if (isValidLastEventId(value)) {\n          event[field] = value\n        }\n        break\n      case 'event':\n        if (value.length > 0) {\n          event[field] = value\n        }\n        break\n    }\n  }\n\n  /**\n   * @param {EventSourceStreamEvent} event\n   */\n  processEvent (event) {\n    if (event.retry && isASCIINumber(event.retry)) {\n      this.state.reconnectionTime = parseInt(event.retry, 10)\n    }\n\n    if (event.id && isValidLastEventId(event.id)) {\n      this.state.lastEventId = event.id\n    }\n\n    // only dispatch event, when data is provided\n    if (event.data !== undefined) {\n      this.push({\n        type: event.event || 'message',\n        options: {\n          data: event.data,\n          lastEventId: this.state.lastEventId,\n          origin: this.state.origin\n        }\n      })\n    }\n  }\n\n  clearEvent () {\n    this.event = {\n      data: undefined,\n      event: undefined,\n      id: undefined,\n      retry: undefined\n    }\n  }\n}\n\nmodule.exports = {\n  EventSourceStream\n}\n"]}}