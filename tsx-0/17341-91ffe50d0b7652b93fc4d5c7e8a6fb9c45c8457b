{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{Readable,Duplex,PassThrough}=require(\"node:stream\");const{InvalidArgumentError,InvalidReturnValueError,RequestAbortedError}=require(\"../core/errors\");const util=require(\"../core/util\");const{AsyncResource}=require(\"node:async_hooks\");const{addSignal,removeSignal}=require(\"./abort-signal\");const assert=require(\"node:assert\");const kResume=Symbol(\"resume\");class PipelineRequest extends Readable{static{__name(this,\"PipelineRequest\")}constructor(){super({autoDestroy:true});this[kResume]=null}_read(){const{[kResume]:resume}=this;if(resume){this[kResume]=null;resume()}}_destroy(err,callback){this._read();callback(err)}}class PipelineResponse extends Readable{static{__name(this,\"PipelineResponse\")}constructor(resume){super({autoDestroy:true});this[kResume]=resume}_read(){this[kResume]()}_destroy(err,callback){if(!err&&!this._readableState.endEmitted){err=new RequestAbortedError}callback(err)}}class PipelineHandler extends AsyncResource{static{__name(this,\"PipelineHandler\")}constructor(opts,handler){if(!opts||typeof opts!==\"object\"){throw new InvalidArgumentError(\"invalid opts\")}if(typeof handler!==\"function\"){throw new InvalidArgumentError(\"invalid handler\")}const{signal,method,opaque,onInfo,responseHeaders}=opts;if(signal&&typeof signal.on!==\"function\"&&typeof signal.addEventListener!==\"function\"){throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\")}if(method===\"CONNECT\"){throw new InvalidArgumentError(\"invalid method\")}if(onInfo&&typeof onInfo!==\"function\"){throw new InvalidArgumentError(\"invalid onInfo callback\")}super(\"UNDICI_PIPELINE\");this.opaque=opaque||null;this.responseHeaders=responseHeaders||null;this.handler=handler;this.abort=null;this.context=null;this.onInfo=onInfo||null;this.req=new PipelineRequest().on(\"error\",util.nop);this.ret=new Duplex({readableObjectMode:opts.objectMode,autoDestroy:true,read:()=>{const{body}=this;if(body?.resume){body.resume()}},write:(chunk,encoding,callback)=>{const{req}=this;if(req.push(chunk,encoding)||req._readableState.destroyed){callback()}else{req[kResume]=callback}},destroy:(err,callback)=>{const{body,req,res,ret,abort}=this;if(!err&&!ret._readableState.endEmitted){err=new RequestAbortedError}if(abort&&err){abort()}util.destroy(body,err);util.destroy(req,err);util.destroy(res,err);removeSignal(this);callback(err)}}).on(\"prefinish\",()=>{const{req}=this;req.push(null)});this.res=null;addSignal(this,signal)}onConnect(abort,context){const{ret,res}=this;if(this.reason){abort(this.reason);return}assert(!res,\"pipeline cannot be retried\");assert(!ret.destroyed);this.abort=abort;this.context=context}onHeaders(statusCode,rawHeaders,resume){const{opaque,handler,context}=this;if(statusCode<200){if(this.onInfo){const headers=this.responseHeaders===\"raw\"?util.parseRawHeaders(rawHeaders):util.parseHeaders(rawHeaders);this.onInfo({statusCode,headers})}return}this.res=new PipelineResponse(resume);let body;try{this.handler=null;const headers=this.responseHeaders===\"raw\"?util.parseRawHeaders(rawHeaders):util.parseHeaders(rawHeaders);body=this.runInAsyncScope(handler,null,{statusCode,headers,opaque,body:this.res,context})}catch(err){this.res.on(\"error\",util.nop);throw err}if(!body||typeof body.on!==\"function\"){throw new InvalidReturnValueError(\"expected Readable\")}body.on(\"data\",chunk=>{const{ret,body:body2}=this;if(!ret.push(chunk)&&body2.pause){body2.pause()}}).on(\"error\",err=>{const{ret}=this;util.destroy(ret,err)}).on(\"end\",()=>{const{ret}=this;ret.push(null)}).on(\"close\",()=>{const{ret}=this;if(!ret._readableState.ended){util.destroy(ret,new RequestAbortedError)}});this.body=body}onData(chunk){const{res}=this;return res.push(chunk)}onComplete(trailers){const{res}=this;res.push(null)}onError(err){const{ret}=this;this.handler=null;util.destroy(ret,err)}}function pipeline(opts,handler){try{const pipelineHandler=new PipelineHandler(opts,handler);this.dispatch({...opts,body:pipelineHandler.req},pipelineHandler);return pipelineHandler.ret}catch(err){return new PassThrough().destroy(err)}}__name(pipeline,\"pipeline\");module.exports=pipeline;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["body"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/api/api-pipeline.js"],"sourcesContent":["'use strict'\n\nconst {\n  Readable,\n  Duplex,\n  PassThrough\n} = require('node:stream')\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { AsyncResource } = require('node:async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\nconst assert = require('node:assert')\n\nconst kResume = Symbol('resume')\n\nclass PipelineRequest extends Readable {\n  constructor () {\n    super({ autoDestroy: true })\n\n    this[kResume] = null\n  }\n\n  _read () {\n    const { [kResume]: resume } = this\n\n    if (resume) {\n      this[kResume] = null\n      resume()\n    }\n  }\n\n  _destroy (err, callback) {\n    this._read()\n\n    callback(err)\n  }\n}\n\nclass PipelineResponse extends Readable {\n  constructor (resume) {\n    super({ autoDestroy: true })\n    this[kResume] = resume\n  }\n\n  _read () {\n    this[kResume]()\n  }\n\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    callback(err)\n  }\n}\n\nclass PipelineHandler extends AsyncResource {\n  constructor (opts, handler) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof handler !== 'function') {\n      throw new InvalidArgumentError('invalid handler')\n    }\n\n    const { signal, method, opaque, onInfo, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    if (method === 'CONNECT') {\n      throw new InvalidArgumentError('invalid method')\n    }\n\n    if (onInfo && typeof onInfo !== 'function') {\n      throw new InvalidArgumentError('invalid onInfo callback')\n    }\n\n    super('UNDICI_PIPELINE')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.handler = handler\n    this.abort = null\n    this.context = null\n    this.onInfo = onInfo || null\n\n    this.req = new PipelineRequest().on('error', util.nop)\n\n    this.ret = new Duplex({\n      readableObjectMode: opts.objectMode,\n      autoDestroy: true,\n      read: () => {\n        const { body } = this\n\n        if (body?.resume) {\n          body.resume()\n        }\n      },\n      write: (chunk, encoding, callback) => {\n        const { req } = this\n\n        if (req.push(chunk, encoding) || req._readableState.destroyed) {\n          callback()\n        } else {\n          req[kResume] = callback\n        }\n      },\n      destroy: (err, callback) => {\n        const { body, req, res, ret, abort } = this\n\n        if (!err && !ret._readableState.endEmitted) {\n          err = new RequestAbortedError()\n        }\n\n        if (abort && err) {\n          abort()\n        }\n\n        util.destroy(body, err)\n        util.destroy(req, err)\n        util.destroy(res, err)\n\n        removeSignal(this)\n\n        callback(err)\n      }\n    }).on('prefinish', () => {\n      const { req } = this\n\n      // Node < 15 does not call _final in same tick.\n      req.push(null)\n    })\n\n    this.res = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    const { ret, res } = this\n\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(!res, 'pipeline cannot be retried')\n    assert(!ret.destroyed)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume) {\n    const { opaque, handler, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.res = new PipelineResponse(resume)\n\n    let body\n    try {\n      this.handler = null\n      const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n      body = this.runInAsyncScope(handler, null, {\n        statusCode,\n        headers,\n        opaque,\n        body: this.res,\n        context\n      })\n    } catch (err) {\n      this.res.on('error', util.nop)\n      throw err\n    }\n\n    if (!body || typeof body.on !== 'function') {\n      throw new InvalidReturnValueError('expected Readable')\n    }\n\n    body\n      .on('data', (chunk) => {\n        const { ret, body } = this\n\n        if (!ret.push(chunk) && body.pause) {\n          body.pause()\n        }\n      })\n      .on('error', (err) => {\n        const { ret } = this\n\n        util.destroy(ret, err)\n      })\n      .on('end', () => {\n        const { ret } = this\n\n        ret.push(null)\n      })\n      .on('close', () => {\n        const { ret } = this\n\n        if (!ret._readableState.ended) {\n          util.destroy(ret, new RequestAbortedError())\n        }\n      })\n\n    this.body = body\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n    res.push(null)\n  }\n\n  onError (err) {\n    const { ret } = this\n    this.handler = null\n    util.destroy(ret, err)\n  }\n}\n\nfunction pipeline (opts, handler) {\n  try {\n    const pipelineHandler = new PipelineHandler(opts, handler)\n    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler)\n    return pipelineHandler.ret\n  } catch (err) {\n    return new PassThrough().destroy(err)\n  }\n}\n\nmodule.exports = pipeline\n"]}}