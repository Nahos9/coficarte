{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{Headers,HeadersList,fill,getHeadersGuard,setHeadersGuard,setHeadersList}=require(\"./headers\");const{extractBody,cloneBody,mixinBody,hasFinalizationRegistry,streamRegistry,bodyUnusable}=require(\"./body\");const util=require(\"../../core/util\");const nodeUtil=require(\"node:util\");const{kEnumerableProperty}=util;const{isValidReasonPhrase,isCancelled,isAborted,isBlobLike,serializeJavascriptValueToJSONString,isErrorLike,isomorphicEncode,environmentSettingsObject:relevantRealm}=require(\"./util\");const{redirectStatusSet,nullBodyStatus}=require(\"./constants\");const{kState,kHeaders}=require(\"./symbols\");const{webidl}=require(\"./webidl\");const{FormData}=require(\"./formdata\");const{URLSerializer}=require(\"./data-url\");const{kConstruct}=require(\"../../core/symbols\");const assert=require(\"node:assert\");const{types}=require(\"node:util\");const textEncoder=new TextEncoder(\"utf-8\");class Response{static{__name(this,\"Response\")}static error(){const responseObject=fromInnerResponse(makeNetworkError(),\"immutable\");return responseObject}static json(data,init={}){webidl.argumentLengthCheck(arguments,1,\"Response.json\");if(init!==null){init=webidl.converters.ResponseInit(init)}const bytes=textEncoder.encode(serializeJavascriptValueToJSONString(data));const body=extractBody(bytes);const responseObject=fromInnerResponse(makeResponse({}),\"response\");initializeResponse(responseObject,init,{body:body[0],type:\"application/json\"});return responseObject}static redirect(url,status=302){webidl.argumentLengthCheck(arguments,1,\"Response.redirect\");url=webidl.converters.USVString(url);status=webidl.converters[\"unsigned short\"](status);let parsedURL;try{parsedURL=new URL(url,relevantRealm.settingsObject.baseUrl)}catch(err){throw new TypeError(`Failed to parse URL from ${url}`,{cause:err})}if(!redirectStatusSet.has(status)){throw new RangeError(`Invalid status code ${status}`)}const responseObject=fromInnerResponse(makeResponse({}),\"immutable\");responseObject[kState].status=status;const value=isomorphicEncode(URLSerializer(parsedURL));responseObject[kState].headersList.append(\"location\",value,true);return responseObject}constructor(body=null,init={}){webidl.util.markAsUncloneable(this);if(body===kConstruct){return}if(body!==null){body=webidl.converters.BodyInit(body)}init=webidl.converters.ResponseInit(init);this[kState]=makeResponse({});this[kHeaders]=new Headers(kConstruct);setHeadersGuard(this[kHeaders],\"response\");setHeadersList(this[kHeaders],this[kState].headersList);let bodyWithType=null;if(body!=null){const[extractedBody,type]=extractBody(body);bodyWithType={body:extractedBody,type}}initializeResponse(this,init,bodyWithType)}get type(){webidl.brandCheck(this,Response);return this[kState].type}get url(){webidl.brandCheck(this,Response);const urlList=this[kState].urlList;const url=urlList[urlList.length-1]??null;if(url===null){return\"\"}return URLSerializer(url,true)}get redirected(){webidl.brandCheck(this,Response);return this[kState].urlList.length>1}get status(){webidl.brandCheck(this,Response);return this[kState].status}get ok(){webidl.brandCheck(this,Response);return this[kState].status>=200&&this[kState].status<=299}get statusText(){webidl.brandCheck(this,Response);return this[kState].statusText}get headers(){webidl.brandCheck(this,Response);return this[kHeaders]}get body(){webidl.brandCheck(this,Response);return this[kState].body?this[kState].body.stream:null}get bodyUsed(){webidl.brandCheck(this,Response);return!!this[kState].body&&util.isDisturbed(this[kState].body.stream)}clone(){webidl.brandCheck(this,Response);if(bodyUnusable(this)){throw webidl.errors.exception({header:\"Response.clone\",message:\"Body has already been consumed.\"})}const clonedResponse=cloneResponse(this[kState]);return fromInnerResponse(clonedResponse,getHeadersGuard(this[kHeaders]))}[nodeUtil.inspect.custom](depth,options){if(options.depth===null){options.depth=2}options.colors??=true;const properties={status:this.status,statusText:this.statusText,headers:this.headers,body:this.body,bodyUsed:this.bodyUsed,ok:this.ok,redirected:this.redirected,type:this.type,url:this.url};return`Response ${nodeUtil.formatWithOptions(options,properties)}`}}mixinBody(Response);Object.defineProperties(Response.prototype,{type:kEnumerableProperty,url:kEnumerableProperty,status:kEnumerableProperty,ok:kEnumerableProperty,redirected:kEnumerableProperty,statusText:kEnumerableProperty,headers:kEnumerableProperty,clone:kEnumerableProperty,body:kEnumerableProperty,bodyUsed:kEnumerableProperty,[Symbol.toStringTag]:{value:\"Response\",configurable:true}});Object.defineProperties(Response,{json:kEnumerableProperty,redirect:kEnumerableProperty,error:kEnumerableProperty});function cloneResponse(response){if(response.internalResponse){return filterResponse(cloneResponse(response.internalResponse),response.type)}const newResponse=makeResponse({...response,body:null});if(response.body!=null){newResponse.body=cloneBody(newResponse,response.body)}return newResponse}__name(cloneResponse,\"cloneResponse\");function makeResponse(init){return{aborted:false,rangeRequested:false,timingAllowPassed:false,requestIncludesCredentials:false,type:\"default\",status:200,timingInfo:null,cacheState:\"\",statusText:\"\",...init,headersList:init?.headersList?new HeadersList(init?.headersList):new HeadersList,urlList:init?.urlList?[...init.urlList]:[]}}__name(makeResponse,\"makeResponse\");function makeNetworkError(reason){const isError=isErrorLike(reason);return makeResponse({type:\"error\",status:0,error:isError?reason:new Error(reason?String(reason):reason),aborted:reason&&reason.name===\"AbortError\"})}__name(makeNetworkError,\"makeNetworkError\");function isNetworkError(response){return response.type===\"error\"&&response.status===0}__name(isNetworkError,\"isNetworkError\");function makeFilteredResponse(response,state){state={internalResponse:response,...state};return new Proxy(response,{get(target,p){return p in state?state[p]:target[p]},set(target,p,value){assert(!(p in state));target[p]=value;return true}})}__name(makeFilteredResponse,\"makeFilteredResponse\");function filterResponse(response,type){if(type===\"basic\"){return makeFilteredResponse(response,{type:\"basic\",headersList:response.headersList})}else if(type===\"cors\"){return makeFilteredResponse(response,{type:\"cors\",headersList:response.headersList})}else if(type===\"opaque\"){return makeFilteredResponse(response,{type:\"opaque\",urlList:Object.freeze([]),status:0,statusText:\"\",body:null})}else if(type===\"opaqueredirect\"){return makeFilteredResponse(response,{type:\"opaqueredirect\",status:0,statusText:\"\",headersList:[],body:null})}else{assert(false)}}__name(filterResponse,\"filterResponse\");function makeAppropriateNetworkError(fetchParams,err=null){assert(isCancelled(fetchParams));return isAborted(fetchParams)?makeNetworkError(Object.assign(new DOMException(\"The operation was aborted.\",\"AbortError\"),{cause:err})):makeNetworkError(Object.assign(new DOMException(\"Request was cancelled.\"),{cause:err}))}__name(makeAppropriateNetworkError,\"makeAppropriateNetworkError\");function initializeResponse(response,init,body){if(init.status!==null&&(init.status<200||init.status>599)){throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.')}if(\"statusText\"in init&&init.statusText!=null){if(!isValidReasonPhrase(String(init.statusText))){throw new TypeError(\"Invalid statusText\")}}if(\"status\"in init&&init.status!=null){response[kState].status=init.status}if(\"statusText\"in init&&init.statusText!=null){response[kState].statusText=init.statusText}if(\"headers\"in init&&init.headers!=null){fill(response[kHeaders],init.headers)}if(body){if(nullBodyStatus.includes(response.status)){throw webidl.errors.exception({header:\"Response constructor\",message:`Invalid response status code ${response.status}`})}response[kState].body=body.body;if(body.type!=null&&!response[kState].headersList.contains(\"content-type\",true)){response[kState].headersList.append(\"content-type\",body.type,true)}}}__name(initializeResponse,\"initializeResponse\");function fromInnerResponse(innerResponse,guard){const response=new Response(kConstruct);response[kState]=innerResponse;response[kHeaders]=new Headers(kConstruct);setHeadersList(response[kHeaders],innerResponse.headersList);setHeadersGuard(response[kHeaders],guard);if(hasFinalizationRegistry&&innerResponse.body?.stream){streamRegistry.register(response,new WeakRef(innerResponse.body.stream))}return response}__name(fromInnerResponse,\"fromInnerResponse\");webidl.converters.ReadableStream=webidl.interfaceConverter(ReadableStream);webidl.converters.FormData=webidl.interfaceConverter(FormData);webidl.converters.URLSearchParams=webidl.interfaceConverter(URLSearchParams);webidl.converters.XMLHttpRequestBodyInit=function(V,prefix,name){if(typeof V===\"string\"){return webidl.converters.USVString(V,prefix,name)}if(isBlobLike(V)){return webidl.converters.Blob(V,prefix,name,{strict:false})}if(ArrayBuffer.isView(V)||types.isArrayBuffer(V)){return webidl.converters.BufferSource(V,prefix,name)}if(util.isFormDataLike(V)){return webidl.converters.FormData(V,prefix,name,{strict:false})}if(V instanceof URLSearchParams){return webidl.converters.URLSearchParams(V,prefix,name)}return webidl.converters.DOMString(V,prefix,name)};webidl.converters.BodyInit=function(V,prefix,argument){if(V instanceof ReadableStream){return webidl.converters.ReadableStream(V,prefix,argument)}if(V?.[Symbol.asyncIterator]){return V}return webidl.converters.XMLHttpRequestBodyInit(V,prefix,argument)};webidl.converters.ResponseInit=webidl.dictionaryConverter([{key:\"status\",converter:webidl.converters[\"unsigned short\"],defaultValue:()=>200},{key:\"statusText\",converter:webidl.converters.ByteString,defaultValue:()=>\"\"},{key:\"headers\",converter:webidl.converters.HeadersInit}]);module.exports={isNetworkError,makeNetworkError,makeResponse,makeAppropriateNetworkError,filterResponse,Response,cloneResponse,fromInnerResponse};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/fetch/response.js"],"sourcesContent":["'use strict'\n\nconst { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = require('./headers')\nconst { extractBody, cloneBody, mixinBody, hasFinalizationRegistry, streamRegistry, bodyUnusable } = require('./body')\nconst util = require('../../core/util')\nconst nodeUtil = require('node:util')\nconst { kEnumerableProperty } = util\nconst {\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  isBlobLike,\n  serializeJavascriptValueToJSONString,\n  isErrorLike,\n  isomorphicEncode,\n  environmentSettingsObject: relevantRealm\n} = require('./util')\nconst {\n  redirectStatusSet,\n  nullBodyStatus\n} = require('./constants')\nconst { kState, kHeaders } = require('./symbols')\nconst { webidl } = require('./webidl')\nconst { FormData } = require('./formdata')\nconst { URLSerializer } = require('./data-url')\nconst { kConstruct } = require('../../core/symbols')\nconst assert = require('node:assert')\nconst { types } = require('node:util')\n\nconst textEncoder = new TextEncoder('utf-8')\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error () {\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = fromInnerResponse(makeNetworkError(), 'immutable')\n\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-json\n  static json (data, init = {}) {\n    webidl.argumentLengthCheck(arguments, 1, 'Response.json')\n\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init)\n    }\n\n    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n    const bytes = textEncoder.encode(\n      serializeJavascriptValueToJSONString(data)\n    )\n\n    // 2. Let body be the result of extracting bytes.\n    const body = extractBody(bytes)\n\n    // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and this’s relevant Realm.\n    const responseObject = fromInnerResponse(makeResponse({}), 'response')\n\n    // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' })\n\n    // 5. Return responseObject.\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (url, status = 302) {\n    webidl.argumentLengthCheck(arguments, 1, 'Response.redirect')\n\n    url = webidl.converters.USVString(url)\n    status = webidl.converters['unsigned short'](status)\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl)\n    } catch (err) {\n      throw new TypeError(`Failed to parse URL from ${url}`, { cause: err })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatusSet.has(status)) {\n      throw new RangeError(`Invalid status code ${status}`)\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = fromInnerResponse(makeResponse({}), 'immutable')\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject[kState].status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    const value = isomorphicEncode(URLSerializer(parsedURL))\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject[kState].headersList.append('location', value, true)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (body = null, init = {}) {\n    webidl.util.markAsUncloneable(this)\n    if (body === kConstruct) {\n      return\n    }\n\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body)\n    }\n\n    init = webidl.converters.ResponseInit(init)\n\n    // 1. Set this’s response to a new response.\n    this[kState] = makeResponse({})\n\n    // 2. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers(kConstruct)\n    setHeadersGuard(this[kHeaders], 'response')\n    setHeadersList(this[kHeaders], this[kState].headersList)\n\n    // 3. Let bodyWithType be null.\n    let bodyWithType = null\n\n    // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body)\n      bodyWithType = { body: extractedBody, type }\n    }\n\n    // 5. Perform initialize a response given this, init, and bodyWithType.\n    initializeResponse(this, init, bodyWithType)\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type () {\n    webidl.brandCheck(this, Response)\n\n    // The type getter steps are to return this’s response’s type.\n    return this[kState].type\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url () {\n    webidl.brandCheck(this, Response)\n\n    const urlList = this[kState].urlList\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    const url = urlList[urlList.length - 1] ?? null\n\n    if (url === null) {\n      return ''\n    }\n\n    return URLSerializer(url, true)\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    webidl.brandCheck(this, Response)\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1\n  }\n\n  // Returns response’s status.\n  get status () {\n    webidl.brandCheck(this, Response)\n\n    // The status getter steps are to return this’s response’s status.\n    return this[kState].status\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok () {\n    webidl.brandCheck(this, Response)\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299\n  }\n\n  // Returns response’s status message.\n  get statusText () {\n    webidl.brandCheck(this, Response)\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this[kState].statusText\n  }\n\n  // Returns response’s headers as Headers.\n  get headers () {\n    webidl.brandCheck(this, Response)\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  get body () {\n    webidl.brandCheck(this, Response)\n\n    return this[kState].body ? this[kState].body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Response)\n\n    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)\n  }\n\n  // Returns a clone of response.\n  clone () {\n    webidl.brandCheck(this, Response)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (bodyUnusable(this)) {\n      throw webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      })\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this[kState])\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    return fromInnerResponse(clonedResponse, getHeadersGuard(this[kHeaders]))\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    if (options.depth === null) {\n      options.depth = 2\n    }\n\n    options.colors ??= true\n\n    const properties = {\n      status: this.status,\n      statusText: this.statusText,\n      headers: this.headers,\n      body: this.body,\n      bodyUsed: this.bodyUsed,\n      ok: this.ok,\n      redirected: this.redirected,\n      type: this.type,\n      url: this.url\n    }\n\n    return `Response ${nodeUtil.formatWithOptions(options, properties)}`\n  }\n}\n\nmixinBody(Response)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Response',\n    configurable: true\n  }\n})\n\nObject.defineProperties(Response, {\n  json: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(newResponse, response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init?.headersList\n      ? new HeadersList(init?.headersList)\n      : new HeadersList(),\n    urlList: init?.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  const isError = isErrorLike(reason)\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError\n      ? reason\n      : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\n// @see https://fetch.spec.whatwg.org/#concept-network-error\nfunction isNetworkError (response) {\n  return (\n    // A network error is a response whose type is \"error\",\n    response.type === 'error' &&\n    // status is 0\n    response.status === 0\n  )\n}\n\nfunction makeFilteredResponse (response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  }\n\n  return new Proxy(response, {\n    get (target, p) {\n      return p in state ? state[p] : target[p]\n    },\n    set (target, p, value) {\n      assert(!(p in state))\n      target[p] = value\n      return true\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: Object.freeze([]),\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError (fetchParams, err = null) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams))\n\n  // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n  return isAborted(fetchParams)\n    ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), { cause: err }))\n    : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), { cause: err }))\n}\n\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse (response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.')\n  }\n\n  // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText')\n    }\n  }\n\n  // 3. Set response’s response’s status to init[\"status\"].\n  if ('status' in init && init.status != null) {\n    response[kState].status = init.status\n  }\n\n  // 4. Set response’s response’s status message to init[\"statusText\"].\n  if ('statusText' in init && init.statusText != null) {\n    response[kState].statusText = init.statusText\n  }\n\n  // 5. If init[\"headers\"] exists, then fill response’s headers with init[\"headers\"].\n  if ('headers' in init && init.headers != null) {\n    fill(response[kHeaders], init.headers)\n  }\n\n  // 6. If body was given, then:\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      throw webidl.errors.exception({\n        header: 'Response constructor',\n        message: `Invalid response status code ${response.status}`\n      })\n    }\n\n    // 2. Set response's body to body's body.\n    response[kState].body = body.body\n\n    // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n    if (body.type != null && !response[kState].headersList.contains('content-type', true)) {\n      response[kState].headersList.append('content-type', body.type, true)\n    }\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#response-create\n * @param {any} innerResponse\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Response}\n */\nfunction fromInnerResponse (innerResponse, guard) {\n  const response = new Response(kConstruct)\n  response[kState] = innerResponse\n  response[kHeaders] = new Headers(kConstruct)\n  setHeadersList(response[kHeaders], innerResponse.headersList)\n  setHeadersGuard(response[kHeaders], guard)\n\n  if (hasFinalizationRegistry && innerResponse.body?.stream) {\n    // If the target (response) is reclaimed, the cleanup callback may be called at some point with\n    // the held value provided for it (innerResponse.body.stream). The held value can be any value:\n    // a primitive or an object, even undefined. If the held value is an object, the registry keeps\n    // a strong reference to it (so it can pass it to the cleanup callback later). Reworded from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n    streamRegistry.register(response, new WeakRef(innerResponse.body.stream))\n  }\n\n  return response\n}\n\nwebidl.converters.ReadableStream = webidl.interfaceConverter(\n  ReadableStream\n)\n\nwebidl.converters.FormData = webidl.interfaceConverter(\n  FormData\n)\n\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(\n  URLSearchParams\n)\n\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function (V, prefix, name) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V, prefix, name)\n  }\n\n  if (isBlobLike(V)) {\n    return webidl.converters.Blob(V, prefix, name, { strict: false })\n  }\n\n  if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {\n    return webidl.converters.BufferSource(V, prefix, name)\n  }\n\n  if (util.isFormDataLike(V)) {\n    return webidl.converters.FormData(V, prefix, name, { strict: false })\n  }\n\n  if (V instanceof URLSearchParams) {\n    return webidl.converters.URLSearchParams(V, prefix, name)\n  }\n\n  return webidl.converters.DOMString(V, prefix, name)\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function (V, prefix, argument) {\n  if (V instanceof ReadableStream) {\n    return webidl.converters.ReadableStream(V, prefix, argument)\n  }\n\n  // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n  if (V?.[Symbol.asyncIterator]) {\n    return V\n  }\n\n  return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument)\n}\n\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n  {\n    key: 'status',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: () => 200\n  },\n  {\n    key: 'statusText',\n    converter: webidl.converters.ByteString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  }\n])\n\nmodule.exports = {\n  isNetworkError,\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response,\n  cloneResponse,\n  fromInnerResponse\n}\n"]}}