{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{promisify}=require(\"node:util\");const Pool=require(\"../dispatcher/pool\");const{buildMockDispatch}=require(\"./mock-utils\");const{kDispatches,kMockAgent,kClose,kOriginalClose,kOrigin,kOriginalDispatch,kConnected}=require(\"./mock-symbols\");const{MockInterceptor}=require(\"./mock-interceptor\");const Symbols=require(\"../core/symbols\");const{InvalidArgumentError}=require(\"../core/errors\");class MockPool extends Pool{static{__name(this,\"MockPool\")}constructor(origin,opts){super(origin,opts);if(!opts||!opts.agent||typeof opts.agent.dispatch!==\"function\"){throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\")}this[kMockAgent]=opts.agent;this[kOrigin]=origin;this[kDispatches]=[];this[kConnected]=1;this[kOriginalDispatch]=this.dispatch;this[kOriginalClose]=this.close.bind(this);this.dispatch=buildMockDispatch.call(this);this.close=this[kClose]}get[Symbols.kConnected](){return this[kConnected]}intercept(opts){return new MockInterceptor(opts,this[kDispatches])}async[kClose](){await promisify(this[kOriginalClose])();this[kConnected]=0;this[kMockAgent][Symbols.kClients].delete(this[kOrigin])}}module.exports=MockPool;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAEA,KAAM,CAAE,SAAU,EAAI,QAAQ,WAAW,EACzC,MAAM,KAAO,QAAQ,oBAAoB,EACzC,KAAM,CAAE,iBAAkB,EAAI,QAAQ,cAAc,EACpD,KAAM,CACJ,YACA,WACA,OACA,eACA,QACA,kBACA,UACF,EAAI,QAAQ,gBAAgB,EAC5B,KAAM,CAAE,eAAgB,EAAI,QAAQ,oBAAoB,EACxD,MAAM,QAAU,QAAQ,iBAAiB,EACzC,KAAM,CAAE,oBAAqB,EAAI,QAAQ,gBAAgB,EAKzD,MAAM,iBAAiB,IAAK,CArB5B,MAqB4B,yBAC1B,YAAa,OAAQ,KAAM,CACzB,MAAM,OAAQ,IAAI,EAElB,GAAI,CAAC,MAAQ,CAAC,KAAK,OAAS,OAAO,KAAK,MAAM,WAAa,WAAY,CACrE,MAAM,IAAI,qBAAqB,0CAA0C,CAC3E,CAEA,KAAK,UAAU,EAAI,KAAK,MACxB,KAAK,OAAO,EAAI,OAChB,KAAK,WAAW,EAAI,CAAC,EACrB,KAAK,UAAU,EAAI,EACnB,KAAK,iBAAiB,EAAI,KAAK,SAC/B,KAAK,cAAc,EAAI,KAAK,MAAM,KAAK,IAAI,EAE3C,KAAK,SAAW,kBAAkB,KAAK,IAAI,EAC3C,KAAK,MAAQ,KAAK,MAAM,CAC1B,CAEA,IAAK,QAAQ,UAAU,GAAK,CAC1B,OAAO,KAAK,UAAU,CACxB,CAKA,UAAW,KAAM,CACf,OAAO,IAAI,gBAAgB,KAAM,KAAK,WAAW,CAAC,CACpD,CAEA,MAAO,MAAM,GAAK,CAChB,MAAM,UAAU,KAAK,cAAc,CAAC,EAAE,EACtC,KAAK,UAAU,EAAI,EACnB,KAAK,UAAU,EAAE,QAAQ,QAAQ,EAAE,OAAO,KAAK,OAAO,CAAC,CACzD,CACF,CAEA,OAAO,QAAU","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/mock/mock-pool.js"],"sourcesContent":["'use strict'\n\nconst { promisify } = require('node:util')\nconst Pool = require('../dispatcher/pool')\nconst { buildMockDispatch } = require('./mock-utils')\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected\n} = require('./mock-symbols')\nconst { MockInterceptor } = require('./mock-interceptor')\nconst Symbols = require('../core/symbols')\nconst { InvalidArgumentError } = require('../core/errors')\n\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */\nclass MockPool extends Pool {\n  constructor (origin, opts) {\n    super(origin, opts)\n\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(opts, this[kDispatches])\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockPool\n"]}}