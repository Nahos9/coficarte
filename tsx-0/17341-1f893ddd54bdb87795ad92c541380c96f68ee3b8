{"code":"(()=>{\n\"use strict\";const{types,inspect}=require(\"node:util\");const{markAsUncloneable}=require(\"node:worker_threads\");const{toUSVString}=require(\"../../core/util\");const webidl={};webidl.converters={};webidl.util={};webidl.errors={};webidl.errors.exception=function(message){return new TypeError(`${message.header}: ${message.message}`)};webidl.errors.conversionFailed=function(context){const plural=context.types.length===1?\"\":\" one of\";const message=`${context.argument} could not be converted to${plural}: ${context.types.join(\", \")}.`;return webidl.errors.exception({header:context.prefix,message})};webidl.errors.invalidArgument=function(context){return webidl.errors.exception({header:context.prefix,message:`\"${context.value}\" is an invalid ${context.type}.`})};webidl.brandCheck=function(V,I,opts){if(opts?.strict!==false){if(!(V instanceof I)){const err=new TypeError(\"Illegal invocation\");err.code=\"ERR_INVALID_THIS\";throw err}}else{if(V?.[Symbol.toStringTag]!==I.prototype[Symbol.toStringTag]){const err=new TypeError(\"Illegal invocation\");err.code=\"ERR_INVALID_THIS\";throw err}}};webidl.argumentLengthCheck=function({length},min,ctx){if(length<min){throw webidl.errors.exception({message:`${min} argument${min!==1?\"s\":\"\"} required, but${length?\" only\":\"\"} ${length} found.`,header:ctx})}};webidl.illegalConstructor=function(){throw webidl.errors.exception({header:\"TypeError\",message:\"Illegal constructor\"})};webidl.util.Type=function(V){switch(typeof V){case\"undefined\":return\"Undefined\";case\"boolean\":return\"Boolean\";case\"string\":return\"String\";case\"symbol\":return\"Symbol\";case\"number\":return\"Number\";case\"bigint\":return\"BigInt\";case\"function\":case\"object\":{if(V===null){return\"Null\"}return\"Object\"}}};webidl.util.markAsUncloneable=markAsUncloneable||(()=>{});webidl.util.ConvertToInt=function(V,bitLength,signedness,opts){let upperBound;let lowerBound;if(bitLength===64){upperBound=Math.pow(2,53)-1;if(signedness===\"unsigned\"){lowerBound=0}else{lowerBound=Math.pow(-2,53)+1}}else if(signedness===\"unsigned\"){lowerBound=0;upperBound=Math.pow(2,bitLength)-1}else{lowerBound=Math.pow(-2,bitLength)-1;upperBound=Math.pow(2,bitLength-1)-1}let x=Number(V);if(x===0){x=0}if(opts?.enforceRange===true){if(Number.isNaN(x)||x===Number.POSITIVE_INFINITY||x===Number.NEGATIVE_INFINITY){throw webidl.errors.exception({header:\"Integer conversion\",message:`Could not convert ${webidl.util.Stringify(V)} to an integer.`})}x=webidl.util.IntegerPart(x);if(x<lowerBound||x>upperBound){throw webidl.errors.exception({header:\"Integer conversion\",message:`Value must be between ${lowerBound}-${upperBound}, got ${x}.`})}return x}if(!Number.isNaN(x)&&opts?.clamp===true){x=Math.min(Math.max(x,lowerBound),upperBound);if(Math.floor(x)%2===0){x=Math.floor(x)}else{x=Math.ceil(x)}return x}if(Number.isNaN(x)||x===0&&Object.is(0,x)||x===Number.POSITIVE_INFINITY||x===Number.NEGATIVE_INFINITY){return 0}x=webidl.util.IntegerPart(x);x=x%Math.pow(2,bitLength);if(signedness===\"signed\"&&x>=Math.pow(2,bitLength)-1){return x-Math.pow(2,bitLength)}return x};webidl.util.IntegerPart=function(n){const r=Math.floor(Math.abs(n));if(n<0){return-1*r}return r};webidl.util.Stringify=function(V){const type=webidl.util.Type(V);switch(type){case\"Symbol\":return`Symbol(${V.description})`;case\"Object\":return inspect(V);case\"String\":return`\"${V}\"`;default:return`${V}`}};webidl.sequenceConverter=function(converter){return(V,prefix,argument,Iterable)=>{if(webidl.util.Type(V)!==\"Object\"){throw webidl.errors.exception({header:prefix,message:`${argument} (${webidl.util.Stringify(V)}) is not iterable.`})}const method=typeof Iterable===\"function\"?Iterable():V?.[Symbol.iterator]?.();const seq=[];let index=0;if(method===void 0||typeof method.next!==\"function\"){throw webidl.errors.exception({header:prefix,message:`${argument} is not iterable.`})}while(true){const{done,value}=method.next();if(done){break}seq.push(converter(value,prefix,`${argument}[${index++}]`))}return seq}};webidl.recordConverter=function(keyConverter,valueConverter){return(O,prefix,argument)=>{if(webidl.util.Type(O)!==\"Object\"){throw webidl.errors.exception({header:prefix,message:`${argument} (\"${webidl.util.Type(O)}\") is not an Object.`})}const result={};if(!types.isProxy(O)){const keys2=[...Object.getOwnPropertyNames(O),...Object.getOwnPropertySymbols(O)];for(const key of keys2){const typedKey=keyConverter(key,prefix,argument);const typedValue=valueConverter(O[key],prefix,argument);result[typedKey]=typedValue}return result}const keys=Reflect.ownKeys(O);for(const key of keys){const desc=Reflect.getOwnPropertyDescriptor(O,key);if(desc?.enumerable){const typedKey=keyConverter(key,prefix,argument);const typedValue=valueConverter(O[key],prefix,argument);result[typedKey]=typedValue}}return result}};webidl.interfaceConverter=function(i){return(V,prefix,argument,opts)=>{if(opts?.strict!==false&&!(V instanceof i)){throw webidl.errors.exception({header:prefix,message:`Expected ${argument} (\"${webidl.util.Stringify(V)}\") to be an instance of ${i.name}.`})}return V}};webidl.dictionaryConverter=function(converters){return(dictionary,prefix,argument)=>{const type=webidl.util.Type(dictionary);const dict={};if(type===\"Null\"||type===\"Undefined\"){return dict}else if(type!==\"Object\"){throw webidl.errors.exception({header:prefix,message:`Expected ${dictionary} to be one of: Null, Undefined, Object.`})}for(const options of converters){const{key,defaultValue,required,converter}=options;if(required===true){if(!Object.hasOwn(dictionary,key)){throw webidl.errors.exception({header:prefix,message:`Missing required key \"${key}\".`})}}let value=dictionary[key];const hasDefault=Object.hasOwn(options,\"defaultValue\");if(hasDefault&&value!==null){value??=defaultValue()}if(required||hasDefault||value!==void 0){value=converter(value,prefix,`${argument}.${key}`);if(options.allowedValues&&!options.allowedValues.includes(value)){throw webidl.errors.exception({header:prefix,message:`${value} is not an accepted type. Expected one of ${options.allowedValues.join(\", \")}.`})}dict[key]=value}}return dict}};webidl.nullableConverter=function(converter){return(V,prefix,argument)=>{if(V===null){return V}return converter(V,prefix,argument)}};webidl.converters.DOMString=function(V,prefix,argument,opts){if(V===null&&opts?.legacyNullToEmptyString){return\"\"}if(typeof V===\"symbol\"){throw webidl.errors.exception({header:prefix,message:`${argument} is a symbol, which cannot be converted to a DOMString.`})}return String(V)};webidl.converters.ByteString=function(V,prefix,argument){const x=webidl.converters.DOMString(V,prefix,argument);for(let index=0;index<x.length;index++){if(x.charCodeAt(index)>255){throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`)}}return x};webidl.converters.USVString=toUSVString;webidl.converters.boolean=function(V){const x=Boolean(V);return x};webidl.converters.any=function(V){return V};webidl.converters[\"long long\"]=function(V,prefix,argument){const x=webidl.util.ConvertToInt(V,64,\"signed\",void 0,prefix,argument);return x};webidl.converters[\"unsigned long long\"]=function(V,prefix,argument){const x=webidl.util.ConvertToInt(V,64,\"unsigned\",void 0,prefix,argument);return x};webidl.converters[\"unsigned long\"]=function(V,prefix,argument){const x=webidl.util.ConvertToInt(V,32,\"unsigned\",void 0,prefix,argument);return x};webidl.converters[\"unsigned short\"]=function(V,prefix,argument,opts){const x=webidl.util.ConvertToInt(V,16,\"unsigned\",opts,prefix,argument);return x};webidl.converters.ArrayBuffer=function(V,prefix,argument,opts){if(webidl.util.Type(V)!==\"Object\"||!types.isAnyArrayBuffer(V)){throw webidl.errors.conversionFailed({prefix,argument:`${argument} (\"${webidl.util.Stringify(V)}\")`,types:[\"ArrayBuffer\"]})}if(opts?.allowShared===false&&types.isSharedArrayBuffer(V)){throw webidl.errors.exception({header:\"ArrayBuffer\",message:\"SharedArrayBuffer is not allowed.\"})}if(V.resizable||V.growable){throw webidl.errors.exception({header:\"ArrayBuffer\",message:\"Received a resizable ArrayBuffer.\"})}return V};webidl.converters.TypedArray=function(V,T,prefix,name,opts){if(webidl.util.Type(V)!==\"Object\"||!types.isTypedArray(V)||V.constructor.name!==T.name){throw webidl.errors.conversionFailed({prefix,argument:`${name} (\"${webidl.util.Stringify(V)}\")`,types:[T.name]})}if(opts?.allowShared===false&&types.isSharedArrayBuffer(V.buffer)){throw webidl.errors.exception({header:\"ArrayBuffer\",message:\"SharedArrayBuffer is not allowed.\"})}if(V.buffer.resizable||V.buffer.growable){throw webidl.errors.exception({header:\"ArrayBuffer\",message:\"Received a resizable ArrayBuffer.\"})}return V};webidl.converters.DataView=function(V,prefix,name,opts){if(webidl.util.Type(V)!==\"Object\"||!types.isDataView(V)){throw webidl.errors.exception({header:prefix,message:`${name} is not a DataView.`})}if(opts?.allowShared===false&&types.isSharedArrayBuffer(V.buffer)){throw webidl.errors.exception({header:\"ArrayBuffer\",message:\"SharedArrayBuffer is not allowed.\"})}if(V.buffer.resizable||V.buffer.growable){throw webidl.errors.exception({header:\"ArrayBuffer\",message:\"Received a resizable ArrayBuffer.\"})}return V};webidl.converters.BufferSource=function(V,prefix,name,opts){if(types.isAnyArrayBuffer(V)){return webidl.converters.ArrayBuffer(V,prefix,name,{...opts,allowShared:false})}if(types.isTypedArray(V)){return webidl.converters.TypedArray(V,V.constructor,prefix,name,{...opts,allowShared:false})}if(types.isDataView(V)){return webidl.converters.DataView(V,prefix,name,{...opts,allowShared:false})}throw webidl.errors.conversionFailed({prefix,argument:`${name} (\"${webidl.util.Stringify(V)}\")`,types:[\"BufferSource\"]})};webidl.converters[\"sequence<ByteString>\"]=webidl.sequenceConverter(webidl.converters.ByteString);webidl.converters[\"sequence<sequence<ByteString>>\"]=webidl.sequenceConverter(webidl.converters[\"sequence<ByteString>\"]);webidl.converters[\"record<ByteString, ByteString>\"]=webidl.recordConverter(webidl.converters.ByteString,webidl.converters.ByteString);module.exports={webidl};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["keys"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/fetch/webidl.js"],"sourcesContent":["'use strict'\n\nconst { types, inspect } = require('node:util')\nconst { markAsUncloneable } = require('node:worker_threads')\nconst { toUSVString } = require('../../core/util')\n\n/** @type {import('../../../types/webidl').Webidl} */\nconst webidl = {}\nwebidl.converters = {}\nwebidl.util = {}\nwebidl.errors = {}\n\nwebidl.errors.exception = function (message) {\n  return new TypeError(`${message.header}: ${message.message}`)\n}\n\nwebidl.errors.conversionFailed = function (context) {\n  const plural = context.types.length === 1 ? '' : ' one of'\n  const message =\n    `${context.argument} could not be converted to` +\n    `${plural}: ${context.types.join(', ')}.`\n\n  return webidl.errors.exception({\n    header: context.prefix,\n    message\n  })\n}\n\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  })\n}\n\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function (V, I, opts) {\n  if (opts?.strict !== false) {\n    if (!(V instanceof I)) {\n      const err = new TypeError('Illegal invocation')\n      err.code = 'ERR_INVALID_THIS' // node compat.\n      throw err\n    }\n  } else {\n    if (V?.[Symbol.toStringTag] !== I.prototype[Symbol.toStringTag]) {\n      const err = new TypeError('Illegal invocation')\n      err.code = 'ERR_INVALID_THIS' // node compat.\n      throw err\n    }\n  }\n}\n\nwebidl.argumentLengthCheck = function ({ length }, min, ctx) {\n  if (length < min) {\n    throw webidl.errors.exception({\n      message: `${min} argument${min !== 1 ? 's' : ''} required, ` +\n               `but${length ? ' only' : ''} ${length} found.`,\n      header: ctx\n    })\n  }\n}\n\nwebidl.illegalConstructor = function () {\n  throw webidl.errors.exception({\n    header: 'TypeError',\n    message: 'Illegal constructor'\n  })\n}\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined': return 'Undefined'\n    case 'boolean': return 'Boolean'\n    case 'string': return 'String'\n    case 'symbol': return 'Symbol'\n    case 'number': return 'Number'\n    case 'bigint': return 'BigInt'\n    case 'function':\n    case 'object': {\n      if (V === null) {\n        return 'Null'\n      }\n\n      return 'Object'\n    }\n  }\n}\n\nwebidl.util.markAsUncloneable = markAsUncloneable || (() => {})\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness, opts) {\n  let upperBound\n  let lowerBound\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53 − 1.\n    upperBound = Math.pow(2, 53) - 1\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0\n    } else {\n      // 3. Otherwise let lowerBound be −2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0\n\n    // 2. Let upperBound be 2^bitLength − 1.\n    upperBound = Math.pow(2, bitLength) - 1\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength − 1.\n    lowerBound = Math.pow(-2, bitLength) - 1\n\n    // 2. Let upperBound be 2^bitLength − 1 − 1.\n    upperBound = Math.pow(2, bitLength - 1) - 1\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V)\n\n  // 5. If x is −0, then set x to +0.\n  if (x === 0) {\n    x = 0\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (opts?.enforceRange === true) {\n    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n    if (\n      Number.isNaN(x) ||\n      x === Number.POSITIVE_INFINITY ||\n      x === Number.NEGATIVE_INFINITY\n    ) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`\n      })\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x)\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      })\n    }\n\n    // 4. Return x.\n    return x\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && opts?.clamp === true) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound)\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than −0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x)\n    } else {\n      x = Math.ceil(x)\n    }\n\n    // 3. Return x.\n    return x\n  }\n\n  // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n  if (\n    Number.isNaN(x) ||\n    (x === 0 && Object.is(0, x)) ||\n    x === Number.POSITIVE_INFINITY ||\n    x === Number.NEGATIVE_INFINITY\n  ) {\n    return 0\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x)\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength)\n\n  // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n  //    then return x − 2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength)\n  }\n\n  // 12. Otherwise, return x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n))\n\n  // 2. If n < 0, then return -1 × r.\n  if (n < 0) {\n    return -1 * r\n  }\n\n  // 3. Otherwise, return r.\n  return r\n}\n\nwebidl.util.Stringify = function (V) {\n  const type = webidl.util.Type(V)\n\n  switch (type) {\n    case 'Symbol':\n      return `Symbol(${V.description})`\n    case 'Object':\n      return inspect(V)\n    case 'String':\n      return `\"${V}\"`\n    default:\n      return `${V}`\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return (V, prefix, argument, Iterable) => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`\n      })\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = typeof Iterable === 'function' ? Iterable() : V?.[Symbol.iterator]?.()\n    const seq = []\n    let index = 0\n\n    // 3. If method is undefined, throw a TypeError.\n    if (\n      method === undefined ||\n      typeof method.next !== 'function'\n    ) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} is not iterable.`\n      })\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const { done, value } = method.next()\n\n      if (done) {\n        break\n      }\n\n      seq.push(converter(value, prefix, `${argument}[${index++}]`))\n    }\n\n    return seq\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return (O, prefix, argument) => {\n    // 1. If Type(O) is not Object, throw a TypeError.\n    if (webidl.util.Type(O) !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (\"${webidl.util.Type(O)}\") is not an Object.`\n      })\n    }\n\n    // 2. Let result be a new empty instance of record<K, V>.\n    const result = {}\n\n    if (!types.isProxy(O)) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const keys = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)]\n\n      for (const key of keys) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, argument)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, argument)\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n\n      // 5. Return result.\n      return result\n    }\n\n    // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n    const keys = Reflect.ownKeys(O)\n\n    // 4. For each key of keys.\n    for (const key of keys) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const desc = Reflect.getOwnPropertyDescriptor(O, key)\n\n      // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n      if (desc?.enumerable) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, argument)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, argument)\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n    }\n\n    // 5. Return result.\n    return result\n  }\n}\n\nwebidl.interfaceConverter = function (i) {\n  return (V, prefix, argument, opts) => {\n    if (opts?.strict !== false && !(V instanceof i)) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${argument} (\"${webidl.util.Stringify(V)}\") to be an instance of ${i.name}.`\n      })\n    }\n\n    return V\n  }\n}\n\nwebidl.dictionaryConverter = function (converters) {\n  return (dictionary, prefix, argument) => {\n    const type = webidl.util.Type(dictionary)\n    const dict = {}\n\n    if (type === 'Null' || type === 'Undefined') {\n      return dict\n    } else if (type !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      })\n    }\n\n    for (const options of converters) {\n      const { key, defaultValue, required, converter } = options\n\n      if (required === true) {\n        if (!Object.hasOwn(dictionary, key)) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `Missing required key \"${key}\".`\n          })\n        }\n      }\n\n      let value = dictionary[key]\n      const hasDefault = Object.hasOwn(options, 'defaultValue')\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value !== null) {\n        value ??= defaultValue()\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value, prefix, `${argument}.${key}`)\n\n        if (\n          options.allowedValues &&\n          !options.allowedValues.includes(value)\n        ) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          })\n        }\n\n        dict[key] = value\n      }\n    }\n\n    return dict\n  }\n}\n\nwebidl.nullableConverter = function (converter) {\n  return (V, prefix, argument) => {\n    if (V === null) {\n      return V\n    }\n\n    return converter(V, prefix, argument)\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V, prefix, argument, opts) {\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && opts?.legacyNullToEmptyString) {\n    return ''\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} is a symbol, which cannot be converted to a DOMString.`\n    })\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V)\n}\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V, prefix, argument) {\n  // 1. Let x be ? ToString(V).\n  // Note: DOMString converter perform ? ToString(V)\n  const x = webidl.converters.DOMString(V, prefix, argument)\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    if (x.charCodeAt(index) > 255) {\n      throw new TypeError(\n        'Cannot convert argument to a ByteString because the character at ' +\n        `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`\n      )\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-USVString\n// TODO: rewrite this so we can control the errors thrown\nwebidl.converters.USVString = toUSVString\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  const x = Boolean(V)\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed', undefined, prefix, argument)\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters['unsigned long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 64, 'unsigned', undefined, prefix, argument)\n\n  // 2. Return the IDL unsigned long long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters['unsigned long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 32, 'unsigned', undefined, prefix, argument)\n\n  // 2. Return the IDL unsigned long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V, prefix, argument, opts) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts, prefix, argument)\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V, prefix, argument, opts) {\n  // 1. If Type(V) is not Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isAnyArrayBuffer(V)\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: ['ArrayBuffer']\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (V.resizable || V.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V\n}\n\nwebidl.converters.TypedArray = function (V, T, prefix, name, opts) {\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to T’s name, then throw a TypeError.\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isTypedArray(V) ||\n    V.constructor.name !== T.name\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n      types: [T.name]\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (V.buffer.resizable || V.buffer.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V\n}\n\nwebidl.converters.DataView = function (V, prefix, name, opts) {\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${name} is not a DataView.`\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (V.buffer.resizable || V.buffer.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function (V, prefix, name, opts) {\n  if (types.isAnyArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, prefix, name, { ...opts, allowShared: false })\n  }\n\n  if (types.isTypedArray(V)) {\n    return webidl.converters.TypedArray(V, V.constructor, prefix, name, { ...opts, allowShared: false })\n  }\n\n  if (types.isDataView(V)) {\n    return webidl.converters.DataView(V, prefix, name, { ...opts, allowShared: false })\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix,\n    argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n    types: ['BufferSource']\n  })\n}\n\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(\n  webidl.converters.ByteString\n)\n\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(\n  webidl.converters['sequence<ByteString>']\n)\n\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(\n  webidl.converters.ByteString,\n  webidl.converters.ByteString\n)\n\nmodule.exports = {\n  webidl\n}\n"]}}