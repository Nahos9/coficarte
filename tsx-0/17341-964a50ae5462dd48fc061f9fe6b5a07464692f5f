{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{kClients}=require(\"../core/symbols\");const Agent=require(\"../dispatcher/agent\");const{kAgent,kMockAgentSet,kMockAgentGet,kDispatches,kIsMockActive,kNetConnect,kGetNetConnect,kOptions,kFactory}=require(\"./mock-symbols\");const MockClient=require(\"./mock-client\");const MockPool=require(\"./mock-pool\");const{matchValue,buildMockOptions}=require(\"./mock-utils\");const{InvalidArgumentError,UndiciError}=require(\"../core/errors\");const Dispatcher=require(\"../dispatcher/dispatcher\");const Pluralizer=require(\"./pluralizer\");const PendingInterceptorsFormatter=require(\"./pending-interceptors-formatter\");class MockAgent extends Dispatcher{static{__name(this,\"MockAgent\")}constructor(opts){super(opts);this[kNetConnect]=true;this[kIsMockActive]=true;if(opts?.agent&&typeof opts.agent.dispatch!==\"function\"){throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\")}const agent=opts?.agent?opts.agent:new Agent(opts);this[kAgent]=agent;this[kClients]=agent[kClients];this[kOptions]=buildMockOptions(opts)}get(origin){let dispatcher=this[kMockAgentGet](origin);if(!dispatcher){dispatcher=this[kFactory](origin);this[kMockAgentSet](origin,dispatcher)}return dispatcher}dispatch(opts,handler){this.get(opts.origin);return this[kAgent].dispatch(opts,handler)}async close(){await this[kAgent].close();this[kClients].clear()}deactivate(){this[kIsMockActive]=false}activate(){this[kIsMockActive]=true}enableNetConnect(matcher){if(typeof matcher===\"string\"||typeof matcher===\"function\"||matcher instanceof RegExp){if(Array.isArray(this[kNetConnect])){this[kNetConnect].push(matcher)}else{this[kNetConnect]=[matcher]}}else if(typeof matcher===\"undefined\"){this[kNetConnect]=true}else{throw new InvalidArgumentError(\"Unsupported matcher. Must be one of String|Function|RegExp.\")}}disableNetConnect(){this[kNetConnect]=false}get isMockActive(){return this[kIsMockActive]}[kMockAgentSet](origin,dispatcher){this[kClients].set(origin,dispatcher)}[kFactory](origin){const mockOptions=Object.assign({agent:this},this[kOptions]);return this[kOptions]&&this[kOptions].connections===1?new MockClient(origin,mockOptions):new MockPool(origin,mockOptions)}[kMockAgentGet](origin){const client=this[kClients].get(origin);if(client){return client}if(typeof origin!==\"string\"){const dispatcher=this[kFactory](\"http://localhost:9999\");this[kMockAgentSet](origin,dispatcher);return dispatcher}for(const[keyMatcher,nonExplicitDispatcher]of Array.from(this[kClients])){if(nonExplicitDispatcher&&typeof keyMatcher!==\"string\"&&matchValue(keyMatcher,origin)){const dispatcher=this[kFactory](origin);this[kMockAgentSet](origin,dispatcher);dispatcher[kDispatches]=nonExplicitDispatcher[kDispatches];return dispatcher}}}[kGetNetConnect](){return this[kNetConnect]}pendingInterceptors(){const mockAgentClients=this[kClients];return Array.from(mockAgentClients.entries()).flatMap(([origin,scope])=>scope[kDispatches].map(dispatch=>({...dispatch,origin}))).filter(({pending})=>pending)}assertNoPendingInterceptors({pendingInterceptorsFormatter=new PendingInterceptorsFormatter}={}){const pending=this.pendingInterceptors();if(pending.length===0){return}const pluralizer=new Pluralizer(\"interceptor\",\"interceptors\").pluralize(pending.length);throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim())}}module.exports=MockAgent;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/mock/mock-agent.js"],"sourcesContent":["'use strict'\n\nconst { kClients } = require('../core/symbols')\nconst Agent = require('../dispatcher/agent')\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory\n} = require('./mock-symbols')\nconst MockClient = require('./mock-client')\nconst MockPool = require('./mock-pool')\nconst { matchValue, buildMockOptions } = require('./mock-utils')\nconst { InvalidArgumentError, UndiciError } = require('../core/errors')\nconst Dispatcher = require('../dispatcher/dispatcher')\nconst Pluralizer = require('./pluralizer')\nconst PendingInterceptorsFormatter = require('./pending-interceptors-formatter')\n\nclass MockAgent extends Dispatcher {\n  constructor (opts) {\n    super(opts)\n\n    this[kNetConnect] = true\n    this[kIsMockActive] = true\n\n    // Instantiate Agent and encapsulate\n    if ((opts?.agent && typeof opts.agent.dispatch !== 'function')) {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n    const agent = opts?.agent ? opts.agent : new Agent(opts)\n    this[kAgent] = agent\n\n    this[kClients] = agent[kClients]\n    this[kOptions] = buildMockOptions(opts)\n  }\n\n  get (origin) {\n    let dispatcher = this[kMockAgentGet](origin)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](origin)\n      this[kMockAgentSet](origin, dispatcher)\n    }\n    return dispatcher\n  }\n\n  dispatch (opts, handler) {\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin)\n    return this[kAgent].dispatch(opts, handler)\n  }\n\n  async close () {\n    await this[kAgent].close()\n    this[kClients].clear()\n  }\n\n  deactivate () {\n    this[kIsMockActive] = false\n  }\n\n  activate () {\n    this[kIsMockActive] = true\n  }\n\n  enableNetConnect (matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher)\n      } else {\n        this[kNetConnect] = [matcher]\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')\n    }\n  }\n\n  disableNetConnect () {\n    this[kNetConnect] = false\n  }\n\n  // This is required to bypass issues caused by using global symbols - see:\n  // https://github.com/nodejs/undici/issues/1447\n  get isMockActive () {\n    return this[kIsMockActive]\n  }\n\n  [kMockAgentSet] (origin, dispatcher) {\n    this[kClients].set(origin, dispatcher)\n  }\n\n  [kFactory] (origin) {\n    const mockOptions = Object.assign({ agent: this }, this[kOptions])\n    return this[kOptions] && this[kOptions].connections === 1\n      ? new MockClient(origin, mockOptions)\n      : new MockPool(origin, mockOptions)\n  }\n\n  [kMockAgentGet] (origin) {\n    // First check if we can immediately find it\n    const client = this[kClients].get(origin)\n    if (client) {\n      return client\n    }\n\n    // If the origin is not a string create a dummy parent pool and return to user\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999')\n      this[kMockAgentSet](origin, dispatcher)\n      return dispatcher\n    }\n\n    // If we match, create a pool and assign the same dispatches\n    for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients])) {\n      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin)\n        this[kMockAgentSet](origin, dispatcher)\n        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches]\n        return dispatcher\n      }\n    }\n  }\n\n  [kGetNetConnect] () {\n    return this[kNetConnect]\n  }\n\n  pendingInterceptors () {\n    const mockAgentClients = this[kClients]\n\n    return Array.from(mockAgentClients.entries())\n      .flatMap(([origin, scope]) => scope[kDispatches].map(dispatch => ({ ...dispatch, origin })))\n      .filter(({ pending }) => pending)\n  }\n\n  assertNoPendingInterceptors ({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n    const pending = this.pendingInterceptors()\n\n    if (pending.length === 0) {\n      return\n    }\n\n    const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length)\n\n    throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim())\n  }\n}\n\nmodule.exports = MockAgent\n"]}}