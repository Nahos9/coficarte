{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{kReadyState,kController,kResponse,kBinaryType,kWebSocketURL}=require(\"./symbols\");const{states,opcodes}=require(\"./constants\");const{ErrorEvent,createFastMessageEvent}=require(\"./events\");const{isUtf8}=require(\"node:buffer\");const{collectASequenceOfCodePointsFast,removeHTTPWhitespace}=require(\"../fetch/data-url\");function isConnecting(ws){return ws[kReadyState]===states.CONNECTING}__name(isConnecting,\"isConnecting\");function isEstablished(ws){return ws[kReadyState]===states.OPEN}__name(isEstablished,\"isEstablished\");function isClosing(ws){return ws[kReadyState]===states.CLOSING}__name(isClosing,\"isClosing\");function isClosed(ws){return ws[kReadyState]===states.CLOSED}__name(isClosed,\"isClosed\");function fireEvent(e,target,eventFactory=(type,init)=>new Event(type,init),eventInitDict={}){const event=eventFactory(e,eventInitDict);target.dispatchEvent(event)}__name(fireEvent,\"fireEvent\");function websocketMessageReceived(ws,type,data){if(ws[kReadyState]!==states.OPEN){return}let dataForEvent;if(type===opcodes.TEXT){try{dataForEvent=utf8Decode(data)}catch{failWebsocketConnection(ws,\"Received invalid UTF-8 in text frame.\");return}}else if(type===opcodes.BINARY){if(ws[kBinaryType]===\"blob\"){dataForEvent=new Blob([data])}else{dataForEvent=toArrayBuffer(data)}}fireEvent(\"message\",ws,createFastMessageEvent,{origin:ws[kWebSocketURL].origin,data:dataForEvent})}__name(websocketMessageReceived,\"websocketMessageReceived\");function toArrayBuffer(buffer){if(buffer.byteLength===buffer.buffer.byteLength){return buffer.buffer}return buffer.buffer.slice(buffer.byteOffset,buffer.byteOffset+buffer.byteLength)}__name(toArrayBuffer,\"toArrayBuffer\");function isValidSubprotocol(protocol){if(protocol.length===0){return false}for(let i=0;i<protocol.length;++i){const code=protocol.charCodeAt(i);if(code<33||code>126||code===34||code===40||code===41||code===44||code===47||code===58||code===59||code===60||code===61||code===62||code===63||code===64||code===91||code===92||code===93||code===123||code===125){return false}}return true}__name(isValidSubprotocol,\"isValidSubprotocol\");function isValidStatusCode(code){if(code>=1e3&&code<1015){return code!==1004&&code!==1005&&code!==1006}return code>=3e3&&code<=4999}__name(isValidStatusCode,\"isValidStatusCode\");function failWebsocketConnection(ws,reason){const{[kController]:controller,[kResponse]:response}=ws;controller.abort();if(response?.socket&&!response.socket.destroyed){response.socket.destroy()}if(reason){fireEvent(\"error\",ws,(type,init)=>new ErrorEvent(type,init),{error:new Error(reason),message:reason})}}__name(failWebsocketConnection,\"failWebsocketConnection\");function isControlFrame(opcode){return opcode===opcodes.CLOSE||opcode===opcodes.PING||opcode===opcodes.PONG}__name(isControlFrame,\"isControlFrame\");function isContinuationFrame(opcode){return opcode===opcodes.CONTINUATION}__name(isContinuationFrame,\"isContinuationFrame\");function isTextBinaryFrame(opcode){return opcode===opcodes.TEXT||opcode===opcodes.BINARY}__name(isTextBinaryFrame,\"isTextBinaryFrame\");function isValidOpcode(opcode){return isTextBinaryFrame(opcode)||isContinuationFrame(opcode)||isControlFrame(opcode)}__name(isValidOpcode,\"isValidOpcode\");function parseExtensions(extensions){const position={position:0};const extensionList=new Map;while(position.position<extensions.length){const pair=collectASequenceOfCodePointsFast(\";\",extensions,position);const[name,value=\"\"]=pair.split(\"=\");extensionList.set(removeHTTPWhitespace(name,true,false),removeHTTPWhitespace(value,false,true));position.position++}return extensionList}__name(parseExtensions,\"parseExtensions\");function isValidClientWindowBits(value){for(let i=0;i<value.length;i++){const byte=value.charCodeAt(i);if(byte<48||byte>57){return false}}return true}__name(isValidClientWindowBits,\"isValidClientWindowBits\");const hasIntl=typeof process.versions.icu===\"string\";const fatalDecoder=hasIntl?new TextDecoder(\"utf-8\",{fatal:true}):void 0;const utf8Decode=hasIntl?fatalDecoder.decode.bind(fatalDecoder):function(buffer){if(isUtf8(buffer)){return buffer.toString(\"utf-8\")}throw new TypeError(\"Invalid utf-8 received.\")};module.exports={isConnecting,isEstablished,isClosing,isClosed,fireEvent,isValidSubprotocol,isValidStatusCode,failWebsocketConnection,websocketMessageReceived,utf8Decode,isControlFrame,isContinuationFrame,isTextBinaryFrame,isValidOpcode,parseExtensions,isValidClientWindowBits};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/websocket/util.js"],"sourcesContent":["'use strict'\n\nconst { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require('./symbols')\nconst { states, opcodes } = require('./constants')\nconst { ErrorEvent, createFastMessageEvent } = require('./events')\nconst { isUtf8 } = require('node:buffer')\nconst { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = require('../fetch/data-url')\n\n/* globals Blob */\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isConnecting (ws) {\n  // If the WebSocket connection is not yet established, and the connection\n  // is not yet closed, then the WebSocket connection is in the CONNECTING state.\n  return ws[kReadyState] === states.CONNECTING\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isEstablished (ws) {\n  // If the server's response is validated as provided for above, it is\n  // said that _The WebSocket Connection is Established_ and that the\n  // WebSocket Connection is in the OPEN state.\n  return ws[kReadyState] === states.OPEN\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isClosing (ws) {\n  // Upon either sending or receiving a Close control frame, it is said\n  // that _The WebSocket Closing Handshake is Started_ and that the\n  // WebSocket connection is in the CLOSING state.\n  return ws[kReadyState] === states.CLOSING\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isClosed (ws) {\n  return ws[kReadyState] === states.CLOSED\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {(...args: ConstructorParameters<typeof Event>) => Event} eventFactory\n * @param {EventInit | undefined} eventInitDict\n */\nfunction fireEvent (e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {\n  // 1. If eventConstructor is not given, then let eventConstructor be Event.\n\n  // 2. Let event be the result of creating an event given eventConstructor,\n  //    in the relevant realm of target.\n  // 3. Initialize event’s type attribute to e.\n  const event = eventFactory(e, eventInitDict)\n\n  // 4. Initialize any other IDL attributes of event as described in the\n  //    invocation of this algorithm.\n\n  // 5. Return the result of dispatching event at target, with legacy target\n  //    override flag set if set.\n  target.dispatchEvent(event)\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */\nfunction websocketMessageReceived (ws, type, data) {\n  // 1. If ready state is not OPEN (1), then return.\n  if (ws[kReadyState] !== states.OPEN) {\n    return\n  }\n\n  // 2. Let dataForEvent be determined by switching on type and binary type:\n  let dataForEvent\n\n  if (type === opcodes.TEXT) {\n    // -> type indicates that the data is Text\n    //      a new DOMString containing data\n    try {\n      dataForEvent = utf8Decode(data)\n    } catch {\n      failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.')\n      return\n    }\n  } else if (type === opcodes.BINARY) {\n    if (ws[kBinaryType] === 'blob') {\n      // -> type indicates that the data is Binary and binary type is \"blob\"\n      //      a new Blob object, created in the relevant Realm of the WebSocket\n      //      object, that represents data as its raw data\n      dataForEvent = new Blob([data])\n    } else {\n      // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n      //      a new ArrayBuffer object, created in the relevant Realm of the\n      //      WebSocket object, whose contents are data\n      dataForEvent = toArrayBuffer(data)\n    }\n  }\n\n  // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n  //    with the origin attribute initialized to the serialization of the WebSocket\n  //    object’s url's origin, and the data attribute initialized to dataForEvent.\n  fireEvent('message', ws, createFastMessageEvent, {\n    origin: ws[kWebSocketURL].origin,\n    data: dataForEvent\n  })\n}\n\nfunction toArrayBuffer (buffer) {\n  if (buffer.byteLength === buffer.buffer.byteLength) {\n    return buffer.buffer\n  }\n  return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength)\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */\nfunction isValidSubprotocol (protocol) {\n  // If present, this value indicates one\n  // or more comma-separated subprotocol the client wishes to speak,\n  // ordered by preference.  The elements that comprise this value\n  // MUST be non-empty strings with characters in the range U+0021 to\n  // U+007E not including separator characters as defined in\n  // [RFC2616] and MUST all be unique strings.\n  if (protocol.length === 0) {\n    return false\n  }\n\n  for (let i = 0; i < protocol.length; ++i) {\n    const code = protocol.charCodeAt(i)\n\n    if (\n      code < 0x21 || // CTL, contains SP (0x20) and HT (0x09)\n      code > 0x7E ||\n      code === 0x22 || // \"\n      code === 0x28 || // (\n      code === 0x29 || // )\n      code === 0x2C || // ,\n      code === 0x2F || // /\n      code === 0x3A || // :\n      code === 0x3B || // ;\n      code === 0x3C || // <\n      code === 0x3D || // =\n      code === 0x3E || // >\n      code === 0x3F || // ?\n      code === 0x40 || // @\n      code === 0x5B || // [\n      code === 0x5C || // \\\n      code === 0x5D || // ]\n      code === 0x7B || // {\n      code === 0x7D // }\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */\nfunction isValidStatusCode (code) {\n  if (code >= 1000 && code < 1015) {\n    return (\n      code !== 1004 && // reserved\n      code !== 1005 && // \"MUST NOT be set as a status code\"\n      code !== 1006 // \"MUST NOT be set as a status code\"\n    )\n  }\n\n  return code >= 3000 && code <= 4999\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */\nfunction failWebsocketConnection (ws, reason) {\n  const { [kController]: controller, [kResponse]: response } = ws\n\n  controller.abort()\n\n  if (response?.socket && !response.socket.destroyed) {\n    response.socket.destroy()\n  }\n\n  if (reason) {\n    // TODO: process.nextTick\n    fireEvent('error', ws, (type, init) => new ErrorEvent(type, init), {\n      error: new Error(reason),\n      message: reason\n    })\n  }\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-5.5\n * @param {number} opcode\n */\nfunction isControlFrame (opcode) {\n  return (\n    opcode === opcodes.CLOSE ||\n    opcode === opcodes.PING ||\n    opcode === opcodes.PONG\n  )\n}\n\nfunction isContinuationFrame (opcode) {\n  return opcode === opcodes.CONTINUATION\n}\n\nfunction isTextBinaryFrame (opcode) {\n  return opcode === opcodes.TEXT || opcode === opcodes.BINARY\n}\n\nfunction isValidOpcode (opcode) {\n  return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode)\n}\n\n/**\n * Parses a Sec-WebSocket-Extensions header value.\n * @param {string} extensions\n * @returns {Map<string, string>}\n */\n// TODO(@Uzlopak, @KhafraDev): make compliant https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\nfunction parseExtensions (extensions) {\n  const position = { position: 0 }\n  const extensionList = new Map()\n\n  while (position.position < extensions.length) {\n    const pair = collectASequenceOfCodePointsFast(';', extensions, position)\n    const [name, value = ''] = pair.split('=')\n\n    extensionList.set(\n      removeHTTPWhitespace(name, true, false),\n      removeHTTPWhitespace(value, false, true)\n    )\n\n    position.position++\n  }\n\n  return extensionList\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7692#section-7.1.2.2\n * @description \"client-max-window-bits = 1*DIGIT\"\n * @param {string} value\n */\nfunction isValidClientWindowBits (value) {\n  for (let i = 0; i < value.length; i++) {\n    const byte = value.charCodeAt(i)\n\n    if (byte < 0x30 || byte > 0x39) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// https://nodejs.org/api/intl.html#detecting-internationalization-support\nconst hasIntl = typeof process.versions.icu === 'string'\nconst fatalDecoder = hasIntl ? new TextDecoder('utf-8', { fatal: true }) : undefined\n\n/**\n * Converts a Buffer to utf-8, even on platforms without icu.\n * @param {Buffer} buffer\n */\nconst utf8Decode = hasIntl\n  ? fatalDecoder.decode.bind(fatalDecoder)\n  : function (buffer) {\n    if (isUtf8(buffer)) {\n      return buffer.toString('utf-8')\n    }\n    throw new TypeError('Invalid utf-8 received.')\n  }\n\nmodule.exports = {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isClosed,\n  fireEvent,\n  isValidSubprotocol,\n  isValidStatusCode,\n  failWebsocketConnection,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isContinuationFrame,\n  isTextBinaryFrame,\n  isValidOpcode,\n  parseExtensions,\n  isValidClientWindowBits\n}\n"]}}