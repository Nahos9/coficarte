{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{pipeline}=require(\"node:stream\");const{fetching}=require(\"../fetch\");const{makeRequest}=require(\"../fetch/request\");const{webidl}=require(\"../fetch/webidl\");const{EventSourceStream}=require(\"./eventsource-stream\");const{parseMIMEType}=require(\"../fetch/data-url\");const{createFastMessageEvent}=require(\"../websocket/events\");const{isNetworkError}=require(\"../fetch/response\");const{delay}=require(\"./util\");const{kEnumerableProperty}=require(\"../../core/util\");const{environmentSettingsObject}=require(\"../fetch/util\");let experimentalWarned=false;const defaultReconnectionTime=3e3;const CONNECTING=0;const OPEN=1;const CLOSED=2;const ANONYMOUS=\"anonymous\";const USE_CREDENTIALS=\"use-credentials\";class EventSource extends EventTarget{static{__name(this,\"EventSource\")}#events={open:null,error:null,message:null};#url=null;#withCredentials=false;#readyState=CONNECTING;#request=null;#controller=null;#dispatcher;#state;constructor(url,eventSourceInitDict={}){super();webidl.util.markAsUncloneable(this);const prefix=\"EventSource constructor\";webidl.argumentLengthCheck(arguments,1,prefix);if(!experimentalWarned){experimentalWarned=true;process.emitWarning(\"EventSource is experimental, expect them to change at any time.\",{code:\"UNDICI-ES\"})}url=webidl.converters.USVString(url,prefix,\"url\");eventSourceInitDict=webidl.converters.EventSourceInitDict(eventSourceInitDict,prefix,\"eventSourceInitDict\");this.#dispatcher=eventSourceInitDict.dispatcher;this.#state={lastEventId:\"\",reconnectionTime:defaultReconnectionTime};const settings=environmentSettingsObject;let urlRecord;try{urlRecord=new URL(url,settings.settingsObject.baseUrl);this.#state.origin=urlRecord.origin}catch(e){throw new DOMException(e,\"SyntaxError\")}this.#url=urlRecord.href;let corsAttributeState=ANONYMOUS;if(eventSourceInitDict.withCredentials){corsAttributeState=USE_CREDENTIALS;this.#withCredentials=true}const initRequest={redirect:\"follow\",keepalive:true,mode:\"cors\",credentials:corsAttributeState===\"anonymous\"?\"same-origin\":\"omit\",referrer:\"no-referrer\"};initRequest.client=environmentSettingsObject.settingsObject;initRequest.headersList=[[\"accept\",{name:\"accept\",value:\"text/event-stream\"}]];initRequest.cache=\"no-store\";initRequest.initiator=\"other\";initRequest.urlList=[new URL(this.#url)];this.#request=makeRequest(initRequest);this.#connect()}get readyState(){return this.#readyState}get url(){return this.#url}get withCredentials(){return this.#withCredentials}#connect(){if(this.#readyState===CLOSED)return;this.#readyState=CONNECTING;const fetchParams={request:this.#request,dispatcher:this.#dispatcher};const processEventSourceEndOfBody=__name(response=>{if(isNetworkError(response)){this.dispatchEvent(new Event(\"error\"));this.close()}this.#reconnect()},\"processEventSourceEndOfBody\");fetchParams.processResponseEndOfBody=processEventSourceEndOfBody;fetchParams.processResponse=response=>{if(isNetworkError(response)){if(response.aborted){this.close();this.dispatchEvent(new Event(\"error\"));return}else{this.#reconnect();return}}const contentType=response.headersList.get(\"content-type\",true);const mimeType=contentType!==null?parseMIMEType(contentType):\"failure\";const contentTypeValid=mimeType!==\"failure\"&&mimeType.essence===\"text/event-stream\";if(response.status!==200||contentTypeValid===false){this.close();this.dispatchEvent(new Event(\"error\"));return}this.#readyState=OPEN;this.dispatchEvent(new Event(\"open\"));this.#state.origin=response.urlList[response.urlList.length-1].origin;const eventSourceStream=new EventSourceStream({eventSourceSettings:this.#state,push:event=>{this.dispatchEvent(createFastMessageEvent(event.type,event.options))}});pipeline(response.body.stream,eventSourceStream,error=>{if(error?.aborted===false){this.close();this.dispatchEvent(new Event(\"error\"))}})};this.#controller=fetching(fetchParams)}async#reconnect(){if(this.#readyState===CLOSED)return;this.#readyState=CONNECTING;this.dispatchEvent(new Event(\"error\"));await delay(this.#state.reconnectionTime);if(this.#readyState!==CONNECTING)return;if(this.#state.lastEventId.length){this.#request.headersList.set(\"last-event-id\",this.#state.lastEventId,true)}this.#connect()}close(){webidl.brandCheck(this,EventSource);if(this.#readyState===CLOSED)return;this.#readyState=CLOSED;this.#controller.abort();this.#request=null}get onopen(){return this.#events.open}set onopen(fn){if(this.#events.open){this.removeEventListener(\"open\",this.#events.open)}if(typeof fn===\"function\"){this.#events.open=fn;this.addEventListener(\"open\",fn)}else{this.#events.open=null}}get onmessage(){return this.#events.message}set onmessage(fn){if(this.#events.message){this.removeEventListener(\"message\",this.#events.message)}if(typeof fn===\"function\"){this.#events.message=fn;this.addEventListener(\"message\",fn)}else{this.#events.message=null}}get onerror(){return this.#events.error}set onerror(fn){if(this.#events.error){this.removeEventListener(\"error\",this.#events.error)}if(typeof fn===\"function\"){this.#events.error=fn;this.addEventListener(\"error\",fn)}else{this.#events.error=null}}}const constantsPropertyDescriptors={CONNECTING:{__proto__:null,configurable:false,enumerable:true,value:CONNECTING,writable:false},OPEN:{__proto__:null,configurable:false,enumerable:true,value:OPEN,writable:false},CLOSED:{__proto__:null,configurable:false,enumerable:true,value:CLOSED,writable:false}};Object.defineProperties(EventSource,constantsPropertyDescriptors);Object.defineProperties(EventSource.prototype,constantsPropertyDescriptors);Object.defineProperties(EventSource.prototype,{close:kEnumerableProperty,onerror:kEnumerableProperty,onmessage:kEnumerableProperty,onopen:kEnumerableProperty,readyState:kEnumerableProperty,url:kEnumerableProperty,withCredentials:kEnumerableProperty});webidl.converters.EventSourceInitDict=webidl.dictionaryConverter([{key:\"withCredentials\",converter:webidl.converters.boolean,defaultValue:()=>false},{key:\"dispatcher\",converter:webidl.converters.any}]);module.exports={EventSource,defaultReconnectionTime};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/eventsource/eventsource.js"],"sourcesContent":["'use strict'\n\nconst { pipeline } = require('node:stream')\nconst { fetching } = require('../fetch')\nconst { makeRequest } = require('../fetch/request')\nconst { webidl } = require('../fetch/webidl')\nconst { EventSourceStream } = require('./eventsource-stream')\nconst { parseMIMEType } = require('../fetch/data-url')\nconst { createFastMessageEvent } = require('../websocket/events')\nconst { isNetworkError } = require('../fetch/response')\nconst { delay } = require('./util')\nconst { kEnumerableProperty } = require('../../core/util')\nconst { environmentSettingsObject } = require('../fetch/util')\n\nlet experimentalWarned = false\n\n/**\n * A reconnection time, in milliseconds. This must initially be an implementation-defined value,\n * probably in the region of a few seconds.\n *\n * In Comparison:\n * - Chrome uses 3000ms.\n * - Deno uses 5000ms.\n *\n * @type {3000}\n */\nconst defaultReconnectionTime = 3000\n\n/**\n * The readyState attribute represents the state of the connection.\n * @enum\n * @readonly\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#dom-eventsource-readystate-dev\n */\n\n/**\n * The connection has not yet been established, or it was closed and the user\n * agent is reconnecting.\n * @type {0}\n */\nconst CONNECTING = 0\n\n/**\n * The user agent has an open connection and is dispatching events as it\n * receives them.\n * @type {1}\n */\nconst OPEN = 1\n\n/**\n * The connection is not open, and the user agent is not trying to reconnect.\n * @type {2}\n */\nconst CLOSED = 2\n\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"same-origin\".\n * @type {'anonymous'}\n */\nconst ANONYMOUS = 'anonymous'\n\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"include\".\n * @type {'use-credentials'}\n */\nconst USE_CREDENTIALS = 'use-credentials'\n\n/**\n * The EventSource interface is used to receive server-sent events. It\n * connects to a server over HTTP and receives events in text/event-stream\n * format without closing the connection.\n * @extends {EventTarget}\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events\n * @api public\n */\nclass EventSource extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    message: null\n  }\n\n  #url = null\n  #withCredentials = false\n\n  #readyState = CONNECTING\n\n  #request = null\n  #controller = null\n\n  #dispatcher\n\n  /**\n   * @type {import('./eventsource-stream').eventSourceSettings}\n   */\n  #state\n\n  /**\n   * Creates a new EventSource object.\n   * @param {string} url\n   * @param {EventSourceInit} [eventSourceInitDict]\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface\n   */\n  constructor (url, eventSourceInitDict = {}) {\n    // 1. Let ev be a new EventSource object.\n    super()\n\n    webidl.util.markAsUncloneable(this)\n\n    const prefix = 'EventSource constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    if (!experimentalWarned) {\n      experimentalWarned = true\n      process.emitWarning('EventSource is experimental, expect them to change at any time.', {\n        code: 'UNDICI-ES'\n      })\n    }\n\n    url = webidl.converters.USVString(url, prefix, 'url')\n    eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, 'eventSourceInitDict')\n\n    this.#dispatcher = eventSourceInitDict.dispatcher\n    this.#state = {\n      lastEventId: '',\n      reconnectionTime: defaultReconnectionTime\n    }\n\n    // 2. Let settings be ev's relevant settings object.\n    // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\n    const settings = environmentSettingsObject\n\n    let urlRecord\n\n    try {\n      // 3. Let urlRecord be the result of encoding-parsing a URL given url, relative to settings.\n      urlRecord = new URL(url, settings.settingsObject.baseUrl)\n      this.#state.origin = urlRecord.origin\n    } catch (e) {\n      // 4. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 5. Set ev's url to urlRecord.\n    this.#url = urlRecord.href\n\n    // 6. Let corsAttributeState be Anonymous.\n    let corsAttributeState = ANONYMOUS\n\n    // 7. If the value of eventSourceInitDict's withCredentials member is true,\n    // then set corsAttributeState to Use Credentials and set ev's\n    // withCredentials attribute to true.\n    if (eventSourceInitDict.withCredentials) {\n      corsAttributeState = USE_CREDENTIALS\n      this.#withCredentials = true\n    }\n\n    // 8. Let request be the result of creating a potential-CORS request given\n    // urlRecord, the empty string, and corsAttributeState.\n    const initRequest = {\n      redirect: 'follow',\n      keepalive: true,\n      // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes\n      mode: 'cors',\n      credentials: corsAttributeState === 'anonymous'\n        ? 'same-origin'\n        : 'omit',\n      referrer: 'no-referrer'\n    }\n\n    // 9. Set request's client to settings.\n    initRequest.client = environmentSettingsObject.settingsObject\n\n    // 10. User agents may set (`Accept`, `text/event-stream`) in request's header list.\n    initRequest.headersList = [['accept', { name: 'accept', value: 'text/event-stream' }]]\n\n    // 11. Set request's cache mode to \"no-store\".\n    initRequest.cache = 'no-store'\n\n    // 12. Set request's initiator type to \"other\".\n    initRequest.initiator = 'other'\n\n    initRequest.urlList = [new URL(this.#url)]\n\n    // 13. Set ev's request to request.\n    this.#request = makeRequest(initRequest)\n\n    this.#connect()\n  }\n\n  /**\n   * Returns the state of this EventSource object's connection. It can have the\n   * values described below.\n   * @returns {0|1|2}\n   * @readonly\n   */\n  get readyState () {\n    return this.#readyState\n  }\n\n  /**\n   * Returns the URL providing the event stream.\n   * @readonly\n   * @returns {string}\n   */\n  get url () {\n    return this.#url\n  }\n\n  /**\n   * Returns a boolean indicating whether the EventSource object was\n   * instantiated with CORS credentials set (true), or not (false, the default).\n   */\n  get withCredentials () {\n    return this.#withCredentials\n  }\n\n  #connect () {\n    if (this.#readyState === CLOSED) return\n\n    this.#readyState = CONNECTING\n\n    const fetchParams = {\n      request: this.#request,\n      dispatcher: this.#dispatcher\n    }\n\n    // 14. Let processEventSourceEndOfBody given response res be the following step: if res is not a network error, then reestablish the connection.\n    const processEventSourceEndOfBody = (response) => {\n      if (isNetworkError(response)) {\n        this.dispatchEvent(new Event('error'))\n        this.close()\n      }\n\n      this.#reconnect()\n    }\n\n    // 15. Fetch request, with processResponseEndOfBody set to processEventSourceEndOfBody...\n    fetchParams.processResponseEndOfBody = processEventSourceEndOfBody\n\n    // and processResponse set to the following steps given response res:\n    fetchParams.processResponse = (response) => {\n      // 1. If res is an aborted network error, then fail the connection.\n\n      if (isNetworkError(response)) {\n        // 1. When a user agent is to fail the connection, the user agent\n        // must queue a task which, if the readyState attribute is set to a\n        // value other than CLOSED, sets the readyState attribute to CLOSED\n        // and fires an event named error at the EventSource object. Once the\n        // user agent has failed the connection, it does not attempt to\n        // reconnect.\n        if (response.aborted) {\n          this.close()\n          this.dispatchEvent(new Event('error'))\n          return\n          // 2. Otherwise, if res is a network error, then reestablish the\n          // connection, unless the user agent knows that to be futile, in\n          // which case the user agent may fail the connection.\n        } else {\n          this.#reconnect()\n          return\n        }\n      }\n\n      // 3. Otherwise, if res's status is not 200, or if res's `Content-Type`\n      // is not `text/event-stream`, then fail the connection.\n      const contentType = response.headersList.get('content-type', true)\n      const mimeType = contentType !== null ? parseMIMEType(contentType) : 'failure'\n      const contentTypeValid = mimeType !== 'failure' && mimeType.essence === 'text/event-stream'\n      if (\n        response.status !== 200 ||\n        contentTypeValid === false\n      ) {\n        this.close()\n        this.dispatchEvent(new Event('error'))\n        return\n      }\n\n      // 4. Otherwise, announce the connection and interpret res's body\n      // line by line.\n\n      // When a user agent is to announce the connection, the user agent\n      // must queue a task which, if the readyState attribute is set to a\n      // value other than CLOSED, sets the readyState attribute to OPEN\n      // and fires an event named open at the EventSource object.\n      // @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n      this.#readyState = OPEN\n      this.dispatchEvent(new Event('open'))\n\n      // If redirected to a different origin, set the origin to the new origin.\n      this.#state.origin = response.urlList[response.urlList.length - 1].origin\n\n      const eventSourceStream = new EventSourceStream({\n        eventSourceSettings: this.#state,\n        push: (event) => {\n          this.dispatchEvent(createFastMessageEvent(\n            event.type,\n            event.options\n          ))\n        }\n      })\n\n      pipeline(response.body.stream,\n        eventSourceStream,\n        (error) => {\n          if (\n            error?.aborted === false\n          ) {\n            this.close()\n            this.dispatchEvent(new Event('error'))\n          }\n        })\n    }\n\n    this.#controller = fetching(fetchParams)\n  }\n\n  /**\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n   * @returns {Promise<void>}\n   */\n  async #reconnect () {\n    // When a user agent is to reestablish the connection, the user agent must\n    // run the following steps. These steps are run in parallel, not as part of\n    // a task. (The tasks that it queues, of course, are run like normal tasks\n    // and not themselves in parallel.)\n\n    // 1. Queue a task to run the following steps:\n\n    //   1. If the readyState attribute is set to CLOSED, abort the task.\n    if (this.#readyState === CLOSED) return\n\n    //   2. Set the readyState attribute to CONNECTING.\n    this.#readyState = CONNECTING\n\n    //   3. Fire an event named error at the EventSource object.\n    this.dispatchEvent(new Event('error'))\n\n    // 2. Wait a delay equal to the reconnection time of the event source.\n    await delay(this.#state.reconnectionTime)\n\n    // 5. Queue a task to run the following steps:\n\n    //   1. If the EventSource object's readyState attribute is not set to\n    //      CONNECTING, then return.\n    if (this.#readyState !== CONNECTING) return\n\n    //   2. Let request be the EventSource object's request.\n    //   3. If the EventSource object's last event ID string is not the empty\n    //      string, then:\n    //      1. Let lastEventIDValue be the EventSource object's last event ID\n    //         string, encoded as UTF-8.\n    //      2. Set (`Last-Event-ID`, lastEventIDValue) in request's header\n    //         list.\n    if (this.#state.lastEventId.length) {\n      this.#request.headersList.set('last-event-id', this.#state.lastEventId, true)\n    }\n\n    //   4. Fetch request and process the response obtained in this fashion, if any, as described earlier in this section.\n    this.#connect()\n  }\n\n  /**\n   * Closes the connection, if any, and sets the readyState attribute to\n   * CLOSED.\n   */\n  close () {\n    webidl.brandCheck(this, EventSource)\n\n    if (this.#readyState === CLOSED) return\n    this.#readyState = CLOSED\n    this.#controller.abort()\n    this.#request = null\n  }\n\n  get onopen () {\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.open = fn\n      this.addEventListener('open', fn)\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onmessage () {\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.message = fn\n      this.addEventListener('message', fn)\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get onerror () {\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this.#events.error = null\n    }\n  }\n}\n\nconst constantsPropertyDescriptors = {\n  CONNECTING: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: CONNECTING,\n    writable: false\n  },\n  OPEN: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: OPEN,\n    writable: false\n  },\n  CLOSED: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: CLOSED,\n    writable: false\n  }\n}\n\nObject.defineProperties(EventSource, constantsPropertyDescriptors)\nObject.defineProperties(EventSource.prototype, constantsPropertyDescriptors)\n\nObject.defineProperties(EventSource.prototype, {\n  close: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  url: kEnumerableProperty,\n  withCredentials: kEnumerableProperty\n})\n\nwebidl.converters.EventSourceInitDict = webidl.dictionaryConverter([\n  {\n    key: 'withCredentials',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'dispatcher', // undici only\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = {\n  EventSource,\n  defaultReconnectionTime\n}\n"]}}