{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});let fastNow=0;const RESOLUTION_MS=1e3;const TICK_MS=(RESOLUTION_MS>>1)-1;let fastNowTimeout;const kFastTimer=Symbol(\"kFastTimer\");const fastTimers=[];const NOT_IN_LIST=-2;const TO_BE_CLEARED=-1;const PENDING=0;const ACTIVE=1;function onTick(){fastNow+=TICK_MS;let idx=0;let len=fastTimers.length;while(idx<len){const timer=fastTimers[idx];if(timer._state===PENDING){timer._idleStart=fastNow-TICK_MS;timer._state=ACTIVE}else if(timer._state===ACTIVE&&fastNow>=timer._idleStart+timer._idleTimeout){timer._state=TO_BE_CLEARED;timer._idleStart=-1;timer._onTimeout(timer._timerArg)}if(timer._state===TO_BE_CLEARED){timer._state=NOT_IN_LIST;if(--len!==0){fastTimers[idx]=fastTimers[len]}}else{++idx}}fastTimers.length=len;if(fastTimers.length!==0){refreshTimeout()}}__name(onTick,\"onTick\");function refreshTimeout(){if(fastNowTimeout){fastNowTimeout.refresh()}else{clearTimeout(fastNowTimeout);fastNowTimeout=setTimeout(onTick,TICK_MS);if(fastNowTimeout.unref){fastNowTimeout.unref()}}}__name(refreshTimeout,\"refreshTimeout\");class FastTimer{static{__name(this,\"FastTimer\")}[kFastTimer]=true;_state=NOT_IN_LIST;_idleTimeout=-1;_idleStart=-1;_onTimeout;_timerArg;constructor(callback,delay,arg){this._onTimeout=callback;this._idleTimeout=delay;this._timerArg=arg;this.refresh()}refresh(){if(this._state===NOT_IN_LIST){fastTimers.push(this)}if(!fastNowTimeout||fastTimers.length===1){refreshTimeout()}this._state=PENDING}clear(){this._state=TO_BE_CLEARED;this._idleStart=-1}}module.exports={setTimeout(callback,delay,arg){return delay<=RESOLUTION_MS?setTimeout(callback,delay,arg):new FastTimer(callback,delay,arg)},clearTimeout(timeout){if(timeout[kFastTimer]){timeout.clear()}else{clearTimeout(timeout)}},setFastTimeout(callback,delay,arg){return new FastTimer(callback,delay,arg)},clearFastTimeout(timeout){timeout.clear()},now(){return fastNow},tick(delay=0){fastNow+=delay-RESOLUTION_MS+1;onTick();onTick()},reset(){fastNow=0;fastTimers.length=0;clearTimeout(fastNowTimeout);fastNowTimeout=null},kFastTimer};\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAqBA,IAAI,QAAU,EAQd,MAAM,cAAgB,IAUtB,MAAM,SAAW,eAAiB,GAAK,EAQvC,IAAI,eAOJ,MAAM,WAAa,OAAO,YAAY,EAOtC,MAAM,WAAa,CAAC,EAgBpB,MAAM,YAAc,GAYpB,MAAM,cAAgB,GAStB,MAAM,QAAU,EAShB,MAAM,OAAS,EAOf,SAAS,QAAU,CAQjB,SAAW,QASX,IAAI,IAAM,EASV,IAAI,IAAM,WAAW,OAErB,MAAO,IAAM,IAAK,CAIhB,MAAM,MAAQ,WAAW,GAAG,EAI5B,GAAI,MAAM,SAAW,QAAS,CAG5B,MAAM,WAAa,QAAU,QAC7B,MAAM,OAAS,MACjB,SACE,MAAM,SAAW,QACjB,SAAW,MAAM,WAAa,MAAM,aACpC,CACA,MAAM,OAAS,cACf,MAAM,WAAa,GACnB,MAAM,WAAW,MAAM,SAAS,CAClC,CAEA,GAAI,MAAM,SAAW,cAAe,CAClC,MAAM,OAAS,YAIf,GAAI,EAAE,MAAQ,EAAG,CACf,WAAW,GAAG,EAAI,WAAW,GAAG,CAClC,CACF,KAAO,CACL,EAAE,GACJ,CACF,CAIA,WAAW,OAAS,IAKpB,GAAI,WAAW,SAAW,EAAG,CAC3B,eAAe,CACjB,CACF,CAzES,wBA2ET,SAAS,gBAAkB,CAEzB,GAAI,eAAgB,CAClB,eAAe,QAAQ,CAEzB,KAAO,CACL,aAAa,cAAc,EAC3B,eAAiB,WAAW,OAAQ,OAAO,EAI3C,GAAI,eAAe,MAAO,CACxB,eAAe,MAAM,CACvB,CACF,CACF,CAfS,wCAqBT,MAAM,SAAU,CAlNhB,MAkNgB,0BACd,CAAC,UAAU,EAAI,KAYf,OAAS,YAQT,aAAe,GAUf,WAAa,GAOb,WAQA,UAUA,YAAa,SAAU,MAAO,IAAK,CACjC,KAAK,WAAa,SAClB,KAAK,aAAe,MACpB,KAAK,UAAY,IAEjB,KAAK,QAAQ,CACf,CAWA,SAAW,CAIT,GAAI,KAAK,SAAW,YAAa,CAC/B,WAAW,KAAK,IAAI,CACtB,CAIA,GAAI,CAAC,gBAAkB,WAAW,SAAW,EAAG,CAC9C,eAAe,CACjB,CAIA,KAAK,OAAS,OAChB,CAQA,OAAS,CAGP,KAAK,OAAS,cAId,KAAK,WAAa,EACpB,CACF,CAMA,OAAO,QAAU,CAYf,WAAY,SAAU,MAAO,IAAK,CAGhC,OAAO,OAAS,cACZ,WAAW,SAAU,MAAO,GAAG,EAC/B,IAAI,UAAU,SAAU,MAAO,GAAG,CACxC,EAOA,aAAc,QAAS,CAErB,GAAI,QAAQ,UAAU,EAAG,CAIvB,QAAQ,MAAM,CAGhB,KAAO,CACL,aAAa,OAAO,CACtB,CACF,EAYA,eAAgB,SAAU,MAAO,IAAK,CACpC,OAAO,IAAI,UAAU,SAAU,MAAO,GAAG,CAC3C,EAOA,iBAAkB,QAAS,CACzB,QAAQ,MAAM,CAChB,EAMA,KAAO,CACL,OAAO,OACT,EAQA,KAAM,MAAQ,EAAG,CACf,SAAW,MAAQ,cAAgB,EACnC,OAAO,EACP,OAAO,CACT,EAOA,OAAS,CACP,QAAU,EACV,WAAW,OAAS,EACpB,aAAa,cAAc,EAC3B,eAAiB,IACnB,EAMA,UACF","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/util/timers.js"],"sourcesContent":["'use strict'\n\n/**\n * This module offers an optimized timer implementation designed for scenarios\n * where high precision is not critical.\n *\n * The timer achieves faster performance by using a low-resolution approach,\n * with an accuracy target of within 500ms. This makes it particularly useful\n * for timers with delays of 1 second or more, where exact timing is less\n * crucial.\n *\n * It's important to note that Node.js timers are inherently imprecise, as\n * delays can occur due to the event loop being blocked by other operations.\n * Consequently, timers may trigger later than their scheduled time.\n */\n\n/**\n * The fastNow variable contains the internal fast timer clock value.\n *\n * @type {number}\n */\nlet fastNow = 0\n\n/**\n * RESOLUTION_MS represents the target resolution time in milliseconds.\n *\n * @type {number}\n * @default 1000\n */\nconst RESOLUTION_MS = 1e3\n\n/**\n * TICK_MS defines the desired interval in milliseconds between each tick.\n * The target value is set to half the resolution time, minus 1 ms, to account\n * for potential event loop overhead.\n *\n * @type {number}\n * @default 499\n */\nconst TICK_MS = (RESOLUTION_MS >> 1) - 1\n\n/**\n * fastNowTimeout is a Node.js timer used to manage and process\n * the FastTimers stored in the `fastTimers` array.\n *\n * @type {NodeJS.Timeout}\n */\nlet fastNowTimeout\n\n/**\n * The kFastTimer symbol is used to identify FastTimer instances.\n *\n * @type {Symbol}\n */\nconst kFastTimer = Symbol('kFastTimer')\n\n/**\n * The fastTimers array contains all active FastTimers.\n *\n * @type {FastTimer[]}\n */\nconst fastTimers = []\n\n/**\n * These constants represent the various states of a FastTimer.\n */\n\n/**\n * The `NOT_IN_LIST` constant indicates that the FastTimer is not included\n * in the `fastTimers` array. Timers with this status will not be processed\n * during the next tick by the `onTick` function.\n *\n * A FastTimer can be re-added to the `fastTimers` array by invoking the\n * `refresh` method on the FastTimer instance.\n *\n * @type {-2}\n */\nconst NOT_IN_LIST = -2\n\n/**\n * The `TO_BE_CLEARED` constant indicates that the FastTimer is scheduled\n * for removal from the `fastTimers` array. A FastTimer in this state will\n * be removed in the next tick by the `onTick` function and will no longer\n * be processed.\n *\n * This status is also set when the `clear` method is called on the FastTimer instance.\n *\n * @type {-1}\n */\nconst TO_BE_CLEARED = -1\n\n/**\n * The `PENDING` constant signifies that the FastTimer is awaiting processing\n * in the next tick by the `onTick` function. Timers with this status will have\n * their `_idleStart` value set and their status updated to `ACTIVE` in the next tick.\n *\n * @type {0}\n */\nconst PENDING = 0\n\n/**\n * The `ACTIVE` constant indicates that the FastTimer is active and waiting\n * for its timer to expire. During the next tick, the `onTick` function will\n * check if the timer has expired, and if so, it will execute the associated callback.\n *\n * @type {1}\n */\nconst ACTIVE = 1\n\n/**\n * The onTick function processes the fastTimers array.\n *\n * @returns {void}\n */\nfunction onTick () {\n  /**\n   * Increment the fastNow value by the TICK_MS value, despite the actual time\n   * that has passed since the last tick. This approach ensures independence\n   * from the system clock and delays caused by a blocked event loop.\n   *\n   * @type {number}\n   */\n  fastNow += TICK_MS\n\n  /**\n   * The `idx` variable is used to iterate over the `fastTimers` array.\n   * Expired timers are removed by replacing them with the last element in the array.\n   * Consequently, `idx` is only incremented when the current element is not removed.\n   *\n   * @type {number}\n   */\n  let idx = 0\n\n  /**\n   * The len variable will contain the length of the fastTimers array\n   * and will be decremented when a FastTimer should be removed from the\n   * fastTimers array.\n   *\n   * @type {number}\n   */\n  let len = fastTimers.length\n\n  while (idx < len) {\n    /**\n     * @type {FastTimer}\n     */\n    const timer = fastTimers[idx]\n\n    // If the timer is in the ACTIVE state and the timer has expired, it will\n    // be processed in the next tick.\n    if (timer._state === PENDING) {\n      // Set the _idleStart value to the fastNow value minus the TICK_MS value\n      // to account for the time the timer was in the PENDING state.\n      timer._idleStart = fastNow - TICK_MS\n      timer._state = ACTIVE\n    } else if (\n      timer._state === ACTIVE &&\n      fastNow >= timer._idleStart + timer._idleTimeout\n    ) {\n      timer._state = TO_BE_CLEARED\n      timer._idleStart = -1\n      timer._onTimeout(timer._timerArg)\n    }\n\n    if (timer._state === TO_BE_CLEARED) {\n      timer._state = NOT_IN_LIST\n\n      // Move the last element to the current index and decrement len if it is\n      // not the only element in the array.\n      if (--len !== 0) {\n        fastTimers[idx] = fastTimers[len]\n      }\n    } else {\n      ++idx\n    }\n  }\n\n  // Set the length of the fastTimers array to the new length and thus\n  // removing the excess FastTimers elements from the array.\n  fastTimers.length = len\n\n  // If there are still active FastTimers in the array, refresh the Timer.\n  // If there are no active FastTimers, the timer will be refreshed again\n  // when a new FastTimer is instantiated.\n  if (fastTimers.length !== 0) {\n    refreshTimeout()\n  }\n}\n\nfunction refreshTimeout () {\n  // If the fastNowTimeout is already set, refresh it.\n  if (fastNowTimeout) {\n    fastNowTimeout.refresh()\n  // fastNowTimeout is not instantiated yet, create a new Timer.\n  } else {\n    clearTimeout(fastNowTimeout)\n    fastNowTimeout = setTimeout(onTick, TICK_MS)\n\n    // If the Timer has an unref method, call it to allow the process to exit if\n    // there are no other active handles.\n    if (fastNowTimeout.unref) {\n      fastNowTimeout.unref()\n    }\n  }\n}\n\n/**\n * The `FastTimer` class is a data structure designed to store and manage\n * timer information.\n */\nclass FastTimer {\n  [kFastTimer] = true\n\n  /**\n   * The state of the timer, which can be one of the following:\n   * - NOT_IN_LIST (-2)\n   * - TO_BE_CLEARED (-1)\n   * - PENDING (0)\n   * - ACTIVE (1)\n   *\n   * @type {-2|-1|0|1}\n   * @private\n   */\n  _state = NOT_IN_LIST\n\n  /**\n   * The number of milliseconds to wait before calling the callback.\n   *\n   * @type {number}\n   * @private\n   */\n  _idleTimeout = -1\n\n  /**\n   * The time in milliseconds when the timer was started. This value is used to\n   * calculate when the timer should expire.\n   *\n   * @type {number}\n   * @default -1\n   * @private\n   */\n  _idleStart = -1\n\n  /**\n   * The function to be executed when the timer expires.\n   * @type {Function}\n   * @private\n   */\n  _onTimeout\n\n  /**\n   * The argument to be passed to the callback when the timer expires.\n   *\n   * @type {*}\n   * @private\n   */\n  _timerArg\n\n  /**\n   * @constructor\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should wait\n   * before the specified function or code is executed.\n   * @param {*} arg\n   */\n  constructor (callback, delay, arg) {\n    this._onTimeout = callback\n    this._idleTimeout = delay\n    this._timerArg = arg\n\n    this.refresh()\n  }\n\n  /**\n   * Sets the timer's start time to the current time, and reschedules the timer\n   * to call its callback at the previously specified duration adjusted to the\n   * current time.\n   * Using this on a timer that has already called its callback will reactivate\n   * the timer.\n   *\n   * @returns {void}\n   */\n  refresh () {\n    // In the special case that the timer is not in the list of active timers,\n    // add it back to the array to be processed in the next tick by the onTick\n    // function.\n    if (this._state === NOT_IN_LIST) {\n      fastTimers.push(this)\n    }\n\n    // If the timer is the only active timer, refresh the fastNowTimeout for\n    // better resolution.\n    if (!fastNowTimeout || fastTimers.length === 1) {\n      refreshTimeout()\n    }\n\n    // Setting the state to PENDING will cause the timer to be reset in the\n    // next tick by the onTick function.\n    this._state = PENDING\n  }\n\n  /**\n   * The `clear` method cancels the timer, preventing it from executing.\n   *\n   * @returns {void}\n   * @private\n   */\n  clear () {\n    // Set the state to TO_BE_CLEARED to mark the timer for removal in the next\n    // tick by the onTick function.\n    this._state = TO_BE_CLEARED\n\n    // Reset the _idleStart value to -1 to indicate that the timer is no longer\n    // active.\n    this._idleStart = -1\n  }\n}\n\n/**\n * This module exports a setTimeout and clearTimeout function that can be\n * used as a drop-in replacement for the native functions.\n */\nmodule.exports = {\n  /**\n   * The setTimeout() method sets a timer which executes a function once the\n   * timer expires.\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should\n   * wait before the specified function or code is executed.\n   * @param {*} [arg] An optional argument to be passed to the callback function\n   * when the timer expires.\n   * @returns {NodeJS.Timeout|FastTimer}\n   */\n  setTimeout (callback, delay, arg) {\n    // If the delay is less than or equal to the RESOLUTION_MS value return a\n    // native Node.js Timer instance.\n    return delay <= RESOLUTION_MS\n      ? setTimeout(callback, delay, arg)\n      : new FastTimer(callback, delay, arg)\n  },\n  /**\n   * The clearTimeout method cancels an instantiated Timer previously created\n   * by calling setTimeout.\n   *\n   * @param {NodeJS.Timeout|FastTimer} timeout\n   */\n  clearTimeout (timeout) {\n    // If the timeout is a FastTimer, call its own clear method.\n    if (timeout[kFastTimer]) {\n      /**\n       * @type {FastTimer}\n       */\n      timeout.clear()\n      // Otherwise it is an instance of a native NodeJS.Timeout, so call the\n      // Node.js native clearTimeout function.\n    } else {\n      clearTimeout(timeout)\n    }\n  },\n  /**\n   * The setFastTimeout() method sets a fastTimer which executes a function once\n   * the timer expires.\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should\n   * wait before the specified function or code is executed.\n   * @param {*} [arg] An optional argument to be passed to the callback function\n   * when the timer expires.\n   * @returns {FastTimer}\n   */\n  setFastTimeout (callback, delay, arg) {\n    return new FastTimer(callback, delay, arg)\n  },\n  /**\n   * The clearTimeout method cancels an instantiated FastTimer previously\n   * created by calling setFastTimeout.\n   *\n   * @param {FastTimer} timeout\n   */\n  clearFastTimeout (timeout) {\n    timeout.clear()\n  },\n  /**\n   * The now method returns the value of the internal fast timer clock.\n   *\n   * @returns {number}\n   */\n  now () {\n    return fastNow\n  },\n  /**\n   * Trigger the onTick function to process the fastTimers array.\n   * Exported for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   * @param {number} [delay=0] The delay in milliseconds to add to the now value.\n   */\n  tick (delay = 0) {\n    fastNow += delay - RESOLUTION_MS + 1\n    onTick()\n    onTick()\n  },\n  /**\n   * Reset FastTimers.\n   * Exported for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   */\n  reset () {\n    fastNow = 0\n    fastTimers.length = 0\n    clearTimeout(fastNowTimeout)\n    fastNowTimeout = null\n  },\n  /**\n   * Exporting for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   */\n  kFastTimer\n}\n"]}}