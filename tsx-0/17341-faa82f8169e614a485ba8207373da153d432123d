{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{maxNameValuePairSize,maxAttributeValueSize}=require(\"./constants\");const{isCTLExcludingHtab}=require(\"./util\");const{collectASequenceOfCodePointsFast}=require(\"../fetch/data-url\");const assert=require(\"node:assert\");function parseSetCookie(header){if(isCTLExcludingHtab(header)){return null}let nameValuePair=\"\";let unparsedAttributes=\"\";let name=\"\";let value=\"\";if(header.includes(\";\")){const position={position:0};nameValuePair=collectASequenceOfCodePointsFast(\";\",header,position);unparsedAttributes=header.slice(position.position)}else{nameValuePair=header}if(!nameValuePair.includes(\"=\")){value=nameValuePair}else{const position={position:0};name=collectASequenceOfCodePointsFast(\"=\",nameValuePair,position);value=nameValuePair.slice(position.position+1)}name=name.trim();value=value.trim();if(name.length+value.length>maxNameValuePairSize){return null}return{name,value,...parseUnparsedAttributes(unparsedAttributes)}}__name(parseSetCookie,\"parseSetCookie\");function parseUnparsedAttributes(unparsedAttributes,cookieAttributeList={}){if(unparsedAttributes.length===0){return cookieAttributeList}assert(unparsedAttributes[0]===\";\");unparsedAttributes=unparsedAttributes.slice(1);let cookieAv=\"\";if(unparsedAttributes.includes(\";\")){cookieAv=collectASequenceOfCodePointsFast(\";\",unparsedAttributes,{position:0});unparsedAttributes=unparsedAttributes.slice(cookieAv.length)}else{cookieAv=unparsedAttributes;unparsedAttributes=\"\"}let attributeName=\"\";let attributeValue=\"\";if(cookieAv.includes(\"=\")){const position={position:0};attributeName=collectASequenceOfCodePointsFast(\"=\",cookieAv,position);attributeValue=cookieAv.slice(position.position+1)}else{attributeName=cookieAv}attributeName=attributeName.trim();attributeValue=attributeValue.trim();if(attributeValue.length>maxAttributeValueSize){return parseUnparsedAttributes(unparsedAttributes,cookieAttributeList)}const attributeNameLowercase=attributeName.toLowerCase();if(attributeNameLowercase===\"expires\"){const expiryTime=new Date(attributeValue);cookieAttributeList.expires=expiryTime}else if(attributeNameLowercase===\"max-age\"){const charCode=attributeValue.charCodeAt(0);if((charCode<48||charCode>57)&&attributeValue[0]!==\"-\"){return parseUnparsedAttributes(unparsedAttributes,cookieAttributeList)}if(!/^\\d+$/.test(attributeValue)){return parseUnparsedAttributes(unparsedAttributes,cookieAttributeList)}const deltaSeconds=Number(attributeValue);cookieAttributeList.maxAge=deltaSeconds}else if(attributeNameLowercase===\"domain\"){let cookieDomain=attributeValue;if(cookieDomain[0]===\".\"){cookieDomain=cookieDomain.slice(1)}cookieDomain=cookieDomain.toLowerCase();cookieAttributeList.domain=cookieDomain}else if(attributeNameLowercase===\"path\"){let cookiePath=\"\";if(attributeValue.length===0||attributeValue[0]!==\"/\"){cookiePath=\"/\"}else{cookiePath=attributeValue}cookieAttributeList.path=cookiePath}else if(attributeNameLowercase===\"secure\"){cookieAttributeList.secure=true}else if(attributeNameLowercase===\"httponly\"){cookieAttributeList.httpOnly=true}else if(attributeNameLowercase===\"samesite\"){let enforcement=\"Default\";const attributeValueLowercase=attributeValue.toLowerCase();if(attributeValueLowercase.includes(\"none\")){enforcement=\"None\"}if(attributeValueLowercase.includes(\"strict\")){enforcement=\"Strict\"}if(attributeValueLowercase.includes(\"lax\")){enforcement=\"Lax\"}cookieAttributeList.sameSite=enforcement}else{cookieAttributeList.unparsed??=[];cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`)}return parseUnparsedAttributes(unparsedAttributes,cookieAttributeList)}__name(parseUnparsedAttributes,\"parseUnparsedAttributes\");module.exports={parseSetCookie,parseUnparsedAttributes};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/cookies/parse.js"],"sourcesContent":["'use strict'\n\nconst { maxNameValuePairSize, maxAttributeValueSize } = require('./constants')\nconst { isCTLExcludingHtab } = require('./util')\nconst { collectASequenceOfCodePointsFast } = require('../fetch/data-url')\nconst assert = require('node:assert')\n\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns if the header is invalid, null will be returned\n */\nfunction parseSetCookie (header) {\n  // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n  //    character (CTL characters excluding HTAB): Abort these steps and\n  //    ignore the set-cookie-string entirely.\n  if (isCTLExcludingHtab(header)) {\n    return null\n  }\n\n  let nameValuePair = ''\n  let unparsedAttributes = ''\n  let name = ''\n  let value = ''\n\n  // 2. If the set-cookie-string contains a %x3B (\";\") character:\n  if (header.includes(';')) {\n    // 1. The name-value-pair string consists of the characters up to,\n    //    but not including, the first %x3B (\";\"), and the unparsed-\n    //    attributes consist of the remainder of the set-cookie-string\n    //    (including the %x3B (\";\") in question).\n    const position = { position: 0 }\n\n    nameValuePair = collectASequenceOfCodePointsFast(';', header, position)\n    unparsedAttributes = header.slice(position.position)\n  } else {\n    // Otherwise:\n\n    // 1. The name-value-pair string consists of all the characters\n    //    contained in the set-cookie-string, and the unparsed-\n    //    attributes is the empty string.\n    nameValuePair = header\n  }\n\n  // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n  //    the name string is empty, and the value string is the value of\n  //    name-value-pair.\n  if (!nameValuePair.includes('=')) {\n    value = nameValuePair\n  } else {\n    //    Otherwise, the name string consists of the characters up to, but\n    //    not including, the first %x3D (\"=\") character, and the (possibly\n    //    empty) value string consists of the characters after the first\n    //    %x3D (\"=\") character.\n    const position = { position: 0 }\n    name = collectASequenceOfCodePointsFast(\n      '=',\n      nameValuePair,\n      position\n    )\n    value = nameValuePair.slice(position.position + 1)\n  }\n\n  // 4. Remove any leading or trailing WSP characters from the name\n  //    string and the value string.\n  name = name.trim()\n  value = value.trim()\n\n  // 5. If the sum of the lengths of the name string and the value string\n  //    is more than 4096 octets, abort these steps and ignore the set-\n  //    cookie-string entirely.\n  if (name.length + value.length > maxNameValuePairSize) {\n    return null\n  }\n\n  // 6. The cookie-name is the name string, and the cookie-value is the\n  //    value string.\n  return {\n    name, value, ...parseUnparsedAttributes(unparsedAttributes)\n  }\n}\n\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {[Object.<string, unknown>]={}} cookieAttributeList\n */\nfunction parseUnparsedAttributes (unparsedAttributes, cookieAttributeList = {}) {\n  // 1. If the unparsed-attributes string is empty, skip the rest of\n  //    these steps.\n  if (unparsedAttributes.length === 0) {\n    return cookieAttributeList\n  }\n\n  // 2. Discard the first character of the unparsed-attributes (which\n  //    will be a %x3B (\";\") character).\n  assert(unparsedAttributes[0] === ';')\n  unparsedAttributes = unparsedAttributes.slice(1)\n\n  let cookieAv = ''\n\n  // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n  //    character:\n  if (unparsedAttributes.includes(';')) {\n    // 1. Consume the characters of the unparsed-attributes up to, but\n    //    not including, the first %x3B (\";\") character.\n    cookieAv = collectASequenceOfCodePointsFast(\n      ';',\n      unparsedAttributes,\n      { position: 0 }\n    )\n    unparsedAttributes = unparsedAttributes.slice(cookieAv.length)\n  } else {\n    // Otherwise:\n\n    // 1. Consume the remainder of the unparsed-attributes.\n    cookieAv = unparsedAttributes\n    unparsedAttributes = ''\n  }\n\n  // Let the cookie-av string be the characters consumed in this step.\n\n  let attributeName = ''\n  let attributeValue = ''\n\n  // 4. If the cookie-av string contains a %x3D (\"=\") character:\n  if (cookieAv.includes('=')) {\n    // 1. The (possibly empty) attribute-name string consists of the\n    //    characters up to, but not including, the first %x3D (\"=\")\n    //    character, and the (possibly empty) attribute-value string\n    //    consists of the characters after the first %x3D (\"=\")\n    //    character.\n    const position = { position: 0 }\n\n    attributeName = collectASequenceOfCodePointsFast(\n      '=',\n      cookieAv,\n      position\n    )\n    attributeValue = cookieAv.slice(position.position + 1)\n  } else {\n    // Otherwise:\n\n    // 1. The attribute-name string consists of the entire cookie-av\n    //    string, and the attribute-value string is empty.\n    attributeName = cookieAv\n  }\n\n  // 5. Remove any leading or trailing WSP characters from the attribute-\n  //    name string and the attribute-value string.\n  attributeName = attributeName.trim()\n  attributeValue = attributeValue.trim()\n\n  // 6. If the attribute-value is longer than 1024 octets, ignore the\n  //    cookie-av string and return to Step 1 of this algorithm.\n  if (attributeValue.length > maxAttributeValueSize) {\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n  }\n\n  // 7. Process the attribute-name and attribute-value according to the\n  //    requirements in the following subsections.  (Notice that\n  //    attributes with unrecognized attribute-names are ignored.)\n  const attributeNameLowercase = attributeName.toLowerCase()\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n  // If the attribute-name case-insensitively matches the string\n  // \"Expires\", the user agent MUST process the cookie-av as follows.\n  if (attributeNameLowercase === 'expires') {\n    // 1. Let the expiry-time be the result of parsing the attribute-value\n    //    as cookie-date (see Section 5.1.1).\n    const expiryTime = new Date(attributeValue)\n\n    // 2. If the attribute-value failed to parse as a cookie date, ignore\n    //    the cookie-av.\n\n    cookieAttributeList.expires = expiryTime\n  } else if (attributeNameLowercase === 'max-age') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n    // If the attribute-name case-insensitively matches the string \"Max-\n    // Age\", the user agent MUST process the cookie-av as follows.\n\n    // 1. If the first character of the attribute-value is not a DIGIT or a\n    //    \"-\" character, ignore the cookie-av.\n    const charCode = attributeValue.charCodeAt(0)\n\n    if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 2. If the remainder of attribute-value contains a non-DIGIT\n    //    character, ignore the cookie-av.\n    if (!/^\\d+$/.test(attributeValue)) {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 3. Let delta-seconds be the attribute-value converted to an integer.\n    const deltaSeconds = Number(attributeValue)\n\n    // 4. Let cookie-age-limit be the maximum age of the cookie (which\n    //    SHOULD be 400 days or less, see Section 4.1.2.2).\n\n    // 5. Set delta-seconds to the smaller of its present value and cookie-\n    //    age-limit.\n    // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n\n    // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n    //    time be the earliest representable date and time.  Otherwise, let\n    //    the expiry-time be the current date and time plus delta-seconds\n    //    seconds.\n    // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n\n    // 7. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Max-Age and an attribute-value of expiry-time.\n    cookieAttributeList.maxAge = deltaSeconds\n  } else if (attributeNameLowercase === 'domain') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n    // If the attribute-name case-insensitively matches the string \"Domain\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. Let cookie-domain be the attribute-value.\n    let cookieDomain = attributeValue\n\n    // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n    //    cookie-domain without its leading %x2E (\".\").\n    if (cookieDomain[0] === '.') {\n      cookieDomain = cookieDomain.slice(1)\n    }\n\n    // 3. Convert the cookie-domain to lower case.\n    cookieDomain = cookieDomain.toLowerCase()\n\n    // 4. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Domain and an attribute-value of cookie-domain.\n    cookieAttributeList.domain = cookieDomain\n  } else if (attributeNameLowercase === 'path') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n    // If the attribute-name case-insensitively matches the string \"Path\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. If the attribute-value is empty or if the first character of the\n    //    attribute-value is not %x2F (\"/\"):\n    let cookiePath = ''\n    if (attributeValue.length === 0 || attributeValue[0] !== '/') {\n      // 1. Let cookie-path be the default-path.\n      cookiePath = '/'\n    } else {\n      // Otherwise:\n\n      // 1. Let cookie-path be the attribute-value.\n      cookiePath = attributeValue\n    }\n\n    // 2. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Path and an attribute-value of cookie-path.\n    cookieAttributeList.path = cookiePath\n  } else if (attributeNameLowercase === 'secure') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n    // If the attribute-name case-insensitively matches the string \"Secure\",\n    // the user agent MUST append an attribute to the cookie-attribute-list\n    // with an attribute-name of Secure and an empty attribute-value.\n\n    cookieAttributeList.secure = true\n  } else if (attributeNameLowercase === 'httponly') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n    // If the attribute-name case-insensitively matches the string\n    // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n    // attribute-list with an attribute-name of HttpOnly and an empty\n    // attribute-value.\n\n    cookieAttributeList.httpOnly = true\n  } else if (attributeNameLowercase === 'samesite') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n    // If the attribute-name case-insensitively matches the string\n    // \"SameSite\", the user agent MUST process the cookie-av as follows:\n\n    // 1. Let enforcement be \"Default\".\n    let enforcement = 'Default'\n\n    const attributeValueLowercase = attributeValue.toLowerCase()\n    // 2. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"None\", set enforcement to \"None\".\n    if (attributeValueLowercase.includes('none')) {\n      enforcement = 'None'\n    }\n\n    // 3. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Strict\", set enforcement to \"Strict\".\n    if (attributeValueLowercase.includes('strict')) {\n      enforcement = 'Strict'\n    }\n\n    // 4. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Lax\", set enforcement to \"Lax\".\n    if (attributeValueLowercase.includes('lax')) {\n      enforcement = 'Lax'\n    }\n\n    // 5. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of \"SameSite\" and an attribute-value of\n    //    enforcement.\n    cookieAttributeList.sameSite = enforcement\n  } else {\n    cookieAttributeList.unparsed ??= []\n\n    cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`)\n  }\n\n  // 8. Return to Step 1 of this algorithm.\n  return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n}\n\nmodule.exports = {\n  parseSetCookie,\n  parseUnparsedAttributes\n}\n"]}}