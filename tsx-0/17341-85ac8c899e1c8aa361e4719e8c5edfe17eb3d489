{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const assert=require(\"node:assert\");const{AsyncResource}=require(\"node:async_hooks\");const{InvalidArgumentError,SocketError}=require(\"../core/errors\");const util=require(\"../core/util\");const{addSignal,removeSignal}=require(\"./abort-signal\");class ConnectHandler extends AsyncResource{static{__name(this,\"ConnectHandler\")}constructor(opts,callback){if(!opts||typeof opts!==\"object\"){throw new InvalidArgumentError(\"invalid opts\")}if(typeof callback!==\"function\"){throw new InvalidArgumentError(\"invalid callback\")}const{signal,opaque,responseHeaders}=opts;if(signal&&typeof signal.on!==\"function\"&&typeof signal.addEventListener!==\"function\"){throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\")}super(\"UNDICI_CONNECT\");this.opaque=opaque||null;this.responseHeaders=responseHeaders||null;this.callback=callback;this.abort=null;addSignal(this,signal)}onConnect(abort,context){if(this.reason){abort(this.reason);return}assert(this.callback);this.abort=abort;this.context=context}onHeaders(){throw new SocketError(\"bad connect\",null)}onUpgrade(statusCode,rawHeaders,socket){const{callback,opaque,context}=this;removeSignal(this);this.callback=null;let headers=rawHeaders;if(headers!=null){headers=this.responseHeaders===\"raw\"?util.parseRawHeaders(rawHeaders):util.parseHeaders(rawHeaders)}this.runInAsyncScope(callback,null,null,{statusCode,headers,socket,opaque,context})}onError(err){const{callback,opaque}=this;removeSignal(this);if(callback){this.callback=null;queueMicrotask(()=>{this.runInAsyncScope(callback,null,err,{opaque})})}}}function connect(opts,callback){if(callback===void 0){return new Promise((resolve,reject)=>{connect.call(this,opts,(err,data)=>{return err?reject(err):resolve(data)})})}try{const connectHandler=new ConnectHandler(opts,callback);this.dispatch({...opts,method:\"CONNECT\"},connectHandler)}catch(err){if(typeof callback!==\"function\"){throw err}const opaque=opts?.opaque;queueMicrotask(()=>callback(err,{opaque}))}}__name(connect,\"connect\");module.exports=connect;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAEA,MAAM,OAAS,QAAQ,aAAa,EACpC,KAAM,CAAE,aAAc,EAAI,QAAQ,kBAAkB,EACpD,KAAM,CAAE,qBAAsB,WAAY,EAAI,QAAQ,gBAAgB,EACtE,MAAM,KAAO,QAAQ,cAAc,EACnC,KAAM,CAAE,UAAW,YAAa,EAAI,QAAQ,gBAAgB,EAE5D,MAAM,uBAAuB,aAAc,CAR3C,MAQ2C,+BACzC,YAAa,KAAM,SAAU,CAC3B,GAAI,CAAC,MAAQ,OAAO,OAAS,SAAU,CACrC,MAAM,IAAI,qBAAqB,cAAc,CAC/C,CAEA,GAAI,OAAO,WAAa,WAAY,CAClC,MAAM,IAAI,qBAAqB,kBAAkB,CACnD,CAEA,KAAM,CAAE,OAAQ,OAAQ,eAAgB,EAAI,KAE5C,GAAI,QAAU,OAAO,OAAO,KAAO,YAAc,OAAO,OAAO,mBAAqB,WAAY,CAC9F,MAAM,IAAI,qBAAqB,+CAA+C,CAChF,CAEA,MAAM,gBAAgB,EAEtB,KAAK,OAAS,QAAU,KACxB,KAAK,gBAAkB,iBAAmB,KAC1C,KAAK,SAAW,SAChB,KAAK,MAAQ,KAEb,UAAU,KAAM,MAAM,CACxB,CAEA,UAAW,MAAO,QAAS,CACzB,GAAI,KAAK,OAAQ,CACf,MAAM,KAAK,MAAM,EACjB,MACF,CAEA,OAAO,KAAK,QAAQ,EAEpB,KAAK,MAAQ,MACb,KAAK,QAAU,OACjB,CAEA,WAAa,CACX,MAAM,IAAI,YAAY,cAAe,IAAI,CAC3C,CAEA,UAAW,WAAY,WAAY,OAAQ,CACzC,KAAM,CAAE,SAAU,OAAQ,OAAQ,EAAI,KAEtC,aAAa,IAAI,EAEjB,KAAK,SAAW,KAEhB,IAAI,QAAU,WAEd,GAAI,SAAW,KAAM,CACnB,QAAU,KAAK,kBAAoB,MAAQ,KAAK,gBAAgB,UAAU,EAAI,KAAK,aAAa,UAAU,CAC5G,CAEA,KAAK,gBAAgB,SAAU,KAAM,KAAM,CACzC,WACA,QACA,OACA,OACA,OACF,CAAC,CACH,CAEA,QAAS,IAAK,CACZ,KAAM,CAAE,SAAU,MAAO,EAAI,KAE7B,aAAa,IAAI,EAEjB,GAAI,SAAU,CACZ,KAAK,SAAW,KAChB,eAAe,IAAM,CACnB,KAAK,gBAAgB,SAAU,KAAM,IAAK,CAAE,MAAO,CAAC,CACtD,CAAC,CACH,CACF,CACF,CAEA,SAAS,QAAS,KAAM,SAAU,CAChC,GAAI,WAAa,OAAW,CAC1B,OAAO,IAAI,QAAQ,CAAC,QAAS,SAAW,CACtC,QAAQ,KAAK,KAAM,KAAM,CAAC,IAAK,OAAS,CACtC,OAAO,IAAM,OAAO,GAAG,EAAI,QAAQ,IAAI,CACzC,CAAC,CACH,CAAC,CACH,CAEA,GAAI,CACF,MAAM,eAAiB,IAAI,eAAe,KAAM,QAAQ,EACxD,KAAK,SAAS,CAAE,GAAG,KAAM,OAAQ,SAAU,EAAG,cAAc,CAC9D,OAAS,IAAK,CACZ,GAAI,OAAO,WAAa,WAAY,CAClC,MAAM,GACR,CACA,MAAM,OAAS,MAAM,OACrB,eAAe,IAAM,SAAS,IAAK,CAAE,MAAO,CAAC,CAAC,CAChD,CACF,CAnBS,0BAqBT,OAAO,QAAU","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/api/api-connect.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { AsyncResource } = require('node:async_hooks')\nconst { InvalidArgumentError, SocketError } = require('../core/errors')\nconst util = require('../core/util')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass ConnectHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_CONNECT')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.callback = callback\n    this.abort = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders () {\n    throw new SocketError('bad connect', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n\n    let headers = rawHeaders\n    // Indicates is an HTTP2Session\n    if (headers != null) {\n      headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    }\n\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction connect (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      connect.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const connectHandler = new ConnectHandler(opts, callback)\n    this.dispatch({ ...opts, method: 'CONNECT' }, connectHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = connect\n"]}}