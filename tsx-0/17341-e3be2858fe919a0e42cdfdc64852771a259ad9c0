{"code":"(()=>{\n\"use strict\";const iconvLite=require(\"iconv-lite\");const supportedNames=require(\"./supported-names.json\");const labelsToNames=require(\"./labels-to-names.json\");const supportedNamesSet=new Set(supportedNames);exports.labelToName=label=>{label=String(label).trim().toLowerCase();return labelsToNames[label]||null};exports.decode=(uint8Array,fallbackEncodingName)=>{let encoding=fallbackEncodingName;if(!exports.isSupported(encoding)){throw new RangeError(`\"${encoding}\" is not a supported encoding name`)}const bomEncoding=exports.getBOMEncoding(uint8Array);if(bomEncoding!==null){encoding=bomEncoding}if(encoding===\"x-user-defined\"){let result=\"\";for(const byte of uint8Array){if(byte<=127){result+=String.fromCodePoint(byte)}else{result+=String.fromCodePoint(63360+byte-128)}}return result}return iconvLite.decode(uint8Array,encoding)};exports.getBOMEncoding=uint8Array=>{if(uint8Array[0]===254&&uint8Array[1]===255){return\"UTF-16BE\"}else if(uint8Array[0]===255&&uint8Array[1]===254){return\"UTF-16LE\"}else if(uint8Array[0]===239&&uint8Array[1]===187&&uint8Array[2]===191){return\"UTF-8\"}return null};exports.isSupported=name=>{return supportedNamesSet.has(String(name))};\n})()\n","warnings":[],"map":{"version":3,"mappings":";aACA,MAAM,UAAY,QAAQ,YAAY,EACtC,MAAM,eAAiB,QAAQ,wBAAwB,EACvD,MAAM,cAAgB,QAAQ,wBAAwB,EAEtD,MAAM,kBAAoB,IAAI,IAAI,cAAc,EAGhD,QAAQ,YAAc,OAAS,CAC7B,MAAQ,OAAO,KAAK,EAAE,KAAK,EAAE,YAAY,EAEzC,OAAO,cAAc,KAAK,GAAK,IACjC,EAGA,QAAQ,OAAS,CAAC,WAAY,uBAAyB,CACrD,IAAI,SAAW,qBACf,GAAI,CAAC,QAAQ,YAAY,QAAQ,EAAG,CAClC,MAAM,IAAI,WAAW,IAAI,QAAQ,oCAAoC,CACvE,CAEA,MAAM,YAAc,QAAQ,eAAe,UAAU,EACrD,GAAI,cAAgB,KAAM,CACxB,SAAW,WAGb,CAEA,GAAI,WAAa,iBAAkB,CAEjC,IAAI,OAAS,GACb,UAAW,QAAQ,WAAY,CAC7B,GAAI,MAAQ,IAAM,CAChB,QAAU,OAAO,cAAc,IAAI,CACrC,KAAO,CACL,QAAU,OAAO,cAAc,MAAS,KAAO,GAAI,CACrD,CACF,CACA,OAAO,MACT,CAEA,OAAO,UAAU,OAAO,WAAY,QAAQ,CAC9C,EAGA,QAAQ,eAAiB,YAAc,CACrC,GAAI,WAAW,CAAC,IAAM,KAAQ,WAAW,CAAC,IAAM,IAAM,CACpD,MAAO,UACT,SAAW,WAAW,CAAC,IAAM,KAAQ,WAAW,CAAC,IAAM,IAAM,CAC3D,MAAO,UACT,SAAW,WAAW,CAAC,IAAM,KAAQ,WAAW,CAAC,IAAM,KAAQ,WAAW,CAAC,IAAM,IAAM,CACrF,MAAO,OACT,CAEA,OAAO,IACT,EAEA,QAAQ,YAAc,MAAQ,CAC5B,OAAO,kBAAkB,IAAI,OAAO,IAAI,CAAC,CAC3C","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/whatwg-encoding@3.1.1/node_modules/whatwg-encoding/lib/whatwg-encoding.js"],"sourcesContent":["\"use strict\";\nconst iconvLite = require(\"iconv-lite\");\nconst supportedNames = require(\"./supported-names.json\");\nconst labelsToNames = require(\"./labels-to-names.json\");\n\nconst supportedNamesSet = new Set(supportedNames);\n\n// https://encoding.spec.whatwg.org/#concept-encoding-get\nexports.labelToName = label => {\n  label = String(label).trim().toLowerCase();\n\n  return labelsToNames[label] || null;\n};\n\n// https://encoding.spec.whatwg.org/#decode\nexports.decode = (uint8Array, fallbackEncodingName) => {\n  let encoding = fallbackEncodingName;\n  if (!exports.isSupported(encoding)) {\n    throw new RangeError(`\"${encoding}\" is not a supported encoding name`);\n  }\n\n  const bomEncoding = exports.getBOMEncoding(uint8Array);\n  if (bomEncoding !== null) {\n    encoding = bomEncoding;\n    // iconv-lite will strip BOMs for us, so no need to do the extra byte removal that the spec does.\n    // Note that we won't end up in the x-user-defined case when there's a bomEncoding.\n  }\n\n  if (encoding === \"x-user-defined\") {\n    // https://encoding.spec.whatwg.org/#x-user-defined-decoder\n    let result = \"\";\n    for (const byte of uint8Array) {\n      if (byte <= 0x7F) {\n        result += String.fromCodePoint(byte);\n      } else {\n        result += String.fromCodePoint(0xF780 + byte - 0x80);\n      }\n    }\n    return result;\n  }\n\n  return iconvLite.decode(uint8Array, encoding);\n};\n\n// https://github.com/whatwg/html/issues/1910#issuecomment-254017369\nexports.getBOMEncoding = uint8Array => {\n  if (uint8Array[0] === 0xFE && uint8Array[1] === 0xFF) {\n    return \"UTF-16BE\";\n  } else if (uint8Array[0] === 0xFF && uint8Array[1] === 0xFE) {\n    return \"UTF-16LE\";\n  } else if (uint8Array[0] === 0xEF && uint8Array[1] === 0xBB && uint8Array[2] === 0xBF) {\n    return \"UTF-8\";\n  }\n\n  return null;\n};\n\nexports.isSupported = name => {\n  return supportedNamesSet.has(String(name));\n};\n"]}}