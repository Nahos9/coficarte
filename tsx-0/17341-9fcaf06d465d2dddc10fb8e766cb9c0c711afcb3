{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const assert=require(\"node:assert\");const{pipeline}=require(\"node:stream\");const util=require(\"../core/util.js\");const{RequestContentLengthMismatchError,RequestAbortedError,SocketError,InformationalError}=require(\"../core/errors.js\");const{kUrl,kReset,kClient,kRunning,kPending,kQueue,kPendingIdx,kRunningIdx,kError,kSocket,kStrictContentLength,kOnError,kMaxConcurrentStreams,kHTTP2Session,kResume,kSize,kHTTPContext}=require(\"../core/symbols.js\");const kOpenStreams=Symbol(\"open streams\");let h2ExperimentalWarned=false;let http2;try{http2=require(\"node:http2\")}catch{http2={constants:{}}}const{constants:{HTTP2_HEADER_AUTHORITY,HTTP2_HEADER_METHOD,HTTP2_HEADER_PATH,HTTP2_HEADER_SCHEME,HTTP2_HEADER_CONTENT_LENGTH,HTTP2_HEADER_EXPECT,HTTP2_HEADER_STATUS}}=http2;function parseH2Headers(headers){const result=[];for(const[name,value]of Object.entries(headers)){if(Array.isArray(value)){for(const subvalue of value){result.push(Buffer.from(name),Buffer.from(subvalue))}}else{result.push(Buffer.from(name),Buffer.from(value))}}return result}__name(parseH2Headers,\"parseH2Headers\");async function connectH2(client,socket){client[kSocket]=socket;if(!h2ExperimentalWarned){h2ExperimentalWarned=true;process.emitWarning(\"H2 support is experimental, expect them to change at any time.\",{code:\"UNDICI-H2\"})}const session=http2.connect(client[kUrl],{createConnection:()=>socket,peerMaxConcurrentStreams:client[kMaxConcurrentStreams]});session[kOpenStreams]=0;session[kClient]=client;session[kSocket]=socket;util.addListener(session,\"error\",onHttp2SessionError);util.addListener(session,\"frameError\",onHttp2FrameError);util.addListener(session,\"end\",onHttp2SessionEnd);util.addListener(session,\"goaway\",onHTTP2GoAway);util.addListener(session,\"close\",function(){const{[kClient]:client2}=this;const{[kSocket]:socket2}=client2;const err=this[kSocket][kError]||this[kError]||new SocketError(\"closed\",util.getSocketInfo(socket2));client2[kHTTP2Session]=null;if(client2.destroyed){assert(client2[kPending]===0);const requests=client2[kQueue].splice(client2[kRunningIdx]);for(let i=0;i<requests.length;i++){const request=requests[i];util.errorRequest(client2,request,err)}}});session.unref();client[kHTTP2Session]=session;socket[kHTTP2Session]=session;util.addListener(socket,\"error\",function(err){assert(err.code!==\"ERR_TLS_CERT_ALTNAME_INVALID\");this[kError]=err;this[kClient][kOnError](err)});util.addListener(socket,\"end\",function(){util.destroy(this,new SocketError(\"other side closed\",util.getSocketInfo(this)))});util.addListener(socket,\"close\",function(){const err=this[kError]||new SocketError(\"closed\",util.getSocketInfo(this));client[kSocket]=null;if(this[kHTTP2Session]!=null){this[kHTTP2Session].destroy(err)}client[kPendingIdx]=client[kRunningIdx];assert(client[kRunning]===0);client.emit(\"disconnect\",client[kUrl],[client],err);client[kResume]()});let closed=false;socket.on(\"close\",()=>{closed=true});return{version:\"h2\",defaultPipelining:Infinity,write(...args){return writeH2(client,...args)},resume(){resumeH2(client)},destroy(err,callback){if(closed){queueMicrotask(callback)}else{socket.destroy(err).on(\"close\",callback)}},get destroyed(){return socket.destroyed},busy(){return false}}}__name(connectH2,\"connectH2\");function resumeH2(client){const socket=client[kSocket];if(socket?.destroyed===false){if(client[kSize]===0&&client[kMaxConcurrentStreams]===0){socket.unref();client[kHTTP2Session].unref()}else{socket.ref();client[kHTTP2Session].ref()}}}__name(resumeH2,\"resumeH2\");function onHttp2SessionError(err){assert(err.code!==\"ERR_TLS_CERT_ALTNAME_INVALID\");this[kSocket][kError]=err;this[kClient][kOnError](err)}__name(onHttp2SessionError,\"onHttp2SessionError\");function onHttp2FrameError(type,code,id){if(id===0){const err=new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`);this[kSocket][kError]=err;this[kClient][kOnError](err)}}__name(onHttp2FrameError,\"onHttp2FrameError\");function onHttp2SessionEnd(){const err=new SocketError(\"other side closed\",util.getSocketInfo(this[kSocket]));this.destroy(err);util.destroy(this[kSocket],err)}__name(onHttp2SessionEnd,\"onHttp2SessionEnd\");function onHTTP2GoAway(code){const err=this[kError]||new SocketError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`,util.getSocketInfo(this));const client=this[kClient];client[kSocket]=null;client[kHTTPContext]=null;if(this[kHTTP2Session]!=null){this[kHTTP2Session].destroy(err);this[kHTTP2Session]=null}util.destroy(this[kSocket],err);const request=client[kQueue][client[kRunningIdx]];client[kQueue][client[kRunningIdx]++]=null;util.errorRequest(client,request,err);client[kPendingIdx]=client[kRunningIdx];assert(client[kRunning]===0);client.emit(\"disconnect\",client[kUrl],[client],err);client[kResume]()}__name(onHTTP2GoAway,\"onHTTP2GoAway\");function shouldSendContentLength(method){return method!==\"GET\"&&method!==\"HEAD\"&&method!==\"OPTIONS\"&&method!==\"TRACE\"&&method!==\"CONNECT\"}__name(shouldSendContentLength,\"shouldSendContentLength\");function writeH2(client,request){const session=client[kHTTP2Session];const{body,method,path,host,upgrade,expectContinue,signal,headers:reqHeaders}=request;if(upgrade){util.errorRequest(client,request,new Error(\"Upgrade not supported for H2\"));return false}const headers={};for(let n=0;n<reqHeaders.length;n+=2){const key=reqHeaders[n+0];const val=reqHeaders[n+1];if(Array.isArray(val)){for(let i=0;i<val.length;i++){if(headers[key]){headers[key]+=`,${val[i]}`}else{headers[key]=val[i]}}}else{headers[key]=val}}let stream;const{hostname,port}=client[kUrl];headers[HTTP2_HEADER_AUTHORITY]=host||`${hostname}${port?`:${port}`:\"\"}`;headers[HTTP2_HEADER_METHOD]=method;const abort=__name(err=>{if(request.aborted||request.completed){return}err=err||new RequestAbortedError;util.errorRequest(client,request,err);if(stream!=null){util.destroy(stream,err)}util.destroy(body,err);client[kQueue][client[kRunningIdx]++]=null;client[kResume]()},\"abort\");try{request.onConnect(abort)}catch(err){util.errorRequest(client,request,err)}if(request.aborted){return false}if(method===\"CONNECT\"){session.ref();stream=session.request(headers,{endStream:false,signal});if(stream.id&&!stream.pending){request.onUpgrade(null,null,stream);++session[kOpenStreams];client[kQueue][client[kRunningIdx]++]=null}else{stream.once(\"ready\",()=>{request.onUpgrade(null,null,stream);++session[kOpenStreams];client[kQueue][client[kRunningIdx]++]=null})}stream.once(\"close\",()=>{session[kOpenStreams]-=1;if(session[kOpenStreams]===0)session.unref()});return true}headers[HTTP2_HEADER_PATH]=path;headers[HTTP2_HEADER_SCHEME]=\"https\";const expectsPayload=method===\"PUT\"||method===\"POST\"||method===\"PATCH\";if(body&&typeof body.read===\"function\"){body.read(0)}let contentLength=util.bodyLength(body);if(contentLength==null){contentLength=request.contentLength}if(contentLength===0||!expectsPayload){contentLength=null}if(shouldSendContentLength(method)&&contentLength>0&&request.contentLength!=null&&request.contentLength!==contentLength){if(client[kStrictContentLength]){util.errorRequest(client,request,new RequestContentLengthMismatchError);return false}process.emitWarning(new RequestContentLengthMismatchError)}if(contentLength!=null){assert(body,\"no body must not have content length\");headers[HTTP2_HEADER_CONTENT_LENGTH]=`${contentLength}`}session.ref();const shouldEndStream=method===\"GET\"||method===\"HEAD\"||body===null;if(expectContinue){headers[HTTP2_HEADER_EXPECT]=\"100-continue\";stream=session.request(headers,{endStream:shouldEndStream,signal});stream.once(\"continue\",writeBodyH2)}else{stream=session.request(headers,{endStream:shouldEndStream,signal});writeBodyH2()}++session[kOpenStreams];stream.once(\"response\",headers2=>{const{[HTTP2_HEADER_STATUS]:statusCode,...realHeaders}=headers2;request.onResponseStarted();if(request.aborted){const err=new RequestAbortedError;util.errorRequest(client,request,err);util.destroy(stream,err);return}if(request.onHeaders(Number(statusCode),parseH2Headers(realHeaders),stream.resume.bind(stream),\"\")===false){stream.pause()}stream.on(\"data\",chunk=>{if(request.onData(chunk)===false){stream.pause()}})});stream.once(\"end\",()=>{if(stream.state?.state==null||stream.state.state<6){request.onComplete([])}if(session[kOpenStreams]===0){session.unref()}abort(new InformationalError(\"HTTP/2: stream half-closed (remote)\"));client[kQueue][client[kRunningIdx]++]=null;client[kPendingIdx]=client[kRunningIdx];client[kResume]()});stream.once(\"close\",()=>{session[kOpenStreams]-=1;if(session[kOpenStreams]===0){session.unref()}});stream.once(\"error\",function(err){abort(err)});stream.once(\"frameError\",(type,code)=>{abort(new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`))});return true;function writeBodyH2(){if(!body||contentLength===0){writeBuffer(abort,stream,null,client,request,client[kSocket],contentLength,expectsPayload)}else if(util.isBuffer(body)){writeBuffer(abort,stream,body,client,request,client[kSocket],contentLength,expectsPayload)}else if(util.isBlobLike(body)){if(typeof body.stream===\"function\"){writeIterable(abort,stream,body.stream(),client,request,client[kSocket],contentLength,expectsPayload)}else{writeBlob(abort,stream,body,client,request,client[kSocket],contentLength,expectsPayload)}}else if(util.isStream(body)){writeStream(abort,client[kSocket],expectsPayload,stream,body,client,request,contentLength)}else if(util.isIterable(body)){writeIterable(abort,stream,body,client,request,client[kSocket],contentLength,expectsPayload)}else{assert(false)}}__name(writeBodyH2,\"writeBodyH2\")}__name(writeH2,\"writeH2\");function writeBuffer(abort,h2stream,body,client,request,socket,contentLength,expectsPayload){try{if(body!=null&&util.isBuffer(body)){assert(contentLength===body.byteLength,\"buffer body must have content length\");h2stream.cork();h2stream.write(body);h2stream.uncork();h2stream.end();request.onBodySent(body)}if(!expectsPayload){socket[kReset]=true}request.onRequestSent();client[kResume]()}catch(error){abort(error)}}__name(writeBuffer,\"writeBuffer\");function writeStream(abort,socket,expectsPayload,h2stream,body,client,request,contentLength){assert(contentLength!==0||client[kRunning]===0,\"stream body cannot be pipelined\");const pipe=pipeline(body,h2stream,err=>{if(err){util.destroy(pipe,err);abort(err)}else{util.removeAllListeners(pipe);request.onRequestSent();if(!expectsPayload){socket[kReset]=true}client[kResume]()}});util.addListener(pipe,\"data\",onPipeData);function onPipeData(chunk){request.onBodySent(chunk)}__name(onPipeData,\"onPipeData\")}__name(writeStream,\"writeStream\");async function writeBlob(abort,h2stream,body,client,request,socket,contentLength,expectsPayload){assert(contentLength===body.size,\"blob body must have content length\");try{if(contentLength!=null&&contentLength!==body.size){throw new RequestContentLengthMismatchError}const buffer=Buffer.from(await body.arrayBuffer());h2stream.cork();h2stream.write(buffer);h2stream.uncork();h2stream.end();request.onBodySent(buffer);request.onRequestSent();if(!expectsPayload){socket[kReset]=true}client[kResume]()}catch(err){abort(err)}}__name(writeBlob,\"writeBlob\");async function writeIterable(abort,h2stream,body,client,request,socket,contentLength,expectsPayload){assert(contentLength!==0||client[kRunning]===0,\"iterator body cannot be pipelined\");let callback=null;function onDrain(){if(callback){const cb=callback;callback=null;cb()}}__name(onDrain,\"onDrain\");const waitForDrain=__name(()=>new Promise((resolve,reject)=>{assert(callback===null);if(socket[kError]){reject(socket[kError])}else{callback=resolve}}),\"waitForDrain\");h2stream.on(\"close\",onDrain).on(\"drain\",onDrain);try{for await(const chunk of body){if(socket[kError]){throw socket[kError]}const res=h2stream.write(chunk);request.onBodySent(chunk);if(!res){await waitForDrain()}}h2stream.end();request.onRequestSent();if(!expectsPayload){socket[kReset]=true}client[kResume]()}catch(err){abort(err)}finally{h2stream.off(\"close\",onDrain).off(\"drain\",onDrain)}}__name(writeIterable,\"writeIterable\");module.exports=connectH2;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["client","socket","headers"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/dispatcher/client-h2.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { pipeline } = require('node:stream')\nconst util = require('../core/util.js')\nconst {\n  RequestContentLengthMismatchError,\n  RequestAbortedError,\n  SocketError,\n  InformationalError\n} = require('../core/errors.js')\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kRunning,\n  kPending,\n  kQueue,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kSocket,\n  kStrictContentLength,\n  kOnError,\n  kMaxConcurrentStreams,\n  kHTTP2Session,\n  kResume,\n  kSize,\n  kHTTPContext\n} = require('../core/symbols.js')\n\nconst kOpenStreams = Symbol('open streams')\n\n// Experimental\nlet h2ExperimentalWarned = false\n\n/** @type {import('http2')} */\nlet http2\ntry {\n  http2 = require('node:http2')\n} catch {\n  // @ts-ignore\n  http2 = { constants: {} }\n}\n\nconst {\n  constants: {\n    HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH,\n    HTTP2_HEADER_SCHEME,\n    HTTP2_HEADER_CONTENT_LENGTH,\n    HTTP2_HEADER_EXPECT,\n    HTTP2_HEADER_STATUS\n  }\n} = http2\n\nfunction parseH2Headers (headers) {\n  const result = []\n\n  for (const [name, value] of Object.entries(headers)) {\n    // h2 may concat the header value by array\n    // e.g. Set-Cookie\n    if (Array.isArray(value)) {\n      for (const subvalue of value) {\n        // we need to provide each header value of header name\n        // because the headers handler expect name-value pair\n        result.push(Buffer.from(name), Buffer.from(subvalue))\n      }\n    } else {\n      result.push(Buffer.from(name), Buffer.from(value))\n    }\n  }\n\n  return result\n}\n\nasync function connectH2 (client, socket) {\n  client[kSocket] = socket\n\n  if (!h2ExperimentalWarned) {\n    h2ExperimentalWarned = true\n    process.emitWarning('H2 support is experimental, expect them to change at any time.', {\n      code: 'UNDICI-H2'\n    })\n  }\n\n  const session = http2.connect(client[kUrl], {\n    createConnection: () => socket,\n    peerMaxConcurrentStreams: client[kMaxConcurrentStreams]\n  })\n\n  session[kOpenStreams] = 0\n  session[kClient] = client\n  session[kSocket] = socket\n\n  util.addListener(session, 'error', onHttp2SessionError)\n  util.addListener(session, 'frameError', onHttp2FrameError)\n  util.addListener(session, 'end', onHttp2SessionEnd)\n  util.addListener(session, 'goaway', onHTTP2GoAway)\n  util.addListener(session, 'close', function () {\n    const { [kClient]: client } = this\n    const { [kSocket]: socket } = client\n\n    const err = this[kSocket][kError] || this[kError] || new SocketError('closed', util.getSocketInfo(socket))\n\n    client[kHTTP2Session] = null\n\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n\n      // Fail entire queue.\n      const requests = client[kQueue].splice(client[kRunningIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(client, request, err)\n      }\n    }\n  })\n\n  session.unref()\n\n  client[kHTTP2Session] = session\n  socket[kHTTP2Session] = session\n\n  util.addListener(socket, 'error', function (err) {\n    assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n    this[kError] = err\n\n    this[kClient][kOnError](err)\n  })\n\n  util.addListener(socket, 'end', function () {\n    util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n  })\n\n  util.addListener(socket, 'close', function () {\n    const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n    client[kSocket] = null\n\n    if (this[kHTTP2Session] != null) {\n      this[kHTTP2Session].destroy(err)\n    }\n\n    client[kPendingIdx] = client[kRunningIdx]\n\n    assert(client[kRunning] === 0)\n\n    client.emit('disconnect', client[kUrl], [client], err)\n\n    client[kResume]()\n  })\n\n  let closed = false\n  socket.on('close', () => {\n    closed = true\n  })\n\n  return {\n    version: 'h2',\n    defaultPipelining: Infinity,\n    write (...args) {\n      return writeH2(client, ...args)\n    },\n    resume () {\n      resumeH2(client)\n    },\n    destroy (err, callback) {\n      if (closed) {\n        queueMicrotask(callback)\n      } else {\n        // Destroying the socket will trigger the session close\n        socket.destroy(err).on('close', callback)\n      }\n    },\n    get destroyed () {\n      return socket.destroyed\n    },\n    busy () {\n      return false\n    }\n  }\n}\n\nfunction resumeH2 (client) {\n  const socket = client[kSocket]\n\n  if (socket?.destroyed === false) {\n    if (client[kSize] === 0 && client[kMaxConcurrentStreams] === 0) {\n      socket.unref()\n      client[kHTTP2Session].unref()\n    } else {\n      socket.ref()\n      client[kHTTP2Session].ref()\n    }\n  }\n}\n\nfunction onHttp2SessionError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  this[kSocket][kError] = err\n  this[kClient][kOnError](err)\n}\n\nfunction onHttp2FrameError (type, code, id) {\n  if (id === 0) {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`)\n    this[kSocket][kError] = err\n    this[kClient][kOnError](err)\n  }\n}\n\nfunction onHttp2SessionEnd () {\n  const err = new SocketError('other side closed', util.getSocketInfo(this[kSocket]))\n  this.destroy(err)\n  util.destroy(this[kSocket], err)\n}\n\n/**\n * This is the root cause of #3011\n * We need to handle GOAWAY frames properly, and trigger the session close\n * along with the socket right away\n */\nfunction onHTTP2GoAway (code) {\n  // We cannot recover, so best to close the session and the socket\n  const err = this[kError] || new SocketError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`, util.getSocketInfo(this))\n  const client = this[kClient]\n\n  client[kSocket] = null\n  client[kHTTPContext] = null\n\n  if (this[kHTTP2Session] != null) {\n    this[kHTTP2Session].destroy(err)\n    this[kHTTP2Session] = null\n  }\n\n  util.destroy(this[kSocket], err)\n\n  // Fail head of pipeline.\n  const request = client[kQueue][client[kRunningIdx]]\n  client[kQueue][client[kRunningIdx]++] = null\n  util.errorRequest(client, request, err)\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  client[kResume]()\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\nfunction writeH2 (client, request) {\n  const session = client[kHTTP2Session]\n  const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request\n\n  if (upgrade) {\n    util.errorRequest(client, request, new Error('Upgrade not supported for H2'))\n    return false\n  }\n\n  const headers = {}\n  for (let n = 0; n < reqHeaders.length; n += 2) {\n    const key = reqHeaders[n + 0]\n    const val = reqHeaders[n + 1]\n\n    if (Array.isArray(val)) {\n      for (let i = 0; i < val.length; i++) {\n        if (headers[key]) {\n          headers[key] += `,${val[i]}`\n        } else {\n          headers[key] = val[i]\n        }\n      }\n    } else {\n      headers[key] = val\n    }\n  }\n\n  /** @type {import('node:http2').ClientHttp2Stream} */\n  let stream\n\n  const { hostname, port } = client[kUrl]\n\n  headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ''}`\n  headers[HTTP2_HEADER_METHOD] = method\n\n  const abort = (err) => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    err = err || new RequestAbortedError()\n\n    util.errorRequest(client, request, err)\n\n    if (stream != null) {\n      util.destroy(stream, err)\n    }\n\n    // We do not destroy the socket as we can continue using the session\n    // the stream get's destroyed and the session remains to create new streams\n    util.destroy(body, err)\n    client[kQueue][client[kRunningIdx]++] = null\n    client[kResume]()\n  }\n\n  try {\n    // We are already connected, streams are pending.\n    // We can call on connect, and wait for abort\n    request.onConnect(abort)\n  } catch (err) {\n    util.errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'CONNECT') {\n    session.ref()\n    // We are already connected, streams are pending, first request\n    // will create a new stream. We trigger a request to create the stream and wait until\n    // `ready` event is triggered\n    // We disabled endStream to allow the user to write to the stream\n    stream = session.request(headers, { endStream: false, signal })\n\n    if (stream.id && !stream.pending) {\n      request.onUpgrade(null, null, stream)\n      ++session[kOpenStreams]\n      client[kQueue][client[kRunningIdx]++] = null\n    } else {\n      stream.once('ready', () => {\n        request.onUpgrade(null, null, stream)\n        ++session[kOpenStreams]\n        client[kQueue][client[kRunningIdx]++] = null\n      })\n    }\n\n    stream.once('close', () => {\n      session[kOpenStreams] -= 1\n      if (session[kOpenStreams] === 0) session.unref()\n    })\n\n    return true\n  }\n\n  // https://tools.ietf.org/html/rfc7540#section-8.3\n  // :path and :scheme headers must be omitted when sending CONNECT\n\n  headers[HTTP2_HEADER_PATH] = path\n  headers[HTTP2_HEADER_SCHEME] = 'https'\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength == null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 || !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  if (contentLength != null) {\n    assert(body, 'no body must not have content length')\n    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`\n  }\n\n  session.ref()\n\n  const shouldEndStream = method === 'GET' || method === 'HEAD' || body === null\n  if (expectContinue) {\n    headers[HTTP2_HEADER_EXPECT] = '100-continue'\n    stream = session.request(headers, { endStream: shouldEndStream, signal })\n\n    stream.once('continue', writeBodyH2)\n  } else {\n    stream = session.request(headers, {\n      endStream: shouldEndStream,\n      signal\n    })\n    writeBodyH2()\n  }\n\n  // Increment counter as we have new streams open\n  ++session[kOpenStreams]\n\n  stream.once('response', headers => {\n    const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers\n    request.onResponseStarted()\n\n    // Due to the stream nature, it is possible we face a race condition\n    // where the stream has been assigned, but the request has been aborted\n    // the request remains in-flight and headers hasn't been received yet\n    // for those scenarios, best effort is to destroy the stream immediately\n    // as there's no value to keep it open.\n    if (request.aborted) {\n      const err = new RequestAbortedError()\n      util.errorRequest(client, request, err)\n      util.destroy(stream, err)\n      return\n    }\n\n    if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), '') === false) {\n      stream.pause()\n    }\n\n    stream.on('data', (chunk) => {\n      if (request.onData(chunk) === false) {\n        stream.pause()\n      }\n    })\n  })\n\n  stream.once('end', () => {\n    // When state is null, it means we haven't consumed body and the stream still do not have\n    // a state.\n    // Present specially when using pipeline or stream\n    if (stream.state?.state == null || stream.state.state < 6) {\n      request.onComplete([])\n    }\n\n    if (session[kOpenStreams] === 0) {\n      // Stream is closed or half-closed-remote (6), decrement counter and cleanup\n      // It does not have sense to continue working with the stream as we do not\n      // have yet RST_STREAM support on client-side\n\n      session.unref()\n    }\n\n    abort(new InformationalError('HTTP/2: stream half-closed (remote)'))\n    client[kQueue][client[kRunningIdx]++] = null\n    client[kPendingIdx] = client[kRunningIdx]\n    client[kResume]()\n  })\n\n  stream.once('close', () => {\n    session[kOpenStreams] -= 1\n    if (session[kOpenStreams] === 0) {\n      session.unref()\n    }\n  })\n\n  stream.once('error', function (err) {\n    abort(err)\n  })\n\n  stream.once('frameError', (type, code) => {\n    abort(new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`))\n  })\n\n  // stream.on('aborted', () => {\n  //   // TODO(HTTP/2): Support aborted\n  // })\n\n  // stream.on('timeout', () => {\n  //   // TODO(HTTP/2): Support timeout\n  // })\n\n  // stream.on('push', headers => {\n  //   // TODO(HTTP/2): Support push\n  // })\n\n  // stream.on('trailers', headers => {\n  //   // TODO(HTTP/2): Support trailers\n  // })\n\n  return true\n\n  function writeBodyH2 () {\n    /* istanbul ignore else: assertion */\n    if (!body || contentLength === 0) {\n      writeBuffer(\n        abort,\n        stream,\n        null,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else if (util.isBuffer(body)) {\n      writeBuffer(\n        abort,\n        stream,\n        body,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else if (util.isBlobLike(body)) {\n      if (typeof body.stream === 'function') {\n        writeIterable(\n          abort,\n          stream,\n          body.stream(),\n          client,\n          request,\n          client[kSocket],\n          contentLength,\n          expectsPayload\n        )\n      } else {\n        writeBlob(\n          abort,\n          stream,\n          body,\n          client,\n          request,\n          client[kSocket],\n          contentLength,\n          expectsPayload\n        )\n      }\n    } else if (util.isStream(body)) {\n      writeStream(\n        abort,\n        client[kSocket],\n        expectsPayload,\n        stream,\n        body,\n        client,\n        request,\n        contentLength\n      )\n    } else if (util.isIterable(body)) {\n      writeIterable(\n        abort,\n        stream,\n        body,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else {\n      assert(false)\n    }\n  }\n}\n\nfunction writeBuffer (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  try {\n    if (body != null && util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n      h2stream.cork()\n      h2stream.write(body)\n      h2stream.uncork()\n      h2stream.end()\n\n      request.onBodySent(body)\n    }\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    request.onRequestSent()\n    client[kResume]()\n  } catch (error) {\n    abort(error)\n  }\n}\n\nfunction writeStream (abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  // For HTTP/2, is enough to pipe the stream\n  const pipe = pipeline(\n    body,\n    h2stream,\n    (err) => {\n      if (err) {\n        util.destroy(pipe, err)\n        abort(err)\n      } else {\n        util.removeAllListeners(pipe)\n        request.onRequestSent()\n\n        if (!expectsPayload) {\n          socket[kReset] = true\n        }\n\n        client[kResume]()\n      }\n    }\n  )\n\n  util.addListener(pipe, 'data', onPipeData)\n\n  function onPipeData (chunk) {\n    request.onBodySent(chunk)\n  }\n}\n\nasync function writeBlob (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    h2stream.cork()\n    h2stream.write(buffer)\n    h2stream.uncork()\n    h2stream.end()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeIterable (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  h2stream\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      const res = h2stream.write(chunk)\n      request.onBodySent(chunk)\n      if (!res) {\n        await waitForDrain()\n      }\n    }\n\n    h2stream.end()\n\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  } finally {\n    h2stream\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nmodule.exports = connectH2\n"]}}