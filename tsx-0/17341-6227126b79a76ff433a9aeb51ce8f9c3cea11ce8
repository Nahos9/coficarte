{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const assert=require(\"node:assert\");const{Readable}=require(\"./readable\");const{InvalidArgumentError,RequestAbortedError}=require(\"../core/errors\");const util=require(\"../core/util\");const{getResolveErrorBodyCallback}=require(\"./util\");const{AsyncResource}=require(\"node:async_hooks\");class RequestHandler extends AsyncResource{static{__name(this,\"RequestHandler\")}constructor(opts,callback){if(!opts||typeof opts!==\"object\"){throw new InvalidArgumentError(\"invalid opts\")}const{signal,method,opaque,body,onInfo,responseHeaders,throwOnError,highWaterMark}=opts;try{if(typeof callback!==\"function\"){throw new InvalidArgumentError(\"invalid callback\")}if(highWaterMark&&(typeof highWaterMark!==\"number\"||highWaterMark<0)){throw new InvalidArgumentError(\"invalid highWaterMark\")}if(signal&&typeof signal.on!==\"function\"&&typeof signal.addEventListener!==\"function\"){throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\")}if(method===\"CONNECT\"){throw new InvalidArgumentError(\"invalid method\")}if(onInfo&&typeof onInfo!==\"function\"){throw new InvalidArgumentError(\"invalid onInfo callback\")}super(\"UNDICI_REQUEST\")}catch(err){if(util.isStream(body)){util.destroy(body.on(\"error\",util.nop),err)}throw err}this.method=method;this.responseHeaders=responseHeaders||null;this.opaque=opaque||null;this.callback=callback;this.res=null;this.abort=null;this.body=body;this.trailers={};this.context=null;this.onInfo=onInfo||null;this.throwOnError=throwOnError;this.highWaterMark=highWaterMark;this.signal=signal;this.reason=null;this.removeAbortListener=null;if(util.isStream(body)){body.on(\"error\",err=>{this.onError(err)})}if(this.signal){if(this.signal.aborted){this.reason=this.signal.reason??new RequestAbortedError}else{this.removeAbortListener=util.addAbortListener(this.signal,()=>{this.reason=this.signal.reason??new RequestAbortedError;if(this.res){util.destroy(this.res,this.reason)}else if(this.abort){this.abort(this.reason)}if(this.removeAbortListener){this.res?.off(\"close\",this.removeAbortListener);this.removeAbortListener();this.removeAbortListener=null}})}}}onConnect(abort,context){if(this.reason){abort(this.reason);return}assert(this.callback);this.abort=abort;this.context=context}onHeaders(statusCode,rawHeaders,resume,statusMessage){const{callback,opaque,abort,context,responseHeaders,highWaterMark}=this;const headers=responseHeaders===\"raw\"?util.parseRawHeaders(rawHeaders):util.parseHeaders(rawHeaders);if(statusCode<200){if(this.onInfo){this.onInfo({statusCode,headers})}return}const parsedHeaders=responseHeaders===\"raw\"?util.parseHeaders(rawHeaders):headers;const contentType=parsedHeaders[\"content-type\"];const contentLength=parsedHeaders[\"content-length\"];const res=new Readable({resume,abort,contentType,contentLength:this.method!==\"HEAD\"&&contentLength?Number(contentLength):null,highWaterMark});if(this.removeAbortListener){res.on(\"close\",this.removeAbortListener)}this.callback=null;this.res=res;if(callback!==null){if(this.throwOnError&&statusCode>=400){this.runInAsyncScope(getResolveErrorBodyCallback,null,{callback,body:res,contentType,statusCode,statusMessage,headers})}else{this.runInAsyncScope(callback,null,null,{statusCode,headers,trailers:this.trailers,opaque,body:res,context})}}}onData(chunk){return this.res.push(chunk)}onComplete(trailers){util.parseHeaders(trailers,this.trailers);this.res.push(null)}onError(err){const{res,callback,body,opaque}=this;if(callback){this.callback=null;queueMicrotask(()=>{this.runInAsyncScope(callback,null,err,{opaque})})}if(res){this.res=null;queueMicrotask(()=>{util.destroy(res,err)})}if(body){this.body=null;util.destroy(body,err)}if(this.removeAbortListener){res?.off(\"close\",this.removeAbortListener);this.removeAbortListener();this.removeAbortListener=null}}}function request(opts,callback){if(callback===void 0){return new Promise((resolve,reject)=>{request.call(this,opts,(err,data)=>{return err?reject(err):resolve(data)})})}try{this.dispatch(opts,new RequestHandler(opts,callback))}catch(err){if(typeof callback!==\"function\"){throw err}const opaque=opts?.opaque;queueMicrotask(()=>callback(err,{opaque}))}}__name(request,\"request\");module.exports=request;module.exports.RequestHandler=RequestHandler;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/api/api-request.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { Readable } = require('./readable')\nconst { InvalidArgumentError, RequestAbortedError } = require('../core/errors')\nconst util = require('../core/util')\nconst { getResolveErrorBodyCallback } = require('./util')\nconst { AsyncResource } = require('node:async_hooks')\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {\n        throw new InvalidArgumentError('invalid highWaterMark')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.method = method\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n    this.throwOnError = throwOnError\n    this.highWaterMark = highWaterMark\n    this.signal = signal\n    this.reason = null\n    this.removeAbortListener = null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    if (this.signal) {\n      if (this.signal.aborted) {\n        this.reason = this.signal.reason ?? new RequestAbortedError()\n      } else {\n        this.removeAbortListener = util.addAbortListener(this.signal, () => {\n          this.reason = this.signal.reason ?? new RequestAbortedError()\n          if (this.res) {\n            util.destroy(this.res, this.reason)\n          } else if (this.abort) {\n            this.abort(this.reason)\n          }\n\n          if (this.removeAbortListener) {\n            this.res?.off('close', this.removeAbortListener)\n            this.removeAbortListener()\n            this.removeAbortListener = null\n          }\n        })\n      }\n    }\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers\n    const contentType = parsedHeaders['content-type']\n    const contentLength = parsedHeaders['content-length']\n    const res = new Readable({\n      resume,\n      abort,\n      contentType,\n      contentLength: this.method !== 'HEAD' && contentLength\n        ? Number(contentLength)\n        : null,\n      highWaterMark\n    })\n\n    if (this.removeAbortListener) {\n      res.on('close', this.removeAbortListener)\n    }\n\n    this.callback = null\n    this.res = res\n    if (callback !== null) {\n      if (this.throwOnError && statusCode >= 400) {\n        this.runInAsyncScope(getResolveErrorBodyCallback, null,\n          { callback, body: res, contentType, statusCode, statusMessage, headers }\n        )\n      } else {\n        this.runInAsyncScope(callback, null, null, {\n          statusCode,\n          headers,\n          trailers: this.trailers,\n          opaque,\n          body: res,\n          context\n        })\n      }\n    }\n  }\n\n  onData (chunk) {\n    return this.res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    util.parseHeaders(trailers, this.trailers)\n    this.res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res, err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n\n    if (this.removeAbortListener) {\n      res?.off('close', this.removeAbortListener)\n      this.removeAbortListener()\n      this.removeAbortListener = null\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\nmodule.exports.RequestHandler = RequestHandler\n"]}}