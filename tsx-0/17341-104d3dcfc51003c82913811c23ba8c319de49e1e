{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{kConstruct}=require(\"../../core/symbols\");const{kEnumerableProperty}=require(\"../../core/util\");const{iteratorMixin,isValidHeaderName,isValidHeaderValue}=require(\"./util\");const{webidl}=require(\"./webidl\");const assert=require(\"node:assert\");const util=require(\"node:util\");const kHeadersMap=Symbol(\"headers map\");const kHeadersSortedMap=Symbol(\"headers map sorted\");function isHTTPWhiteSpaceCharCode(code){return code===10||code===13||code===9||code===32}__name(isHTTPWhiteSpaceCharCode,\"isHTTPWhiteSpaceCharCode\");function headerValueNormalize(potentialValue){let i=0;let j=potentialValue.length;while(j>i&&isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j-1)))--j;while(j>i&&isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))++i;return i===0&&j===potentialValue.length?potentialValue:potentialValue.substring(i,j)}__name(headerValueNormalize,\"headerValueNormalize\");function fill(headers,object){if(Array.isArray(object)){for(let i=0;i<object.length;++i){const header=object[i];if(header.length!==2){throw webidl.errors.exception({header:\"Headers constructor\",message:`expected name/value pair to be length 2, found ${header.length}.`})}appendHeader(headers,header[0],header[1])}}else if(typeof object===\"object\"&&object!==null){const keys=Object.keys(object);for(let i=0;i<keys.length;++i){appendHeader(headers,keys[i],object[keys[i]])}}else{throw webidl.errors.conversionFailed({prefix:\"Headers constructor\",argument:\"Argument 1\",types:[\"sequence<sequence<ByteString>>\",\"record<ByteString, ByteString>\"]})}}__name(fill,\"fill\");function appendHeader(headers,name,value){value=headerValueNormalize(value);if(!isValidHeaderName(name)){throw webidl.errors.invalidArgument({prefix:\"Headers.append\",value:name,type:\"header name\"})}else if(!isValidHeaderValue(value)){throw webidl.errors.invalidArgument({prefix:\"Headers.append\",value,type:\"header value\"})}if(getHeadersGuard(headers)===\"immutable\"){throw new TypeError(\"immutable\")}return getHeadersList(headers).append(name,value,false)}__name(appendHeader,\"appendHeader\");function compareHeaderName(a,b){return a[0]<b[0]?-1:1}__name(compareHeaderName,\"compareHeaderName\");class HeadersList{static{__name(this,\"HeadersList\")}cookies=null;constructor(init){if(init instanceof HeadersList){this[kHeadersMap]=new Map(init[kHeadersMap]);this[kHeadersSortedMap]=init[kHeadersSortedMap];this.cookies=init.cookies===null?null:[...init.cookies]}else{this[kHeadersMap]=new Map(init);this[kHeadersSortedMap]=null}}contains(name,isLowerCase){return this[kHeadersMap].has(isLowerCase?name:name.toLowerCase())}clear(){this[kHeadersMap].clear();this[kHeadersSortedMap]=null;this.cookies=null}append(name,value,isLowerCase){this[kHeadersSortedMap]=null;const lowercaseName=isLowerCase?name:name.toLowerCase();const exists=this[kHeadersMap].get(lowercaseName);if(exists){const delimiter=lowercaseName===\"cookie\"?\"; \":\", \";this[kHeadersMap].set(lowercaseName,{name:exists.name,value:`${exists.value}${delimiter}${value}`})}else{this[kHeadersMap].set(lowercaseName,{name,value})}if(lowercaseName===\"set-cookie\"){(this.cookies??=[]).push(value)}}set(name,value,isLowerCase){this[kHeadersSortedMap]=null;const lowercaseName=isLowerCase?name:name.toLowerCase();if(lowercaseName===\"set-cookie\"){this.cookies=[value]}this[kHeadersMap].set(lowercaseName,{name,value})}delete(name,isLowerCase){this[kHeadersSortedMap]=null;if(!isLowerCase)name=name.toLowerCase();if(name===\"set-cookie\"){this.cookies=null}this[kHeadersMap].delete(name)}get(name,isLowerCase){return this[kHeadersMap].get(isLowerCase?name:name.toLowerCase())?.value??null}*[Symbol.iterator](){for(const{0:name,1:{value}}of this[kHeadersMap]){yield[name,value]}}get entries(){const headers={};if(this[kHeadersMap].size!==0){for(const{name,value}of this[kHeadersMap].values()){headers[name]=value}}return headers}rawValues(){return this[kHeadersMap].values()}get entriesList(){const headers=[];if(this[kHeadersMap].size!==0){for(const{0:lowerName,1:{name,value}}of this[kHeadersMap]){if(lowerName===\"set-cookie\"){for(const cookie of this.cookies){headers.push([name,cookie])}}else{headers.push([name,value])}}}return headers}toSortedArray(){const size=this[kHeadersMap].size;const array=new Array(size);if(size<=32){if(size===0){return array}const iterator=this[kHeadersMap][Symbol.iterator]();const firstValue=iterator.next().value;array[0]=[firstValue[0],firstValue[1].value];assert(firstValue[1].value!==null);for(let i=1,j=0,right=0,left=0,pivot=0,x,value;i<size;++i){value=iterator.next().value;x=array[i]=[value[0],value[1].value];assert(x[1]!==null);left=0;right=i;while(left<right){pivot=left+(right-left>>1);if(array[pivot][0]<=x[0]){left=pivot+1}else{right=pivot}}if(i!==pivot){j=i;while(j>left){array[j]=array[--j]}array[left]=x}}if(!iterator.next().done){throw new TypeError(\"Unreachable\")}return array}else{let i=0;for(const{0:name,1:{value}}of this[kHeadersMap]){array[i++]=[name,value];assert(value!==null)}return array.sort(compareHeaderName)}}}class Headers{static{__name(this,\"Headers\")}#guard;#headersList;constructor(init=void 0){webidl.util.markAsUncloneable(this);if(init===kConstruct){return}this.#headersList=new HeadersList;this.#guard=\"none\";if(init!==void 0){init=webidl.converters.HeadersInit(init,\"Headers contructor\",\"init\");fill(this,init)}}append(name,value){webidl.brandCheck(this,Headers);webidl.argumentLengthCheck(arguments,2,\"Headers.append\");const prefix=\"Headers.append\";name=webidl.converters.ByteString(name,prefix,\"name\");value=webidl.converters.ByteString(value,prefix,\"value\");return appendHeader(this,name,value)}delete(name){webidl.brandCheck(this,Headers);webidl.argumentLengthCheck(arguments,1,\"Headers.delete\");const prefix=\"Headers.delete\";name=webidl.converters.ByteString(name,prefix,\"name\");if(!isValidHeaderName(name)){throw webidl.errors.invalidArgument({prefix:\"Headers.delete\",value:name,type:\"header name\"})}if(this.#guard===\"immutable\"){throw new TypeError(\"immutable\")}if(!this.#headersList.contains(name,false)){return}this.#headersList.delete(name,false)}get(name){webidl.brandCheck(this,Headers);webidl.argumentLengthCheck(arguments,1,\"Headers.get\");const prefix=\"Headers.get\";name=webidl.converters.ByteString(name,prefix,\"name\");if(!isValidHeaderName(name)){throw webidl.errors.invalidArgument({prefix,value:name,type:\"header name\"})}return this.#headersList.get(name,false)}has(name){webidl.brandCheck(this,Headers);webidl.argumentLengthCheck(arguments,1,\"Headers.has\");const prefix=\"Headers.has\";name=webidl.converters.ByteString(name,prefix,\"name\");if(!isValidHeaderName(name)){throw webidl.errors.invalidArgument({prefix,value:name,type:\"header name\"})}return this.#headersList.contains(name,false)}set(name,value){webidl.brandCheck(this,Headers);webidl.argumentLengthCheck(arguments,2,\"Headers.set\");const prefix=\"Headers.set\";name=webidl.converters.ByteString(name,prefix,\"name\");value=webidl.converters.ByteString(value,prefix,\"value\");value=headerValueNormalize(value);if(!isValidHeaderName(name)){throw webidl.errors.invalidArgument({prefix,value:name,type:\"header name\"})}else if(!isValidHeaderValue(value)){throw webidl.errors.invalidArgument({prefix,value,type:\"header value\"})}if(this.#guard===\"immutable\"){throw new TypeError(\"immutable\")}this.#headersList.set(name,value,false)}getSetCookie(){webidl.brandCheck(this,Headers);const list=this.#headersList.cookies;if(list){return[...list]}return[]}get[kHeadersSortedMap](){if(this.#headersList[kHeadersSortedMap]){return this.#headersList[kHeadersSortedMap]}const headers=[];const names=this.#headersList.toSortedArray();const cookies=this.#headersList.cookies;if(cookies===null||cookies.length===1){return this.#headersList[kHeadersSortedMap]=names}for(let i=0;i<names.length;++i){const{0:name,1:value}=names[i];if(name===\"set-cookie\"){for(let j=0;j<cookies.length;++j){headers.push([name,cookies[j]])}}else{headers.push([name,value])}}return this.#headersList[kHeadersSortedMap]=headers}[util.inspect.custom](depth,options){options.depth??=depth;return`Headers ${util.formatWithOptions(options,this.#headersList.entries)}`}static getHeadersGuard(o){return o.#guard}static setHeadersGuard(o,guard){o.#guard=guard}static getHeadersList(o){return o.#headersList}static setHeadersList(o,list){o.#headersList=list}}const{getHeadersGuard,setHeadersGuard,getHeadersList,setHeadersList}=Headers;Reflect.deleteProperty(Headers,\"getHeadersGuard\");Reflect.deleteProperty(Headers,\"setHeadersGuard\");Reflect.deleteProperty(Headers,\"getHeadersList\");Reflect.deleteProperty(Headers,\"setHeadersList\");iteratorMixin(\"Headers\",Headers,kHeadersSortedMap,0,1);Object.defineProperties(Headers.prototype,{append:kEnumerableProperty,delete:kEnumerableProperty,get:kEnumerableProperty,has:kEnumerableProperty,set:kEnumerableProperty,getSetCookie:kEnumerableProperty,[Symbol.toStringTag]:{value:\"Headers\",configurable:true},[util.inspect.custom]:{enumerable:false}});webidl.converters.HeadersInit=function(V,prefix,argument){if(webidl.util.Type(V)===\"Object\"){const iterator=Reflect.get(V,Symbol.iterator);if(!util.types.isProxy(V)&&iterator===Headers.prototype.entries){try{return getHeadersList(V).entriesList}catch{}}if(typeof iterator===\"function\"){return webidl.converters[\"sequence<sequence<ByteString>>\"](V,prefix,argument,iterator.bind(V))}return webidl.converters[\"record<ByteString, ByteString>\"](V,prefix,argument)}throw webidl.errors.conversionFailed({prefix:\"Headers constructor\",argument:\"Argument 1\",types:[\"sequence<sequence<ByteString>>\",\"record<ByteString, ByteString>\"]})};module.exports={fill,compareHeaderName,Headers,HeadersList,getHeadersGuard,setHeadersGuard,setHeadersList,getHeadersList};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/fetch/headers.js"],"sourcesContent":["// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst { kConstruct } = require('../../core/symbols')\nconst { kEnumerableProperty } = require('../../core/util')\nconst {\n  iteratorMixin,\n  isValidHeaderName,\n  isValidHeaderValue\n} = require('./util')\nconst { webidl } = require('./webidl')\nconst assert = require('node:assert')\nconst util = require('node:util')\n\nconst kHeadersMap = Symbol('headers map')\nconst kHeadersSortedMap = Symbol('headers map sorted')\n\n/**\n * @param {number} code\n */\nfunction isHTTPWhiteSpaceCharCode (code) {\n  return code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */\nfunction headerValueNormalize (potentialValue) {\n  //  To normalize a byte sequence potentialValue, remove\n  //  any leading and trailing HTTP whitespace bytes from\n  //  potentialValue.\n  let i = 0; let j = potentialValue.length\n\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i\n\n  return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j)\n}\n\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  // 1. If object is a sequence, then for each header in object:\n  // Note: webidl conversion to array has already been done.\n  if (Array.isArray(object)) {\n    for (let i = 0; i < object.length; ++i) {\n      const header = object[i]\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (header.length !== 2) {\n        throw webidl.errors.exception({\n          header: 'Headers constructor',\n          message: `expected name/value pair to be length 2, found ${header.length}.`\n        })\n      }\n\n      // 2. Append (header’s first item, header’s second item) to headers.\n      appendHeader(headers, header[0], header[1])\n    }\n  } else if (typeof object === 'object' && object !== null) {\n    // Note: null should throw\n\n    // 2. Otherwise, object is a record, then for each key → value in object,\n    //    append (key, value) to headers\n    const keys = Object.keys(object)\n    for (let i = 0; i < keys.length; ++i) {\n      appendHeader(headers, keys[i], object[keys[i]])\n    }\n  } else {\n    throw webidl.errors.conversionFailed({\n      prefix: 'Headers constructor',\n      argument: 'Argument 1',\n      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n    })\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-headers-append\n */\nfunction appendHeader (headers, name, value) {\n  // 1. Normalize value.\n  value = headerValueNormalize(value)\n\n  // 2. If name is not a header name or value is not a\n  //    header value, then throw a TypeError.\n  if (!isValidHeaderName(name)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value: name,\n      type: 'header name'\n    })\n  } else if (!isValidHeaderValue(value)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value,\n      type: 'header value'\n    })\n  }\n\n  // 3. If headers’s guard is \"immutable\", then throw a TypeError.\n  // 4. Otherwise, if headers’s guard is \"request\" and name is a\n  //    forbidden header name, return.\n  // 5. Otherwise, if headers’s guard is \"request-no-cors\":\n  //    TODO\n  // Note: undici does not implement forbidden header names\n  if (getHeadersGuard(headers) === 'immutable') {\n    throw new TypeError('immutable')\n  }\n\n  // 6. Otherwise, if headers’s guard is \"response\" and name is a\n  //    forbidden response-header name, return.\n\n  // 7. Append (name, value) to headers’s header list.\n  return getHeadersList(headers).append(name, value, false)\n\n  // 8. If headers’s guard is \"request-no-cors\", then remove\n  //    privileged no-CORS request headers from headers\n}\n\nfunction compareHeaderName (a, b) {\n  return a[0] < b[0] ? -1 : 1\n}\n\nclass HeadersList {\n  /** @type {[string, string][]|null} */\n  cookies = null\n\n  constructor (init) {\n    if (init instanceof HeadersList) {\n      this[kHeadersMap] = new Map(init[kHeadersMap])\n      this[kHeadersSortedMap] = init[kHeadersSortedMap]\n      this.cookies = init.cookies === null ? null : [...init.cookies]\n    } else {\n      this[kHeadersMap] = new Map(init)\n      this[kHeadersSortedMap] = null\n    }\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#header-list-contains\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */\n  contains (name, isLowerCase) {\n    // A header list list contains a header name name if list\n    // contains a header whose name is a byte-case-insensitive\n    // match for name.\n\n    return this[kHeadersMap].has(isLowerCase ? name : name.toLowerCase())\n  }\n\n  clear () {\n    this[kHeadersMap].clear()\n    this[kHeadersSortedMap] = null\n    this.cookies = null\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-append\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */\n  append (name, value, isLowerCase) {\n    this[kHeadersSortedMap] = null\n\n    // 1. If list contains name, then set name to the first such\n    //    header’s name.\n    const lowercaseName = isLowerCase ? name : name.toLowerCase()\n    const exists = this[kHeadersMap].get(lowercaseName)\n\n    // 2. Append (name, value) to list.\n    if (exists) {\n      const delimiter = lowercaseName === 'cookie' ? '; ' : ', '\n      this[kHeadersMap].set(lowercaseName, {\n        name: exists.name,\n        value: `${exists.value}${delimiter}${value}`\n      })\n    } else {\n      this[kHeadersMap].set(lowercaseName, { name, value })\n    }\n\n    if (lowercaseName === 'set-cookie') {\n      (this.cookies ??= []).push(value)\n    }\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-set\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */\n  set (name, value, isLowerCase) {\n    this[kHeadersSortedMap] = null\n    const lowercaseName = isLowerCase ? name : name.toLowerCase()\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies = [value]\n    }\n\n    // 1. If list contains name, then set the value of\n    //    the first such header to value and remove the\n    //    others.\n    // 2. Otherwise, append header (name, value) to list.\n    this[kHeadersMap].set(lowercaseName, { name, value })\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-delete\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */\n  delete (name, isLowerCase) {\n    this[kHeadersSortedMap] = null\n    if (!isLowerCase) name = name.toLowerCase()\n\n    if (name === 'set-cookie') {\n      this.cookies = null\n    }\n\n    this[kHeadersMap].delete(name)\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-get\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   * @returns {string | null}\n   */\n  get (name, isLowerCase) {\n    // 1. If list does not contain name, then return null.\n    // 2. Return the values of all headers in list whose name\n    //    is a byte-case-insensitive match for name,\n    //    separated from each other by 0x2C 0x20, in order.\n    return this[kHeadersMap].get(isLowerCase ? name : name.toLowerCase())?.value ?? null\n  }\n\n  * [Symbol.iterator] () {\n    // use the lowercased name\n    for (const { 0: name, 1: { value } } of this[kHeadersMap]) {\n      yield [name, value]\n    }\n  }\n\n  get entries () {\n    const headers = {}\n\n    if (this[kHeadersMap].size !== 0) {\n      for (const { name, value } of this[kHeadersMap].values()) {\n        headers[name] = value\n      }\n    }\n\n    return headers\n  }\n\n  rawValues () {\n    return this[kHeadersMap].values()\n  }\n\n  get entriesList () {\n    const headers = []\n\n    if (this[kHeadersMap].size !== 0) {\n      for (const { 0: lowerName, 1: { name, value } } of this[kHeadersMap]) {\n        if (lowerName === 'set-cookie') {\n          for (const cookie of this.cookies) {\n            headers.push([name, cookie])\n          }\n        } else {\n          headers.push([name, value])\n        }\n      }\n    }\n\n    return headers\n  }\n\n  // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set\n  toSortedArray () {\n    const size = this[kHeadersMap].size\n    const array = new Array(size)\n    // In most cases, you will use the fast-path.\n    // fast-path: Use binary insertion sort for small arrays.\n    if (size <= 32) {\n      if (size === 0) {\n        // If empty, it is an empty array. To avoid the first index assignment.\n        return array\n      }\n      // Improve performance by unrolling loop and avoiding double-loop.\n      // Double-loop-less version of the binary insertion sort.\n      const iterator = this[kHeadersMap][Symbol.iterator]()\n      const firstValue = iterator.next().value\n      // set [name, value] to first index.\n      array[0] = [firstValue[0], firstValue[1].value]\n      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n      // 3.2.2. Assert: value is non-null.\n      assert(firstValue[1].value !== null)\n      for (\n        let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value;\n        i < size;\n        ++i\n      ) {\n        // get next value\n        value = iterator.next().value\n        // set [name, value] to current index.\n        x = array[i] = [value[0], value[1].value]\n        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n        // 3.2.2. Assert: value is non-null.\n        assert(x[1] !== null)\n        left = 0\n        right = i\n        // binary search\n        while (left < right) {\n          // middle index\n          pivot = left + ((right - left) >> 1)\n          // compare header name\n          if (array[pivot][0] <= x[0]) {\n            left = pivot + 1\n          } else {\n            right = pivot\n          }\n        }\n        if (i !== pivot) {\n          j = i\n          while (j > left) {\n            array[j] = array[--j]\n          }\n          array[left] = x\n        }\n      }\n      /* c8 ignore next 4 */\n      if (!iterator.next().done) {\n        // This is for debugging and will never be called.\n        throw new TypeError('Unreachable')\n      }\n      return array\n    } else {\n      // This case would be a rare occurrence.\n      // slow-path: fallback\n      let i = 0\n      for (const { 0: name, 1: { value } } of this[kHeadersMap]) {\n        array[i++] = [name, value]\n        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n        // 3.2.2. Assert: value is non-null.\n        assert(value !== null)\n      }\n      return array.sort(compareHeaderName)\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n  #guard\n  #headersList\n\n  constructor (init = undefined) {\n    webidl.util.markAsUncloneable(this)\n\n    if (init === kConstruct) {\n      return\n    }\n\n    this.#headersList = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set this’s guard to \"none\".\n    this.#guard = 'none'\n\n    // 2. If init is given, then fill this with init.\n    if (init !== undefined) {\n      init = webidl.converters.HeadersInit(init, 'Headers contructor', 'init')\n      fill(this, init)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-append\n  append (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, 'Headers.append')\n\n    const prefix = 'Headers.append'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n    value = webidl.converters.ByteString(value, prefix, 'value')\n\n    return appendHeader(this, name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-delete\n  delete (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.delete')\n\n    const prefix = 'Headers.delete'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.delete',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. If this’s guard is \"immutable\", then throw a TypeError.\n    // 3. Otherwise, if this’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 4. Otherwise, if this’s guard is \"request-no-cors\", name\n    //    is not a no-CORS-safelisted request-header name, and\n    //    name is not a privileged no-CORS request-header name,\n    //    return.\n    // 5. Otherwise, if this’s guard is \"response\" and name is\n    //    a forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this.#guard === 'immutable') {\n      throw new TypeError('immutable')\n    }\n\n    // 6. If this’s header list does not contain name, then\n    //    return.\n    if (!this.#headersList.contains(name, false)) {\n      return\n    }\n\n    // 7. Delete name from this’s header list.\n    // 8. If this’s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this.\n    this.#headersList.delete(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-get\n  get (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.get')\n\n    const prefix = 'Headers.get'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return the result of getting name from this’s header\n    //    list.\n    return this.#headersList.get(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-has\n  has (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.has')\n\n    const prefix = 'Headers.has'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return true if this’s header list contains name;\n    //    otherwise false.\n    return this.#headersList.contains(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-set\n  set (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, 'Headers.set')\n\n    const prefix = 'Headers.set'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n    value = webidl.converters.ByteString(value, prefix, 'value')\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value)\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value,\n        type: 'header value'\n      })\n    }\n\n    // 3. If this’s guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if this’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 5. Otherwise, if this’s guard is \"request-no-cors\" and\n    //    name/value is not a no-CORS-safelisted request-header,\n    //    return.\n    // 6. Otherwise, if this’s guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this.#guard === 'immutable') {\n      throw new TypeError('immutable')\n    }\n\n    // 7. Set (name, value) in this’s header list.\n    // 8. If this’s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this\n    this.#headersList.set(name, value, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n  getSetCookie () {\n    webidl.brandCheck(this, Headers)\n\n    // 1. If this’s header list does not contain `Set-Cookie`, then return « ».\n    // 2. Return the values of all headers in this’s header list whose name is\n    //    a byte-case-insensitive match for `Set-Cookie`, in order.\n\n    const list = this.#headersList.cookies\n\n    if (list) {\n      return [...list]\n    }\n\n    return []\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n  get [kHeadersSortedMap] () {\n    if (this.#headersList[kHeadersSortedMap]) {\n      return this.#headersList[kHeadersSortedMap]\n    }\n\n    // 1. Let headers be an empty list of headers with the key being the name\n    //    and value the value.\n    const headers = []\n\n    // 2. Let names be the result of convert header names to a sorted-lowercase\n    //    set with all the names of the headers in list.\n    const names = this.#headersList.toSortedArray()\n\n    const cookies = this.#headersList.cookies\n\n    // fast-path\n    if (cookies === null || cookies.length === 1) {\n      // Note: The non-null assertion of value has already been done by `HeadersList#toSortedArray`\n      return (this.#headersList[kHeadersSortedMap] = names)\n    }\n\n    // 3. For each name of names:\n    for (let i = 0; i < names.length; ++i) {\n      const { 0: name, 1: value } = names[i]\n      // 1. If name is `set-cookie`, then:\n      if (name === 'set-cookie') {\n        // 1. Let values be a list of all values of headers in list whose name\n        //    is a byte-case-insensitive match for name, in order.\n\n        // 2. For each value of values:\n        // 1. Append (name, value) to headers.\n        for (let j = 0; j < cookies.length; ++j) {\n          headers.push([name, cookies[j]])\n        }\n      } else {\n        // 2. Otherwise:\n\n        // 1. Let value be the result of getting name from list.\n\n        // 2. Assert: value is non-null.\n        // Note: This operation was done by `HeadersList#toSortedArray`.\n\n        // 3. Append (name, value) to headers.\n        headers.push([name, value])\n      }\n    }\n\n    // 4. Return headers.\n    return (this.#headersList[kHeadersSortedMap] = headers)\n  }\n\n  [util.inspect.custom] (depth, options) {\n    options.depth ??= depth\n\n    return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`\n  }\n\n  static getHeadersGuard (o) {\n    return o.#guard\n  }\n\n  static setHeadersGuard (o, guard) {\n    o.#guard = guard\n  }\n\n  static getHeadersList (o) {\n    return o.#headersList\n  }\n\n  static setHeadersList (o, list) {\n    o.#headersList = list\n  }\n}\n\nconst { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers\nReflect.deleteProperty(Headers, 'getHeadersGuard')\nReflect.deleteProperty(Headers, 'setHeadersGuard')\nReflect.deleteProperty(Headers, 'getHeadersList')\nReflect.deleteProperty(Headers, 'setHeadersList')\n\niteratorMixin('Headers', Headers, kHeadersSortedMap, 0, 1)\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  getSetCookie: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Headers',\n    configurable: true\n  },\n  [util.inspect.custom]: {\n    enumerable: false\n  }\n})\n\nwebidl.converters.HeadersInit = function (V, prefix, argument) {\n  if (webidl.util.Type(V) === 'Object') {\n    const iterator = Reflect.get(V, Symbol.iterator)\n\n    // A work-around to ensure we send the properly-cased Headers when V is a Headers object.\n    // Read https://github.com/nodejs/undici/pull/3159#issuecomment-2075537226 before touching, please.\n    if (!util.types.isProxy(V) && iterator === Headers.prototype.entries) { // Headers object\n      try {\n        return getHeadersList(V).entriesList\n      } catch {\n        // fall-through\n      }\n    }\n\n    if (typeof iterator === 'function') {\n      return webidl.converters['sequence<sequence<ByteString>>'](V, prefix, argument, iterator.bind(V))\n    }\n\n    return webidl.converters['record<ByteString, ByteString>'](V, prefix, argument)\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix: 'Headers constructor',\n    argument: 'Argument 1',\n    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n  })\n}\n\nmodule.exports = {\n  fill,\n  // for test.\n  compareHeaderName,\n  Headers,\n  HeadersList,\n  getHeadersGuard,\n  setHeadersGuard,\n  setHeadersList,\n  getHeadersList\n}\n"]}}