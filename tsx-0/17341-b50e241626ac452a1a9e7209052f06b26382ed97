{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const assert=require(\"node:assert\");const{Readable}=require(\"node:stream\");const{RequestAbortedError,NotSupportedError,InvalidArgumentError,AbortError}=require(\"../core/errors\");const util=require(\"../core/util\");const{ReadableStreamFrom}=require(\"../core/util\");const kConsume=Symbol(\"kConsume\");const kReading=Symbol(\"kReading\");const kBody=Symbol(\"kBody\");const kAbort=Symbol(\"kAbort\");const kContentType=Symbol(\"kContentType\");const kContentLength=Symbol(\"kContentLength\");const noop=__name(()=>{},\"noop\");class BodyReadable extends Readable{static{__name(this,\"BodyReadable\")}constructor({resume,abort,contentType=\"\",contentLength,highWaterMark=64*1024}){super({autoDestroy:true,read:resume,highWaterMark});this._readableState.dataEmitted=false;this[kAbort]=abort;this[kConsume]=null;this[kBody]=null;this[kContentType]=contentType;this[kContentLength]=contentLength;this[kReading]=false}destroy(err){if(!err&&!this._readableState.endEmitted){err=new RequestAbortedError}if(err){this[kAbort]()}return super.destroy(err)}_destroy(err,callback){if(!this[kReading]){setImmediate(()=>{callback(err)})}else{callback(err)}}on(ev,...args){if(ev===\"data\"||ev===\"readable\"){this[kReading]=true}return super.on(ev,...args)}addListener(ev,...args){return this.on(ev,...args)}off(ev,...args){const ret=super.off(ev,...args);if(ev===\"data\"||ev===\"readable\"){this[kReading]=this.listenerCount(\"data\")>0||this.listenerCount(\"readable\")>0}return ret}removeListener(ev,...args){return this.off(ev,...args)}push(chunk){if(this[kConsume]&&chunk!==null){consumePush(this[kConsume],chunk);return this[kReading]?super.push(chunk):true}return super.push(chunk)}async text(){return consume(this,\"text\")}async json(){return consume(this,\"json\")}async blob(){return consume(this,\"blob\")}async bytes(){return consume(this,\"bytes\")}async arrayBuffer(){return consume(this,\"arrayBuffer\")}async formData(){throw new NotSupportedError}get bodyUsed(){return util.isDisturbed(this)}get body(){if(!this[kBody]){this[kBody]=ReadableStreamFrom(this);if(this[kConsume]){this[kBody].getReader();assert(this[kBody].locked)}}return this[kBody]}async dump(opts){let limit=Number.isFinite(opts?.limit)?opts.limit:128*1024;const signal=opts?.signal;if(signal!=null&&(typeof signal!==\"object\"||!(\"aborted\"in signal))){throw new InvalidArgumentError(\"signal must be an AbortSignal\")}signal?.throwIfAborted();if(this._readableState.closeEmitted){return null}return await new Promise((resolve,reject)=>{if(this[kContentLength]>limit){this.destroy(new AbortError)}const onAbort=__name(()=>{this.destroy(signal.reason??new AbortError)},\"onAbort\");signal?.addEventListener(\"abort\",onAbort);this.on(\"close\",function(){signal?.removeEventListener(\"abort\",onAbort);if(signal?.aborted){reject(signal.reason??new AbortError)}else{resolve(null)}}).on(\"error\",noop).on(\"data\",function(chunk){limit-=chunk.length;if(limit<=0){this.destroy()}}).resume()})}}function isLocked(self){return self[kBody]&&self[kBody].locked===true||self[kConsume]}__name(isLocked,\"isLocked\");function isUnusable(self){return util.isDisturbed(self)||isLocked(self)}__name(isUnusable,\"isUnusable\");async function consume(stream,type){assert(!stream[kConsume]);return new Promise((resolve,reject)=>{if(isUnusable(stream)){const rState=stream._readableState;if(rState.destroyed&&rState.closeEmitted===false){stream.on(\"error\",err=>{reject(err)}).on(\"close\",()=>{reject(new TypeError(\"unusable\"))})}else{reject(rState.errored??new TypeError(\"unusable\"))}}else{queueMicrotask(()=>{stream[kConsume]={type,stream,resolve,reject,length:0,body:[]};stream.on(\"error\",function(err){consumeFinish(this[kConsume],err)}).on(\"close\",function(){if(this[kConsume].body!==null){consumeFinish(this[kConsume],new RequestAbortedError)}});consumeStart(stream[kConsume])})}})}__name(consume,\"consume\");function consumeStart(consume2){if(consume2.body===null){return}const{_readableState:state}=consume2.stream;if(state.bufferIndex){const start=state.bufferIndex;const end=state.buffer.length;for(let n=start;n<end;n++){consumePush(consume2,state.buffer[n])}}else{for(const chunk of state.buffer){consumePush(consume2,chunk)}}if(state.endEmitted){consumeEnd(this[kConsume])}else{consume2.stream.on(\"end\",function(){consumeEnd(this[kConsume])})}consume2.stream.resume();while(consume2.stream.read()!=null){}}__name(consumeStart,\"consumeStart\");function chunksDecode(chunks,length){if(chunks.length===0||length===0){return\"\"}const buffer=chunks.length===1?chunks[0]:Buffer.concat(chunks,length);const bufferLength=buffer.length;const start=bufferLength>2&&buffer[0]===239&&buffer[1]===187&&buffer[2]===191?3:0;return buffer.utf8Slice(start,bufferLength)}__name(chunksDecode,\"chunksDecode\");function chunksConcat(chunks,length){if(chunks.length===0||length===0){return new Uint8Array(0)}if(chunks.length===1){return new Uint8Array(chunks[0])}const buffer=new Uint8Array(Buffer.allocUnsafeSlow(length).buffer);let offset=0;for(let i=0;i<chunks.length;++i){const chunk=chunks[i];buffer.set(chunk,offset);offset+=chunk.length}return buffer}__name(chunksConcat,\"chunksConcat\");function consumeEnd(consume2){const{type,body,resolve,stream,length}=consume2;try{if(type===\"text\"){resolve(chunksDecode(body,length))}else if(type===\"json\"){resolve(JSON.parse(chunksDecode(body,length)))}else if(type===\"arrayBuffer\"){resolve(chunksConcat(body,length).buffer)}else if(type===\"blob\"){resolve(new Blob(body,{type:stream[kContentType]}))}else if(type===\"bytes\"){resolve(chunksConcat(body,length))}consumeFinish(consume2)}catch(err){stream.destroy(err)}}__name(consumeEnd,\"consumeEnd\");function consumePush(consume2,chunk){consume2.length+=chunk.length;consume2.body.push(chunk)}__name(consumePush,\"consumePush\");function consumeFinish(consume2,err){if(consume2.body===null){return}if(err){consume2.reject(err)}else{consume2.resolve()}consume2.type=null;consume2.stream=null;consume2.resolve=null;consume2.reject=null;consume2.length=0;consume2.body=null}__name(consumeFinish,\"consumeFinish\");module.exports={Readable:BodyReadable,chunksDecode};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["consume"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/api/readable.js"],"sourcesContent":["// Ported from https://github.com/nodejs/undici/pull/907\n\n'use strict'\n\nconst assert = require('node:assert')\nconst { Readable } = require('node:stream')\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = require('../core/errors')\nconst util = require('../core/util')\nconst { ReadableStreamFrom } = require('../core/util')\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('kAbort')\nconst kContentType = Symbol('kContentType')\nconst kContentLength = Symbol('kContentLength')\n\nconst noop = () => {}\n\nclass BodyReadable extends Readable {\n  constructor ({\n    resume,\n    abort,\n    contentType = '',\n    contentLength,\n    highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n  }) {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n    this[kConsume] = null\n    this[kBody] = null\n    this[kContentType] = contentType\n    this[kContentLength] = contentLength\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false\n  }\n\n  destroy (err) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    return super.destroy(err)\n  }\n\n  _destroy (err, callback) {\n    // Workaround for Node \"bug\". If the stream is destroyed in same\n    // tick as it is created, then a user who is waiting for a\n    // promise (i.e micro tick) for installing a 'error' listener will\n    // never get a chance and will always encounter an unhandled exception.\n    if (!this[kReading]) {\n      setImmediate(() => {\n        callback(err)\n      })\n    } else {\n      callback(err)\n    }\n  }\n\n  on (ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true\n    }\n    return super.on(ev, ...args)\n  }\n\n  addListener (ev, ...args) {\n    return this.on(ev, ...args)\n  }\n\n  off (ev, ...args) {\n    const ret = super.off(ev, ...args)\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  removeListener (ev, ...args) {\n    return this.off(ev, ...args)\n  }\n\n  push (chunk) {\n    if (this[kConsume] && chunk !== null) {\n      consumePush(this[kConsume], chunk)\n      return this[kReading] ? super.push(chunk) : true\n    }\n    return super.push(chunk)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text () {\n    return consume(this, 'text')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json () {\n    return consume(this, 'json')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob () {\n    return consume(this, 'blob')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bytes\n  async bytes () {\n    return consume(this, 'bytes')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n\n  async dump (opts) {\n    let limit = Number.isFinite(opts?.limit) ? opts.limit : 128 * 1024\n    const signal = opts?.signal\n\n    if (signal != null && (typeof signal !== 'object' || !('aborted' in signal))) {\n      throw new InvalidArgumentError('signal must be an AbortSignal')\n    }\n\n    signal?.throwIfAborted()\n\n    if (this._readableState.closeEmitted) {\n      return null\n    }\n\n    return await new Promise((resolve, reject) => {\n      if (this[kContentLength] > limit) {\n        this.destroy(new AbortError())\n      }\n\n      const onAbort = () => {\n        this.destroy(signal.reason ?? new AbortError())\n      }\n      signal?.addEventListener('abort', onAbort)\n\n      this\n        .on('close', function () {\n          signal?.removeEventListener('abort', onAbort)\n          if (signal?.aborted) {\n            reject(signal.reason ?? new AbortError())\n          } else {\n            resolve(null)\n          }\n        })\n        .on('error', noop)\n        .on('data', function (chunk) {\n          limit -= chunk.length\n          if (limit <= 0) {\n            this.destroy()\n          }\n        })\n        .resume()\n    })\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked (self) {\n  // Consume is an implicit lock.\n  return (self[kBody] && self[kBody].locked === true) || self[kConsume]\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable (self) {\n  return util.isDisturbed(self) || isLocked(self)\n}\n\nasync function consume (stream, type) {\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    if (isUnusable(stream)) {\n      const rState = stream._readableState\n      if (rState.destroyed && rState.closeEmitted === false) {\n        stream\n          .on('error', err => {\n            reject(err)\n          })\n          .on('close', () => {\n            reject(new TypeError('unusable'))\n          })\n      } else {\n        reject(rState.errored ?? new TypeError('unusable'))\n      }\n    } else {\n      queueMicrotask(() => {\n        stream[kConsume] = {\n          type,\n          stream,\n          resolve,\n          reject,\n          length: 0,\n          body: []\n        }\n\n        stream\n          .on('error', function (err) {\n            consumeFinish(this[kConsume], err)\n          })\n          .on('close', function () {\n            if (this[kConsume].body !== null) {\n              consumeFinish(this[kConsume], new RequestAbortedError())\n            }\n          })\n\n        consumeStart(stream[kConsume])\n      })\n    }\n  })\n}\n\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  if (state.bufferIndex) {\n    const start = state.bufferIndex\n    const end = state.buffer.length\n    for (let n = start; n < end; n++) {\n      consumePush(consume, state.buffer[n])\n    }\n  } else {\n    for (const chunk of state.buffer) {\n      consumePush(consume, chunk)\n    }\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume])\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume])\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n */\nfunction chunksDecode (chunks, length) {\n  if (chunks.length === 0 || length === 0) {\n    return ''\n  }\n  const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length)\n  const bufferLength = buffer.length\n\n  // Skip BOM.\n  const start =\n    bufferLength > 2 &&\n    buffer[0] === 0xef &&\n    buffer[1] === 0xbb &&\n    buffer[2] === 0xbf\n      ? 3\n      : 0\n  return buffer.utf8Slice(start, bufferLength)\n}\n\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n * @returns {Uint8Array}\n */\nfunction chunksConcat (chunks, length) {\n  if (chunks.length === 0 || length === 0) {\n    return new Uint8Array(0)\n  }\n  if (chunks.length === 1) {\n    // fast-path\n    return new Uint8Array(chunks[0])\n  }\n  const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer)\n\n  let offset = 0\n  for (let i = 0; i < chunks.length; ++i) {\n    const chunk = chunks[i]\n    buffer.set(chunk, offset)\n    offset += chunk.length\n  }\n\n  return buffer\n}\n\nfunction consumeEnd (consume) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(chunksDecode(body, length))\n    } else if (type === 'json') {\n      resolve(JSON.parse(chunksDecode(body, length)))\n    } else if (type === 'arrayBuffer') {\n      resolve(chunksConcat(body, length).buffer)\n    } else if (type === 'blob') {\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    } else if (type === 'bytes') {\n      resolve(chunksConcat(body, length))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  consume.type = null\n  consume.stream = null\n  consume.resolve = null\n  consume.reject = null\n  consume.length = 0\n  consume.body = null\n}\n\nmodule.exports = { Readable: BodyReadable, chunksDecode }\n"]}}