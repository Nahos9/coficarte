{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{kConstruct}=require(\"./symbols\");const{urlEquals,getFieldValues}=require(\"./util\");const{kEnumerableProperty,isDisturbed}=require(\"../../core/util\");const{webidl}=require(\"../fetch/webidl\");const{Response,cloneResponse,fromInnerResponse}=require(\"../fetch/response\");const{Request,fromInnerRequest}=require(\"../fetch/request\");const{kState}=require(\"../fetch/symbols\");const{fetching}=require(\"../fetch/index\");const{urlIsHttpHttpsScheme,createDeferredPromise,readAllBytes}=require(\"../fetch/util\");const assert=require(\"node:assert\");class Cache{static{__name(this,\"Cache\")}#relevantRequestResponseList;constructor(){if(arguments[0]!==kConstruct){webidl.illegalConstructor()}webidl.util.markAsUncloneable(this);this.#relevantRequestResponseList=arguments[1]}async match(request,options={}){webidl.brandCheck(this,Cache);const prefix=\"Cache.match\";webidl.argumentLengthCheck(arguments,1,prefix);request=webidl.converters.RequestInfo(request,prefix,\"request\");options=webidl.converters.CacheQueryOptions(options,prefix,\"options\");const p=this.#internalMatchAll(request,options,1);if(p.length===0){return}return p[0]}async matchAll(request=void 0,options={}){webidl.brandCheck(this,Cache);const prefix=\"Cache.matchAll\";if(request!==void 0)request=webidl.converters.RequestInfo(request,prefix,\"request\");options=webidl.converters.CacheQueryOptions(options,prefix,\"options\");return this.#internalMatchAll(request,options)}async add(request){webidl.brandCheck(this,Cache);const prefix=\"Cache.add\";webidl.argumentLengthCheck(arguments,1,prefix);request=webidl.converters.RequestInfo(request,prefix,\"request\");const requests=[request];const responseArrayPromise=this.addAll(requests);return await responseArrayPromise}async addAll(requests){webidl.brandCheck(this,Cache);const prefix=\"Cache.addAll\";webidl.argumentLengthCheck(arguments,1,prefix);const responsePromises=[];const requestList=[];for(let request of requests){if(request===void 0){throw webidl.errors.conversionFailed({prefix,argument:\"Argument 1\",types:[\"undefined is not allowed\"]})}request=webidl.converters.RequestInfo(request);if(typeof request===\"string\"){continue}const r=request[kState];if(!urlIsHttpHttpsScheme(r.url)||r.method!==\"GET\"){throw webidl.errors.exception({header:prefix,message:\"Expected http/s scheme when method is not GET.\"})}}const fetchControllers=[];for(const request of requests){const r=new Request(request)[kState];if(!urlIsHttpHttpsScheme(r.url)){throw webidl.errors.exception({header:prefix,message:\"Expected http/s scheme.\"})}r.initiator=\"fetch\";r.destination=\"subresource\";requestList.push(r);const responsePromise=createDeferredPromise();fetchControllers.push(fetching({request:r,processResponse(response){if(response.type===\"error\"||response.status===206||response.status<200||response.status>299){responsePromise.reject(webidl.errors.exception({header:\"Cache.addAll\",message:\"Received an invalid status code or the request failed.\"}))}else if(response.headersList.contains(\"vary\")){const fieldValues=getFieldValues(response.headersList.get(\"vary\"));for(const fieldValue of fieldValues){if(fieldValue===\"*\"){responsePromise.reject(webidl.errors.exception({header:\"Cache.addAll\",message:\"invalid vary field value\"}));for(const controller of fetchControllers){controller.abort()}return}}}},processResponseEndOfBody(response){if(response.aborted){responsePromise.reject(new DOMException(\"aborted\",\"AbortError\"));return}responsePromise.resolve(response)}}));responsePromises.push(responsePromise.promise)}const p=Promise.all(responsePromises);const responses=await p;const operations=[];let index=0;for(const response of responses){const operation={type:\"put\",request:requestList[index],response};operations.push(operation);index++}const cacheJobPromise=createDeferredPromise();let errorData=null;try{this.#batchCacheOperations(operations)}catch(e){errorData=e}queueMicrotask(()=>{if(errorData===null){cacheJobPromise.resolve(void 0)}else{cacheJobPromise.reject(errorData)}});return cacheJobPromise.promise}async put(request,response){webidl.brandCheck(this,Cache);const prefix=\"Cache.put\";webidl.argumentLengthCheck(arguments,2,prefix);request=webidl.converters.RequestInfo(request,prefix,\"request\");response=webidl.converters.Response(response,prefix,\"response\");let innerRequest=null;if(request instanceof Request){innerRequest=request[kState]}else{innerRequest=new Request(request)[kState]}if(!urlIsHttpHttpsScheme(innerRequest.url)||innerRequest.method!==\"GET\"){throw webidl.errors.exception({header:prefix,message:\"Expected an http/s scheme when method is not GET\"})}const innerResponse=response[kState];if(innerResponse.status===206){throw webidl.errors.exception({header:prefix,message:\"Got 206 status\"})}if(innerResponse.headersList.contains(\"vary\")){const fieldValues=getFieldValues(innerResponse.headersList.get(\"vary\"));for(const fieldValue of fieldValues){if(fieldValue===\"*\"){throw webidl.errors.exception({header:prefix,message:\"Got * vary field value\"})}}}if(innerResponse.body&&(isDisturbed(innerResponse.body.stream)||innerResponse.body.stream.locked)){throw webidl.errors.exception({header:prefix,message:\"Response body is locked or disturbed\"})}const clonedResponse=cloneResponse(innerResponse);const bodyReadPromise=createDeferredPromise();if(innerResponse.body!=null){const stream=innerResponse.body.stream;const reader=stream.getReader();readAllBytes(reader).then(bodyReadPromise.resolve,bodyReadPromise.reject)}else{bodyReadPromise.resolve(void 0)}const operations=[];const operation={type:\"put\",request:innerRequest,response:clonedResponse};operations.push(operation);const bytes=await bodyReadPromise.promise;if(clonedResponse.body!=null){clonedResponse.body.source=bytes}const cacheJobPromise=createDeferredPromise();let errorData=null;try{this.#batchCacheOperations(operations)}catch(e){errorData=e}queueMicrotask(()=>{if(errorData===null){cacheJobPromise.resolve()}else{cacheJobPromise.reject(errorData)}});return cacheJobPromise.promise}async delete(request,options={}){webidl.brandCheck(this,Cache);const prefix=\"Cache.delete\";webidl.argumentLengthCheck(arguments,1,prefix);request=webidl.converters.RequestInfo(request,prefix,\"request\");options=webidl.converters.CacheQueryOptions(options,prefix,\"options\");let r=null;if(request instanceof Request){r=request[kState];if(r.method!==\"GET\"&&!options.ignoreMethod){return false}}else{assert(typeof request===\"string\");r=new Request(request)[kState]}const operations=[];const operation={type:\"delete\",request:r,options};operations.push(operation);const cacheJobPromise=createDeferredPromise();let errorData=null;let requestResponses;try{requestResponses=this.#batchCacheOperations(operations)}catch(e){errorData=e}queueMicrotask(()=>{if(errorData===null){cacheJobPromise.resolve(!!requestResponses?.length)}else{cacheJobPromise.reject(errorData)}});return cacheJobPromise.promise}async keys(request=void 0,options={}){webidl.brandCheck(this,Cache);const prefix=\"Cache.keys\";if(request!==void 0)request=webidl.converters.RequestInfo(request,prefix,\"request\");options=webidl.converters.CacheQueryOptions(options,prefix,\"options\");let r=null;if(request!==void 0){if(request instanceof Request){r=request[kState];if(r.method!==\"GET\"&&!options.ignoreMethod){return[]}}else if(typeof request===\"string\"){r=new Request(request)[kState]}}const promise=createDeferredPromise();const requests=[];if(request===void 0){for(const requestResponse of this.#relevantRequestResponseList){requests.push(requestResponse[0])}}else{const requestResponses=this.#queryCache(r,options);for(const requestResponse of requestResponses){requests.push(requestResponse[0])}}queueMicrotask(()=>{const requestList=[];for(const request2 of requests){const requestObject=fromInnerRequest(request2,new AbortController().signal,\"immutable\");requestList.push(requestObject)}promise.resolve(Object.freeze(requestList))});return promise.promise}#batchCacheOperations(operations){const cache=this.#relevantRequestResponseList;const backupCache=[...cache];const addedItems=[];const resultList=[];try{for(const operation of operations){if(operation.type!==\"delete\"&&operation.type!==\"put\"){throw webidl.errors.exception({header:\"Cache.#batchCacheOperations\",message:'operation type does not match \"delete\" or \"put\"'})}if(operation.type===\"delete\"&&operation.response!=null){throw webidl.errors.exception({header:\"Cache.#batchCacheOperations\",message:\"delete operation should not have an associated response\"})}if(this.#queryCache(operation.request,operation.options,addedItems).length){throw new DOMException(\"???\",\"InvalidStateError\")}let requestResponses;if(operation.type===\"delete\"){requestResponses=this.#queryCache(operation.request,operation.options);if(requestResponses.length===0){return[]}for(const requestResponse of requestResponses){const idx=cache.indexOf(requestResponse);assert(idx!==-1);cache.splice(idx,1)}}else if(operation.type===\"put\"){if(operation.response==null){throw webidl.errors.exception({header:\"Cache.#batchCacheOperations\",message:\"put operation should have an associated response\"})}const r=operation.request;if(!urlIsHttpHttpsScheme(r.url)){throw webidl.errors.exception({header:\"Cache.#batchCacheOperations\",message:\"expected http or https scheme\"})}if(r.method!==\"GET\"){throw webidl.errors.exception({header:\"Cache.#batchCacheOperations\",message:\"not get method\"})}if(operation.options!=null){throw webidl.errors.exception({header:\"Cache.#batchCacheOperations\",message:\"options must not be defined\"})}requestResponses=this.#queryCache(operation.request);for(const requestResponse of requestResponses){const idx=cache.indexOf(requestResponse);assert(idx!==-1);cache.splice(idx,1)}cache.push([operation.request,operation.response]);addedItems.push([operation.request,operation.response])}resultList.push([operation.request,operation.response])}return resultList}catch(e){this.#relevantRequestResponseList.length=0;this.#relevantRequestResponseList=backupCache;throw e}}#queryCache(requestQuery,options,targetStorage){const resultList=[];const storage=targetStorage??this.#relevantRequestResponseList;for(const requestResponse of storage){const[cachedRequest,cachedResponse]=requestResponse;if(this.#requestMatchesCachedItem(requestQuery,cachedRequest,cachedResponse,options)){resultList.push(requestResponse)}}return resultList}#requestMatchesCachedItem(requestQuery,request,response=null,options){const queryURL=new URL(requestQuery.url);const cachedURL=new URL(request.url);if(options?.ignoreSearch){cachedURL.search=\"\";queryURL.search=\"\"}if(!urlEquals(queryURL,cachedURL,true)){return false}if(response==null||options?.ignoreVary||!response.headersList.contains(\"vary\")){return true}const fieldValues=getFieldValues(response.headersList.get(\"vary\"));for(const fieldValue of fieldValues){if(fieldValue===\"*\"){return false}const requestValue=request.headersList.get(fieldValue);const queryValue=requestQuery.headersList.get(fieldValue);if(requestValue!==queryValue){return false}}return true}#internalMatchAll(request,options,maxResponses=Infinity){let r=null;if(request!==void 0){if(request instanceof Request){r=request[kState];if(r.method!==\"GET\"&&!options.ignoreMethod){return[]}}else if(typeof request===\"string\"){r=new Request(request)[kState]}}const responses=[];if(request===void 0){for(const requestResponse of this.#relevantRequestResponseList){responses.push(requestResponse[1])}}else{const requestResponses=this.#queryCache(r,options);for(const requestResponse of requestResponses){responses.push(requestResponse[1])}}const responseList=[];for(const response of responses){const responseObject=fromInnerResponse(response,\"immutable\");responseList.push(responseObject.clone());if(responseList.length>=maxResponses){break}}return Object.freeze(responseList)}}Object.defineProperties(Cache.prototype,{[Symbol.toStringTag]:{value:\"Cache\",configurable:true},match:kEnumerableProperty,matchAll:kEnumerableProperty,add:kEnumerableProperty,addAll:kEnumerableProperty,put:kEnumerableProperty,delete:kEnumerableProperty,keys:kEnumerableProperty});const cacheQueryOptionConverters=[{key:\"ignoreSearch\",converter:webidl.converters.boolean,defaultValue:()=>false},{key:\"ignoreMethod\",converter:webidl.converters.boolean,defaultValue:()=>false},{key:\"ignoreVary\",converter:webidl.converters.boolean,defaultValue:()=>false}];webidl.converters.CacheQueryOptions=webidl.dictionaryConverter(cacheQueryOptionConverters);webidl.converters.MultiCacheQueryOptions=webidl.dictionaryConverter([...cacheQueryOptionConverters,{key:\"cacheName\",converter:webidl.converters.DOMString}]);webidl.converters.Response=webidl.interfaceConverter(Response);webidl.converters[\"sequence<RequestInfo>\"]=webidl.sequenceConverter(webidl.converters.RequestInfo);module.exports={Cache};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["request"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/cache/cache.js"],"sourcesContent":["'use strict'\n\nconst { kConstruct } = require('./symbols')\nconst { urlEquals, getFieldValues } = require('./util')\nconst { kEnumerableProperty, isDisturbed } = require('../../core/util')\nconst { webidl } = require('../fetch/webidl')\nconst { Response, cloneResponse, fromInnerResponse } = require('../fetch/response')\nconst { Request, fromInnerRequest } = require('../fetch/request')\nconst { kState } = require('../fetch/symbols')\nconst { fetching } = require('../fetch/index')\nconst { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require('../fetch/util')\nconst assert = require('node:assert')\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../types/cache').CacheQueryOptions} options\n */\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */\n\nclass Cache {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */\n  #relevantRequestResponseList\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n\n    webidl.util.markAsUncloneable(this)\n    this.#relevantRequestResponseList = arguments[1]\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.match'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    const p = this.#internalMatchAll(request, options, 1)\n\n    if (p.length === 0) {\n      return\n    }\n\n    return p[0]\n  }\n\n  async matchAll (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.matchAll'\n    if (request !== undefined) request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    return this.#internalMatchAll(request, options)\n  }\n\n  async add (request) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.add'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n\n    // 1.\n    const requests = [request]\n\n    // 2.\n    const responseArrayPromise = this.addAll(requests)\n\n    // 3.\n    return await responseArrayPromise\n  }\n\n  async addAll (requests) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.addAll'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    // 1.\n    const responsePromises = []\n\n    // 2.\n    const requestList = []\n\n    // 3.\n    for (let request of requests) {\n      if (request === undefined) {\n        throw webidl.errors.conversionFailed({\n          prefix,\n          argument: 'Argument 1',\n          types: ['undefined is not allowed']\n        })\n      }\n\n      request = webidl.converters.RequestInfo(request)\n\n      if (typeof request === 'string') {\n        continue\n      }\n\n      // 3.1\n      const r = request[kState]\n\n      // 3.2\n      if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {\n        throw webidl.errors.exception({\n          header: prefix,\n          message: 'Expected http/s scheme when method is not GET.'\n        })\n      }\n    }\n\n    // 4.\n    /** @type {ReturnType<typeof fetching>[]} */\n    const fetchControllers = []\n\n    // 5.\n    for (const request of requests) {\n      // 5.1\n      const r = new Request(request)[kState]\n\n      // 5.2\n      if (!urlIsHttpHttpsScheme(r.url)) {\n        throw webidl.errors.exception({\n          header: prefix,\n          message: 'Expected http/s scheme.'\n        })\n      }\n\n      // 5.4\n      r.initiator = 'fetch'\n      r.destination = 'subresource'\n\n      // 5.5\n      requestList.push(r)\n\n      // 5.6\n      const responsePromise = createDeferredPromise()\n\n      // 5.7\n      fetchControllers.push(fetching({\n        request: r,\n        processResponse (response) {\n          // 1.\n          if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {\n            responsePromise.reject(webidl.errors.exception({\n              header: 'Cache.addAll',\n              message: 'Received an invalid status code or the request failed.'\n            }))\n          } else if (response.headersList.contains('vary')) { // 2.\n            // 2.1\n            const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n            // 2.2\n            for (const fieldValue of fieldValues) {\n              // 2.2.1\n              if (fieldValue === '*') {\n                responsePromise.reject(webidl.errors.exception({\n                  header: 'Cache.addAll',\n                  message: 'invalid vary field value'\n                }))\n\n                for (const controller of fetchControllers) {\n                  controller.abort()\n                }\n\n                return\n              }\n            }\n          }\n        },\n        processResponseEndOfBody (response) {\n          // 1.\n          if (response.aborted) {\n            responsePromise.reject(new DOMException('aborted', 'AbortError'))\n            return\n          }\n\n          // 2.\n          responsePromise.resolve(response)\n        }\n      }))\n\n      // 5.8\n      responsePromises.push(responsePromise.promise)\n    }\n\n    // 6.\n    const p = Promise.all(responsePromises)\n\n    // 7.\n    const responses = await p\n\n    // 7.1\n    const operations = []\n\n    // 7.2\n    let index = 0\n\n    // 7.3\n    for (const response of responses) {\n      // 7.3.1\n      /** @type {CacheBatchOperation} */\n      const operation = {\n        type: 'put', // 7.3.2\n        request: requestList[index], // 7.3.3\n        response // 7.3.4\n      }\n\n      operations.push(operation) // 7.3.5\n\n      index++ // 7.3.6\n    }\n\n    // 7.5\n    const cacheJobPromise = createDeferredPromise()\n\n    // 7.6.1\n    let errorData = null\n\n    // 7.6.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 7.6.3\n    queueMicrotask(() => {\n      // 7.6.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve(undefined)\n      } else {\n        // 7.6.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    // 7.7\n    return cacheJobPromise.promise\n  }\n\n  async put (request, response) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.put'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n    response = webidl.converters.Response(response, prefix, 'response')\n\n    // 1.\n    let innerRequest = null\n\n    // 2.\n    if (request instanceof Request) {\n      innerRequest = request[kState]\n    } else { // 3.\n      innerRequest = new Request(request)[kState]\n    }\n\n    // 4.\n    if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Expected an http/s scheme when method is not GET'\n      })\n    }\n\n    // 5.\n    const innerResponse = response[kState]\n\n    // 6.\n    if (innerResponse.status === 206) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Got 206 status'\n      })\n    }\n\n    // 7.\n    if (innerResponse.headersList.contains('vary')) {\n      // 7.1.\n      const fieldValues = getFieldValues(innerResponse.headersList.get('vary'))\n\n      // 7.2.\n      for (const fieldValue of fieldValues) {\n        // 7.2.1\n        if (fieldValue === '*') {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: 'Got * vary field value'\n          })\n        }\n      }\n    }\n\n    // 8.\n    if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Response body is locked or disturbed'\n      })\n    }\n\n    // 9.\n    const clonedResponse = cloneResponse(innerResponse)\n\n    // 10.\n    const bodyReadPromise = createDeferredPromise()\n\n    // 11.\n    if (innerResponse.body != null) {\n      // 11.1\n      const stream = innerResponse.body.stream\n\n      // 11.2\n      const reader = stream.getReader()\n\n      // 11.3\n      readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject)\n    } else {\n      bodyReadPromise.resolve(undefined)\n    }\n\n    // 12.\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    // 13.\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'put', // 14.\n      request: innerRequest, // 15.\n      response: clonedResponse // 16.\n    }\n\n    // 17.\n    operations.push(operation)\n\n    // 19.\n    const bytes = await bodyReadPromise.promise\n\n    if (clonedResponse.body != null) {\n      clonedResponse.body.source = bytes\n    }\n\n    // 19.1\n    const cacheJobPromise = createDeferredPromise()\n\n    // 19.2.1\n    let errorData = null\n\n    // 19.2.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 19.2.3\n    queueMicrotask(() => {\n      // 19.2.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve()\n      } else { // 19.2.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  async delete (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    /**\n     * @type {Request}\n     */\n    let r = null\n\n    if (request instanceof Request) {\n      r = request[kState]\n\n      if (r.method !== 'GET' && !options.ignoreMethod) {\n        return false\n      }\n    } else {\n      assert(typeof request === 'string')\n\n      r = new Request(request)[kState]\n    }\n\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'delete',\n      request: r,\n      options\n    }\n\n    operations.push(operation)\n\n    const cacheJobPromise = createDeferredPromise()\n\n    let errorData = null\n    let requestResponses\n\n    try {\n      requestResponses = this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    queueMicrotask(() => {\n      if (errorData === null) {\n        cacheJobPromise.resolve(!!requestResponses?.length)\n      } else {\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @returns {Promise<readonly Request[]>}\n   */\n  async keys (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.keys'\n\n    if (request !== undefined) request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      // 2.1\n      if (request instanceof Request) {\n        // 2.1.1\n        r = request[kState]\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') { // 2.2\n        r = new Request(request)[kState]\n      }\n    }\n\n    // 4.\n    const promise = createDeferredPromise()\n\n    // 5.\n    // 5.1\n    const requests = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        // 5.2.1.1\n        requests.push(requestResponse[0])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        // 5.3.2.1\n        requests.push(requestResponse[0])\n      }\n    }\n\n    // 5.4\n    queueMicrotask(() => {\n      // 5.4.1\n      const requestList = []\n\n      // 5.4.2\n      for (const request of requests) {\n        const requestObject = fromInnerRequest(\n          request,\n          new AbortController().signal,\n          'immutable'\n        )\n        // 5.4.2.1\n        requestList.push(requestObject)\n      }\n\n      // 5.4.3\n      promise.resolve(Object.freeze(requestList))\n    })\n\n    return promise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */\n  #batchCacheOperations (operations) {\n    // 1.\n    const cache = this.#relevantRequestResponseList\n\n    // 2.\n    const backupCache = [...cache]\n\n    // 3.\n    const addedItems = []\n\n    // 4.1\n    const resultList = []\n\n    try {\n      // 4.2\n      for (const operation of operations) {\n        // 4.2.1\n        if (operation.type !== 'delete' && operation.type !== 'put') {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'operation type does not match \"delete\" or \"put\"'\n          })\n        }\n\n        // 4.2.2\n        if (operation.type === 'delete' && operation.response != null) {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'delete operation should not have an associated response'\n          })\n        }\n\n        // 4.2.3\n        if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n          throw new DOMException('???', 'InvalidStateError')\n        }\n\n        // 4.2.4\n        let requestResponses\n\n        // 4.2.5\n        if (operation.type === 'delete') {\n          // 4.2.5.1\n          requestResponses = this.#queryCache(operation.request, operation.options)\n\n          // TODO: the spec is wrong, this is needed to pass WPTs\n          if (requestResponses.length === 0) {\n            return []\n          }\n\n          // 4.2.5.2\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.5.2.1\n            cache.splice(idx, 1)\n          }\n        } else if (operation.type === 'put') { // 4.2.6\n          // 4.2.6.1\n          if (operation.response == null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'put operation should have an associated response'\n            })\n          }\n\n          // 4.2.6.2\n          const r = operation.request\n\n          // 4.2.6.3\n          if (!urlIsHttpHttpsScheme(r.url)) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'expected http or https scheme'\n            })\n          }\n\n          // 4.2.6.4\n          if (r.method !== 'GET') {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'not get method'\n            })\n          }\n\n          // 4.2.6.5\n          if (operation.options != null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'options must not be defined'\n            })\n          }\n\n          // 4.2.6.6\n          requestResponses = this.#queryCache(operation.request)\n\n          // 4.2.6.7\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.6.7.1\n            cache.splice(idx, 1)\n          }\n\n          // 4.2.6.8\n          cache.push([operation.request, operation.response])\n\n          // 4.2.6.10\n          addedItems.push([operation.request, operation.response])\n        }\n\n        // 4.2.7\n        resultList.push([operation.request, operation.response])\n      }\n\n      // 4.3\n      return resultList\n    } catch (e) { // 5.\n      // 5.1\n      this.#relevantRequestResponseList.length = 0\n\n      // 5.2\n      this.#relevantRequestResponseList = backupCache\n\n      // 5.3\n      throw e\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */\n  #queryCache (requestQuery, options, targetStorage) {\n    /** @type {requestResponseList} */\n    const resultList = []\n\n    const storage = targetStorage ?? this.#relevantRequestResponseList\n\n    for (const requestResponse of storage) {\n      const [cachedRequest, cachedResponse] = requestResponse\n      if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n        resultList.push(requestResponse)\n      }\n    }\n\n    return resultList\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */\n  #requestMatchesCachedItem (requestQuery, request, response = null, options) {\n    // if (options?.ignoreMethod === false && request.method === 'GET') {\n    //   return false\n    // }\n\n    const queryURL = new URL(requestQuery.url)\n\n    const cachedURL = new URL(request.url)\n\n    if (options?.ignoreSearch) {\n      cachedURL.search = ''\n\n      queryURL.search = ''\n    }\n\n    if (!urlEquals(queryURL, cachedURL, true)) {\n      return false\n    }\n\n    if (\n      response == null ||\n      options?.ignoreVary ||\n      !response.headersList.contains('vary')\n    ) {\n      return true\n    }\n\n    const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n    for (const fieldValue of fieldValues) {\n      if (fieldValue === '*') {\n        return false\n      }\n\n      const requestValue = request.headersList.get(fieldValue)\n      const queryValue = requestQuery.headersList.get(fieldValue)\n\n      // If one has the header and the other doesn't, or one has\n      // a different value than the other, return false\n      if (requestValue !== queryValue) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  #internalMatchAll (request, options, maxResponses = Infinity) {\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      if (request instanceof Request) {\n        // 2.1.1\n        r = request[kState]\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') {\n        // 2.2.1\n        r = new Request(request)[kState]\n      }\n    }\n\n    // 5.\n    // 5.1\n    const responses = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        responses.push(requestResponse[1])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        responses.push(requestResponse[1])\n      }\n    }\n\n    // 5.4\n    // We don't implement CORs so we don't need to loop over the responses, yay!\n\n    // 5.5.1\n    const responseList = []\n\n    // 5.5.2\n    for (const response of responses) {\n      // 5.5.2.1\n      const responseObject = fromInnerResponse(response, 'immutable')\n\n      responseList.push(responseObject.clone())\n\n      if (responseList.length >= maxResponses) {\n        break\n      }\n    }\n\n    // 6.\n    return Object.freeze(responseList)\n  }\n}\n\nObject.defineProperties(Cache.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'Cache',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  matchAll: kEnumerableProperty,\n  add: kEnumerableProperty,\n  addAll: kEnumerableProperty,\n  put: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nconst cacheQueryOptionConverters = [\n  {\n    key: 'ignoreSearch',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'ignoreMethod',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'ignoreVary',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  }\n]\n\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters)\n\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([\n  ...cacheQueryOptionConverters,\n  {\n    key: 'cacheName',\n    converter: webidl.converters.DOMString\n  }\n])\n\nwebidl.converters.Response = webidl.interfaceConverter(Response)\n\nwebidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(\n  webidl.converters.RequestInfo\n)\n\nmodule.exports = {\n  Cache\n}\n"]}}