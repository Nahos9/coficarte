{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const assert=require(\"node:assert\");const util=require(\"../core/util.js\");const{channels}=require(\"../core/diagnostics.js\");const timers=require(\"../util/timers.js\");const{RequestContentLengthMismatchError,ResponseContentLengthMismatchError,RequestAbortedError,HeadersTimeoutError,HeadersOverflowError,SocketError,InformationalError,BodyTimeoutError,HTTPParserError,ResponseExceededMaxSizeError}=require(\"../core/errors.js\");const{kUrl,kReset,kClient,kParser,kBlocking,kRunning,kPending,kSize,kWriting,kQueue,kNoRef,kKeepAliveDefaultTimeout,kHostHeader,kPendingIdx,kRunningIdx,kError,kPipelining,kSocket,kKeepAliveTimeoutValue,kMaxHeadersSize,kKeepAliveMaxTimeout,kKeepAliveTimeoutThreshold,kHeadersTimeout,kBodyTimeout,kStrictContentLength,kMaxRequests,kCounter,kMaxResponseSize,kOnError,kResume,kHTTPContext}=require(\"../core/symbols.js\");const constants=require(\"../llhttp/constants.js\");const EMPTY_BUF=Buffer.alloc(0);const FastBuffer=Buffer[Symbol.species];const addListener=util.addListener;const removeAllListeners=util.removeAllListeners;let extractBody;async function lazyllhttp(){const llhttpWasmData=process.env.JEST_WORKER_ID?require(\"../llhttp/llhttp-wasm.js\"):void 0;let mod;try{mod=await WebAssembly.compile(require(\"../llhttp/llhttp_simd-wasm.js\"))}catch(e){mod=await WebAssembly.compile(llhttpWasmData||require(\"../llhttp/llhttp-wasm.js\"))}return await WebAssembly.instantiate(mod,{env:{wasm_on_url:(p,at,len)=>{return 0},wasm_on_status:(p,at,len)=>{assert(currentParser.ptr===p);const start=at-currentBufferPtr+currentBufferRef.byteOffset;return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer,start,len))||0},wasm_on_message_begin:p=>{assert(currentParser.ptr===p);return currentParser.onMessageBegin()||0},wasm_on_header_field:(p,at,len)=>{assert(currentParser.ptr===p);const start=at-currentBufferPtr+currentBufferRef.byteOffset;return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer,start,len))||0},wasm_on_header_value:(p,at,len)=>{assert(currentParser.ptr===p);const start=at-currentBufferPtr+currentBufferRef.byteOffset;return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer,start,len))||0},wasm_on_headers_complete:(p,statusCode,upgrade,shouldKeepAlive)=>{assert(currentParser.ptr===p);return currentParser.onHeadersComplete(statusCode,Boolean(upgrade),Boolean(shouldKeepAlive))||0},wasm_on_body:(p,at,len)=>{assert(currentParser.ptr===p);const start=at-currentBufferPtr+currentBufferRef.byteOffset;return currentParser.onBody(new FastBuffer(currentBufferRef.buffer,start,len))||0},wasm_on_message_complete:p=>{assert(currentParser.ptr===p);return currentParser.onMessageComplete()||0}}})}__name(lazyllhttp,\"lazyllhttp\");let llhttpInstance=null;let llhttpPromise=lazyllhttp();llhttpPromise.catch();let currentParser=null;let currentBufferRef=null;let currentBufferSize=0;let currentBufferPtr=null;const USE_NATIVE_TIMER=0;const USE_FAST_TIMER=1;const TIMEOUT_HEADERS=2|USE_FAST_TIMER;const TIMEOUT_BODY=4|USE_FAST_TIMER;const TIMEOUT_KEEP_ALIVE=8|USE_NATIVE_TIMER;class Parser{static{__name(this,\"Parser\")}constructor(client,socket,{exports:exports2}){assert(Number.isFinite(client[kMaxHeadersSize])&&client[kMaxHeadersSize]>0);this.llhttp=exports2;this.ptr=this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);this.client=client;this.socket=socket;this.timeout=null;this.timeoutValue=null;this.timeoutType=null;this.statusCode=null;this.statusText=\"\";this.upgrade=false;this.headers=[];this.headersSize=0;this.headersMaxSize=client[kMaxHeadersSize];this.shouldKeepAlive=false;this.paused=false;this.resume=this.resume.bind(this);this.bytesRead=0;this.keepAlive=\"\";this.contentLength=\"\";this.connection=\"\";this.maxResponseSize=client[kMaxResponseSize]}setTimeout(delay,type){if(delay!==this.timeoutValue||type&USE_FAST_TIMER^this.timeoutType&USE_FAST_TIMER){if(this.timeout){timers.clearTimeout(this.timeout);this.timeout=null}if(delay){if(type&USE_FAST_TIMER){this.timeout=timers.setFastTimeout(onParserTimeout,delay,new WeakRef(this))}else{this.timeout=setTimeout(onParserTimeout,delay,new WeakRef(this));this.timeout.unref()}}this.timeoutValue=delay}else if(this.timeout){if(this.timeout.refresh){this.timeout.refresh()}}this.timeoutType=type}resume(){if(this.socket.destroyed||!this.paused){return}assert(this.ptr!=null);assert(currentParser==null);this.llhttp.llhttp_resume(this.ptr);assert(this.timeoutType===TIMEOUT_BODY);if(this.timeout){if(this.timeout.refresh){this.timeout.refresh()}}this.paused=false;this.execute(this.socket.read()||EMPTY_BUF);this.readMore()}readMore(){while(!this.paused&&this.ptr){const chunk=this.socket.read();if(chunk===null){break}this.execute(chunk)}}execute(data){assert(this.ptr!=null);assert(currentParser==null);assert(!this.paused);const{socket,llhttp}=this;if(data.length>currentBufferSize){if(currentBufferPtr){llhttp.free(currentBufferPtr)}currentBufferSize=Math.ceil(data.length/4096)*4096;currentBufferPtr=llhttp.malloc(currentBufferSize)}new Uint8Array(llhttp.memory.buffer,currentBufferPtr,currentBufferSize).set(data);try{let ret;try{currentBufferRef=data;currentParser=this;ret=llhttp.llhttp_execute(this.ptr,currentBufferPtr,data.length)}catch(err){throw err}finally{currentParser=null;currentBufferRef=null}const offset=llhttp.llhttp_get_error_pos(this.ptr)-currentBufferPtr;if(ret===constants.ERROR.PAUSED_UPGRADE){this.onUpgrade(data.slice(offset))}else if(ret===constants.ERROR.PAUSED){this.paused=true;socket.unshift(data.slice(offset))}else if(ret!==constants.ERROR.OK){const ptr=llhttp.llhttp_get_error_reason(this.ptr);let message=\"\";if(ptr){const len=new Uint8Array(llhttp.memory.buffer,ptr).indexOf(0);message=\"Response does not match the HTTP/1.1 protocol (\"+Buffer.from(llhttp.memory.buffer,ptr,len).toString()+\")\"}throw new HTTPParserError(message,constants.ERROR[ret],data.slice(offset))}}catch(err){util.destroy(socket,err)}}destroy(){assert(this.ptr!=null);assert(currentParser==null);this.llhttp.llhttp_free(this.ptr);this.ptr=null;this.timeout&&timers.clearTimeout(this.timeout);this.timeout=null;this.timeoutValue=null;this.timeoutType=null;this.paused=false}onStatus(buf){this.statusText=buf.toString()}onMessageBegin(){const{socket,client}=this;if(socket.destroyed){return-1}const request=client[kQueue][client[kRunningIdx]];if(!request){return-1}request.onResponseStarted()}onHeaderField(buf){const len=this.headers.length;if((len&1)===0){this.headers.push(buf)}else{this.headers[len-1]=Buffer.concat([this.headers[len-1],buf])}this.trackHeader(buf.length)}onHeaderValue(buf){let len=this.headers.length;if((len&1)===1){this.headers.push(buf);len+=1}else{this.headers[len-1]=Buffer.concat([this.headers[len-1],buf])}const key=this.headers[len-2];if(key.length===10){const headerName=util.bufferToLowerCasedHeaderName(key);if(headerName===\"keep-alive\"){this.keepAlive+=buf.toString()}else if(headerName===\"connection\"){this.connection+=buf.toString()}}else if(key.length===14&&util.bufferToLowerCasedHeaderName(key)===\"content-length\"){this.contentLength+=buf.toString()}this.trackHeader(buf.length)}trackHeader(len){this.headersSize+=len;if(this.headersSize>=this.headersMaxSize){util.destroy(this.socket,new HeadersOverflowError)}}onUpgrade(head){const{upgrade,client,socket,headers,statusCode}=this;assert(upgrade);assert(client[kSocket]===socket);assert(!socket.destroyed);assert(!this.paused);assert((headers.length&1)===0);const request=client[kQueue][client[kRunningIdx]];assert(request);assert(request.upgrade||request.method===\"CONNECT\");this.statusCode=null;this.statusText=\"\";this.shouldKeepAlive=null;this.headers=[];this.headersSize=0;socket.unshift(head);socket[kParser].destroy();socket[kParser]=null;socket[kClient]=null;socket[kError]=null;removeAllListeners(socket);client[kSocket]=null;client[kHTTPContext]=null;client[kQueue][client[kRunningIdx]++]=null;client.emit(\"disconnect\",client[kUrl],[client],new InformationalError(\"upgrade\"));try{request.onUpgrade(statusCode,headers,socket)}catch(err){util.destroy(socket,err)}client[kResume]()}onHeadersComplete(statusCode,upgrade,shouldKeepAlive){const{client,socket,headers,statusText}=this;if(socket.destroyed){return-1}const request=client[kQueue][client[kRunningIdx]];if(!request){return-1}assert(!this.upgrade);assert(this.statusCode<200);if(statusCode===100){util.destroy(socket,new SocketError(\"bad response\",util.getSocketInfo(socket)));return-1}if(upgrade&&!request.upgrade){util.destroy(socket,new SocketError(\"bad upgrade\",util.getSocketInfo(socket)));return-1}assert(this.timeoutType===TIMEOUT_HEADERS);this.statusCode=statusCode;this.shouldKeepAlive=shouldKeepAlive||request.method===\"HEAD\"&&!socket[kReset]&&this.connection.toLowerCase()===\"keep-alive\";if(this.statusCode>=200){const bodyTimeout=request.bodyTimeout!=null?request.bodyTimeout:client[kBodyTimeout];this.setTimeout(bodyTimeout,TIMEOUT_BODY)}else if(this.timeout){if(this.timeout.refresh){this.timeout.refresh()}}if(request.method===\"CONNECT\"){assert(client[kRunning]===1);this.upgrade=true;return 2}if(upgrade){assert(client[kRunning]===1);this.upgrade=true;return 2}assert((this.headers.length&1)===0);this.headers=[];this.headersSize=0;if(this.shouldKeepAlive&&client[kPipelining]){const keepAliveTimeout=this.keepAlive?util.parseKeepAliveTimeout(this.keepAlive):null;if(keepAliveTimeout!=null){const timeout=Math.min(keepAliveTimeout-client[kKeepAliveTimeoutThreshold],client[kKeepAliveMaxTimeout]);if(timeout<=0){socket[kReset]=true}else{client[kKeepAliveTimeoutValue]=timeout}}else{client[kKeepAliveTimeoutValue]=client[kKeepAliveDefaultTimeout]}}else{socket[kReset]=true}const pause=request.onHeaders(statusCode,headers,this.resume,statusText)===false;if(request.aborted){return-1}if(request.method===\"HEAD\"){return 1}if(statusCode<200){return 1}if(socket[kBlocking]){socket[kBlocking]=false;client[kResume]()}return pause?constants.ERROR.PAUSED:0}onBody(buf){const{client,socket,statusCode,maxResponseSize}=this;if(socket.destroyed){return-1}const request=client[kQueue][client[kRunningIdx]];assert(request);assert(this.timeoutType===TIMEOUT_BODY);if(this.timeout){if(this.timeout.refresh){this.timeout.refresh()}}assert(statusCode>=200);if(maxResponseSize>-1&&this.bytesRead+buf.length>maxResponseSize){util.destroy(socket,new ResponseExceededMaxSizeError);return-1}this.bytesRead+=buf.length;if(request.onData(buf)===false){return constants.ERROR.PAUSED}}onMessageComplete(){const{client,socket,statusCode,upgrade,headers,contentLength,bytesRead,shouldKeepAlive}=this;if(socket.destroyed&&(!statusCode||shouldKeepAlive)){return-1}if(upgrade){return}assert(statusCode>=100);assert((this.headers.length&1)===0);const request=client[kQueue][client[kRunningIdx]];assert(request);this.statusCode=null;this.statusText=\"\";this.bytesRead=0;this.contentLength=\"\";this.keepAlive=\"\";this.connection=\"\";this.headers=[];this.headersSize=0;if(statusCode<200){return}if(request.method!==\"HEAD\"&&contentLength&&bytesRead!==parseInt(contentLength,10)){util.destroy(socket,new ResponseContentLengthMismatchError);return-1}request.onComplete(headers);client[kQueue][client[kRunningIdx]++]=null;if(socket[kWriting]){assert(client[kRunning]===0);util.destroy(socket,new InformationalError(\"reset\"));return constants.ERROR.PAUSED}else if(!shouldKeepAlive){util.destroy(socket,new InformationalError(\"reset\"));return constants.ERROR.PAUSED}else if(socket[kReset]&&client[kRunning]===0){util.destroy(socket,new InformationalError(\"reset\"));return constants.ERROR.PAUSED}else if(client[kPipelining]==null||client[kPipelining]===1){setImmediate(()=>client[kResume]())}else{client[kResume]()}}}function onParserTimeout(parser){const{socket,timeoutType,client,paused}=parser.deref();if(timeoutType===TIMEOUT_HEADERS){if(!socket[kWriting]||socket.writableNeedDrain||client[kRunning]>1){assert(!paused,\"cannot be paused while waiting for headers\");util.destroy(socket,new HeadersTimeoutError)}}else if(timeoutType===TIMEOUT_BODY){if(!paused){util.destroy(socket,new BodyTimeoutError)}}else if(timeoutType===TIMEOUT_KEEP_ALIVE){assert(client[kRunning]===0&&client[kKeepAliveTimeoutValue]);util.destroy(socket,new InformationalError(\"socket idle timeout\"))}}__name(onParserTimeout,\"onParserTimeout\");async function connectH1(client,socket){client[kSocket]=socket;if(!llhttpInstance){llhttpInstance=await llhttpPromise;llhttpPromise=null}socket[kNoRef]=false;socket[kWriting]=false;socket[kReset]=false;socket[kBlocking]=false;socket[kParser]=new Parser(client,socket,llhttpInstance);addListener(socket,\"error\",function(err){assert(err.code!==\"ERR_TLS_CERT_ALTNAME_INVALID\");const parser=this[kParser];if(err.code===\"ECONNRESET\"&&parser.statusCode&&!parser.shouldKeepAlive){parser.onMessageComplete();return}this[kError]=err;this[kClient][kOnError](err)});addListener(socket,\"readable\",function(){const parser=this[kParser];if(parser){parser.readMore()}});addListener(socket,\"end\",function(){const parser=this[kParser];if(parser.statusCode&&!parser.shouldKeepAlive){parser.onMessageComplete();return}util.destroy(this,new SocketError(\"other side closed\",util.getSocketInfo(this)))});addListener(socket,\"close\",function(){const client2=this[kClient];const parser=this[kParser];if(parser){if(!this[kError]&&parser.statusCode&&!parser.shouldKeepAlive){parser.onMessageComplete()}this[kParser].destroy();this[kParser]=null}const err=this[kError]||new SocketError(\"closed\",util.getSocketInfo(this));client2[kSocket]=null;client2[kHTTPContext]=null;if(client2.destroyed){assert(client2[kPending]===0);const requests=client2[kQueue].splice(client2[kRunningIdx]);for(let i=0;i<requests.length;i++){const request=requests[i];util.errorRequest(client2,request,err)}}else if(client2[kRunning]>0&&err.code!==\"UND_ERR_INFO\"){const request=client2[kQueue][client2[kRunningIdx]];client2[kQueue][client2[kRunningIdx]++]=null;util.errorRequest(client2,request,err)}client2[kPendingIdx]=client2[kRunningIdx];assert(client2[kRunning]===0);client2.emit(\"disconnect\",client2[kUrl],[client2],err);client2[kResume]()});let closed=false;socket.on(\"close\",()=>{closed=true});return{version:\"h1\",defaultPipelining:1,write(...args){return writeH1(client,...args)},resume(){resumeH1(client)},destroy(err,callback){if(closed){queueMicrotask(callback)}else{socket.destroy(err).on(\"close\",callback)}},get destroyed(){return socket.destroyed},busy(request){if(socket[kWriting]||socket[kReset]||socket[kBlocking]){return true}if(request){if(client[kRunning]>0&&!request.idempotent){return true}if(client[kRunning]>0&&(request.upgrade||request.method===\"CONNECT\")){return true}if(client[kRunning]>0&&util.bodyLength(request.body)!==0&&(util.isStream(request.body)||util.isAsyncIterable(request.body)||util.isFormDataLike(request.body))){return true}}return false}}}__name(connectH1,\"connectH1\");function resumeH1(client){const socket=client[kSocket];if(socket&&!socket.destroyed){if(client[kSize]===0){if(!socket[kNoRef]&&socket.unref){socket.unref();socket[kNoRef]=true}}else if(socket[kNoRef]&&socket.ref){socket.ref();socket[kNoRef]=false}if(client[kSize]===0){if(socket[kParser].timeoutType!==TIMEOUT_KEEP_ALIVE){socket[kParser].setTimeout(client[kKeepAliveTimeoutValue],TIMEOUT_KEEP_ALIVE)}}else if(client[kRunning]>0&&socket[kParser].statusCode<200){if(socket[kParser].timeoutType!==TIMEOUT_HEADERS){const request=client[kQueue][client[kRunningIdx]];const headersTimeout=request.headersTimeout!=null?request.headersTimeout:client[kHeadersTimeout];socket[kParser].setTimeout(headersTimeout,TIMEOUT_HEADERS)}}}}__name(resumeH1,\"resumeH1\");function shouldSendContentLength(method){return method!==\"GET\"&&method!==\"HEAD\"&&method!==\"OPTIONS\"&&method!==\"TRACE\"&&method!==\"CONNECT\"}__name(shouldSendContentLength,\"shouldSendContentLength\");function writeH1(client,request){const{method,path,host,upgrade,blocking,reset}=request;let{body,headers,contentLength}=request;const expectsPayload=method===\"PUT\"||method===\"POST\"||method===\"PATCH\"||method===\"QUERY\"||method===\"PROPFIND\"||method===\"PROPPATCH\";if(util.isFormDataLike(body)){if(!extractBody){extractBody=require(\"../web/fetch/body.js\").extractBody}const[bodyStream,contentType]=extractBody(body);if(request.contentType==null){headers.push(\"content-type\",contentType)}body=bodyStream.stream;contentLength=bodyStream.length}else if(util.isBlobLike(body)&&request.contentType==null&&body.type){headers.push(\"content-type\",body.type)}if(body&&typeof body.read===\"function\"){body.read(0)}const bodyLength=util.bodyLength(body);contentLength=bodyLength??contentLength;if(contentLength===null){contentLength=request.contentLength}if(contentLength===0&&!expectsPayload){contentLength=null}if(shouldSendContentLength(method)&&contentLength>0&&request.contentLength!==null&&request.contentLength!==contentLength){if(client[kStrictContentLength]){util.errorRequest(client,request,new RequestContentLengthMismatchError);return false}process.emitWarning(new RequestContentLengthMismatchError)}const socket=client[kSocket];const abort=__name(err=>{if(request.aborted||request.completed){return}util.errorRequest(client,request,err||new RequestAbortedError);util.destroy(body);util.destroy(socket,new InformationalError(\"aborted\"))},\"abort\");try{request.onConnect(abort)}catch(err){util.errorRequest(client,request,err)}if(request.aborted){return false}if(method===\"HEAD\"){socket[kReset]=true}if(upgrade||method===\"CONNECT\"){socket[kReset]=true}if(reset!=null){socket[kReset]=reset}if(client[kMaxRequests]&&socket[kCounter]++>=client[kMaxRequests]){socket[kReset]=true}if(blocking){socket[kBlocking]=true}let header=`${method} ${path} HTTP/1.1\\r\n`;if(typeof host===\"string\"){header+=`host: ${host}\\r\n`}else{header+=client[kHostHeader]}if(upgrade){header+=`connection: upgrade\\r\nupgrade: ${upgrade}\\r\n`}else if(client[kPipelining]&&!socket[kReset]){header+=\"connection: keep-alive\\r\\n\"}else{header+=\"connection: close\\r\\n\"}if(Array.isArray(headers)){for(let n=0;n<headers.length;n+=2){const key=headers[n+0];const val=headers[n+1];if(Array.isArray(val)){for(let i=0;i<val.length;i++){header+=`${key}: ${val[i]}\\r\n`}}else{header+=`${key}: ${val}\\r\n`}}}if(channels.sendHeaders.hasSubscribers){channels.sendHeaders.publish({request,headers:header,socket})}if(!body||bodyLength===0){writeBuffer(abort,null,client,request,socket,contentLength,header,expectsPayload)}else if(util.isBuffer(body)){writeBuffer(abort,body,client,request,socket,contentLength,header,expectsPayload)}else if(util.isBlobLike(body)){if(typeof body.stream===\"function\"){writeIterable(abort,body.stream(),client,request,socket,contentLength,header,expectsPayload)}else{writeBlob(abort,body,client,request,socket,contentLength,header,expectsPayload)}}else if(util.isStream(body)){writeStream(abort,body,client,request,socket,contentLength,header,expectsPayload)}else if(util.isIterable(body)){writeIterable(abort,body,client,request,socket,contentLength,header,expectsPayload)}else{assert(false)}return true}__name(writeH1,\"writeH1\");function writeStream(abort,body,client,request,socket,contentLength,header,expectsPayload){assert(contentLength!==0||client[kRunning]===0,\"stream body cannot be pipelined\");let finished=false;const writer=new AsyncWriter({abort,socket,request,contentLength,client,expectsPayload,header});const onData=__name(function(chunk){if(finished){return}try{if(!writer.write(chunk)&&this.pause){this.pause()}}catch(err){util.destroy(this,err)}},\"onData\");const onDrain=__name(function(){if(finished){return}if(body.resume){body.resume()}},\"onDrain\");const onClose=__name(function(){queueMicrotask(()=>{body.removeListener(\"error\",onFinished)});if(!finished){const err=new RequestAbortedError;queueMicrotask(()=>onFinished(err))}},\"onClose\");const onFinished=__name(function(err){if(finished){return}finished=true;assert(socket.destroyed||socket[kWriting]&&client[kRunning]<=1);socket.off(\"drain\",onDrain).off(\"error\",onFinished);body.removeListener(\"data\",onData).removeListener(\"end\",onFinished).removeListener(\"close\",onClose);if(!err){try{writer.end()}catch(er){err=er}}writer.destroy(err);if(err&&(err.code!==\"UND_ERR_INFO\"||err.message!==\"reset\")){util.destroy(body,err)}else{util.destroy(body)}},\"onFinished\");body.on(\"data\",onData).on(\"end\",onFinished).on(\"error\",onFinished).on(\"close\",onClose);if(body.resume){body.resume()}socket.on(\"drain\",onDrain).on(\"error\",onFinished);if(body.errorEmitted??body.errored){setImmediate(()=>onFinished(body.errored))}else if(body.endEmitted??body.readableEnded){setImmediate(()=>onFinished(null))}if(body.closeEmitted??body.closed){setImmediate(onClose)}}__name(writeStream,\"writeStream\");function writeBuffer(abort,body,client,request,socket,contentLength,header,expectsPayload){try{if(!body){if(contentLength===0){socket.write(`${header}content-length: 0\\r\n\\r\n`,\"latin1\")}else{assert(contentLength===null,\"no body must not have content length\");socket.write(`${header}\\r\n`,\"latin1\")}}else if(util.isBuffer(body)){assert(contentLength===body.byteLength,\"buffer body must have content length\");socket.cork();socket.write(`${header}content-length: ${contentLength}\\r\n\\r\n`,\"latin1\");socket.write(body);socket.uncork();request.onBodySent(body);if(!expectsPayload&&request.reset!==false){socket[kReset]=true}}request.onRequestSent();client[kResume]()}catch(err){abort(err)}}__name(writeBuffer,\"writeBuffer\");async function writeBlob(abort,body,client,request,socket,contentLength,header,expectsPayload){assert(contentLength===body.size,\"blob body must have content length\");try{if(contentLength!=null&&contentLength!==body.size){throw new RequestContentLengthMismatchError}const buffer=Buffer.from(await body.arrayBuffer());socket.cork();socket.write(`${header}content-length: ${contentLength}\\r\n\\r\n`,\"latin1\");socket.write(buffer);socket.uncork();request.onBodySent(buffer);request.onRequestSent();if(!expectsPayload&&request.reset!==false){socket[kReset]=true}client[kResume]()}catch(err){abort(err)}}__name(writeBlob,\"writeBlob\");async function writeIterable(abort,body,client,request,socket,contentLength,header,expectsPayload){assert(contentLength!==0||client[kRunning]===0,\"iterator body cannot be pipelined\");let callback=null;function onDrain(){if(callback){const cb=callback;callback=null;cb()}}__name(onDrain,\"onDrain\");const waitForDrain=__name(()=>new Promise((resolve,reject)=>{assert(callback===null);if(socket[kError]){reject(socket[kError])}else{callback=resolve}}),\"waitForDrain\");socket.on(\"close\",onDrain).on(\"drain\",onDrain);const writer=new AsyncWriter({abort,socket,request,contentLength,client,expectsPayload,header});try{for await(const chunk of body){if(socket[kError]){throw socket[kError]}if(!writer.write(chunk)){await waitForDrain()}}writer.end()}catch(err){writer.destroy(err)}finally{socket.off(\"close\",onDrain).off(\"drain\",onDrain)}}__name(writeIterable,\"writeIterable\");class AsyncWriter{static{__name(this,\"AsyncWriter\")}constructor({abort,socket,request,contentLength,client,expectsPayload,header}){this.socket=socket;this.request=request;this.contentLength=contentLength;this.client=client;this.bytesWritten=0;this.expectsPayload=expectsPayload;this.header=header;this.abort=abort;socket[kWriting]=true}write(chunk){const{socket,request,contentLength,client,bytesWritten,expectsPayload,header}=this;if(socket[kError]){throw socket[kError]}if(socket.destroyed){return false}const len=Buffer.byteLength(chunk);if(!len){return true}if(contentLength!==null&&bytesWritten+len>contentLength){if(client[kStrictContentLength]){throw new RequestContentLengthMismatchError}process.emitWarning(new RequestContentLengthMismatchError)}socket.cork();if(bytesWritten===0){if(!expectsPayload&&request.reset!==false){socket[kReset]=true}if(contentLength===null){socket.write(`${header}transfer-encoding: chunked\\r\n`,\"latin1\")}else{socket.write(`${header}content-length: ${contentLength}\\r\n\\r\n`,\"latin1\")}}if(contentLength===null){socket.write(`\\r\n${len.toString(16)}\\r\n`,\"latin1\")}this.bytesWritten+=len;const ret=socket.write(chunk);socket.uncork();request.onBodySent(chunk);if(!ret){if(socket[kParser].timeout&&socket[kParser].timeoutType===TIMEOUT_HEADERS){if(socket[kParser].timeout.refresh){socket[kParser].timeout.refresh()}}}return ret}end(){const{socket,contentLength,client,bytesWritten,expectsPayload,header,request}=this;request.onRequestSent();socket[kWriting]=false;if(socket[kError]){throw socket[kError]}if(socket.destroyed){return}if(bytesWritten===0){if(expectsPayload){socket.write(`${header}content-length: 0\\r\n\\r\n`,\"latin1\")}else{socket.write(`${header}\\r\n`,\"latin1\")}}else if(contentLength===null){socket.write(\"\\r\\n0\\r\\n\\r\\n\",\"latin1\")}if(contentLength!==null&&bytesWritten!==contentLength){if(client[kStrictContentLength]){throw new RequestContentLengthMismatchError}else{process.emitWarning(new RequestContentLengthMismatchError)}}if(socket[kParser].timeout&&socket[kParser].timeoutType===TIMEOUT_HEADERS){if(socket[kParser].timeout.refresh){socket[kParser].timeout.refresh()}}client[kResume]()}destroy(err){const{socket,client,abort}=this;socket[kWriting]=false;if(err){assert(client[kRunning]<=1,\"pipeline should only contain this request\");abort(err)}}}module.exports=connectH1;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["exports","client"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/dispatcher/client-h1.js"],"sourcesContent":["'use strict'\n\n/* global WebAssembly */\n\nconst assert = require('node:assert')\nconst util = require('../core/util.js')\nconst { channels } = require('../core/diagnostics.js')\nconst timers = require('../util/timers.js')\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError\n} = require('../core/errors.js')\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kParser,\n  kBlocking,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kMaxRequests,\n  kCounter,\n  kMaxResponseSize,\n  kOnError,\n  kResume,\n  kHTTPContext\n} = require('../core/symbols.js')\n\nconst constants = require('../llhttp/constants.js')\nconst EMPTY_BUF = Buffer.alloc(0)\nconst FastBuffer = Buffer[Symbol.species]\nconst addListener = util.addListener\nconst removeAllListeners = util.removeAllListeners\n\nlet extractBody\n\nasync function lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('../llhttp/llhttp-wasm.js') : undefined\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(require('../llhttp/llhttp_simd-wasm.js'))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(llhttpWasmData || require('../llhttp/llhttp-wasm.js'))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\nllhttpPromise.catch()\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst USE_NATIVE_TIMER = 0\nconst USE_FAST_TIMER = 1\n\n// Use fast timers for headers and body to take eventual event loop\n// latency into account.\nconst TIMEOUT_HEADERS = 2 | USE_FAST_TIMER\nconst TIMEOUT_BODY = 4 | USE_FAST_TIMER\n\n// Use native timers to ignore event loop latency for keep-alive\n// handling.\nconst TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n    this.connection = ''\n    this.maxResponseSize = client[kMaxResponseSize]\n  }\n\n  setTimeout (delay, type) {\n    // If the existing timer and the new timer are of different timer type\n    // (fast or native) or have different delay, we need to clear the existing\n    // timer and set a new one.\n    if (\n      delay !== this.timeoutValue ||\n      (type & USE_FAST_TIMER) ^ (this.timeoutType & USE_FAST_TIMER)\n    ) {\n      // If a timeout is already set, clear it with clearTimeout of the fast\n      // timer implementation, as it can clear fast and native timers.\n      if (this.timeout) {\n        timers.clearTimeout(this.timeout)\n        this.timeout = null\n      }\n\n      if (delay) {\n        if (type & USE_FAST_TIMER) {\n          this.timeout = timers.setFastTimeout(onParserTimeout, delay, new WeakRef(this))\n        } else {\n          this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this))\n          this.timeout.unref()\n        }\n      }\n\n      this.timeoutValue = delay\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.timeoutType = type\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message =\n            'Response does not match the HTTP/1.1 protocol (' +\n            Buffer.from(llhttp.memory.buffer, ptr, len).toString() +\n            ')'\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    this.timeout && timers.clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n    request.onResponseStarted()\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10) {\n      const headerName = util.bufferToLowerCasedHeaderName(key)\n      if (headerName === 'keep-alive') {\n        this.keepAlive += buf.toString()\n      } else if (headerName === 'connection') {\n        this.connection += buf.toString()\n      }\n    } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n    assert(client[kSocket] === socket)\n    assert(!socket.destroyed)\n    assert(!this.paused)\n    assert((headers.length & 1) === 0)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n\n    removeAllListeners(socket)\n\n    client[kSocket] = null\n    client[kHTTPContext] = null // TODO (fix): This is hacky...\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    client[kResume]()\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert(this.timeoutType === TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = (\n      shouldKeepAlive ||\n      // Override llhttp value which does not allow keepAlive for HEAD.\n      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')\n    )\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert((this.headers.length & 1) === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n\n    if (request.aborted) {\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      client[kResume]()\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode, maxResponseSize } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError())\n      return -1\n    }\n\n    this.bytesRead += buf.length\n\n    if (request.onData(buf) === false) {\n      return constants.ERROR.PAUSED\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    assert(statusCode >= 100)\n    assert((this.headers.length & 1) === 0)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n    this.connection = ''\n\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    request.onComplete(headers)\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert(client[kRunning] === 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] == null || client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(() => client[kResume]())\n    } else {\n      client[kResume]()\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client, paused } = parser.deref()\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nasync function connectH1 (client, socket) {\n  client[kSocket] = socket\n\n  if (!llhttpInstance) {\n    llhttpInstance = await llhttpPromise\n    llhttpPromise = null\n  }\n\n  socket[kNoRef] = false\n  socket[kWriting] = false\n  socket[kReset] = false\n  socket[kBlocking] = false\n  socket[kParser] = new Parser(client, socket, llhttpInstance)\n\n  addListener(socket, 'error', function (err) {\n    assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n    const parser = this[kParser]\n\n    // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n    // to the user.\n    if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so for as a valid response.\n      parser.onMessageComplete()\n      return\n    }\n\n    this[kError] = err\n\n    this[kClient][kOnError](err)\n  })\n  addListener(socket, 'readable', function () {\n    const parser = this[kParser]\n\n    if (parser) {\n      parser.readMore()\n    }\n  })\n  addListener(socket, 'end', function () {\n    const parser = this[kParser]\n\n    if (parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete()\n      return\n    }\n\n    util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n  })\n  addListener(socket, 'close', function () {\n    const client = this[kClient]\n    const parser = this[kParser]\n\n    if (parser) {\n      if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n        // We treat all incoming data so far as a valid response.\n        parser.onMessageComplete()\n      }\n\n      this[kParser].destroy()\n      this[kParser] = null\n    }\n\n    const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n    client[kSocket] = null\n    client[kHTTPContext] = null // TODO (fix): This is hacky...\n\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n\n      // Fail entire queue.\n      const requests = client[kQueue].splice(client[kRunningIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(client, request, err)\n      }\n    } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n      // Fail head of pipeline.\n      const request = client[kQueue][client[kRunningIdx]]\n      client[kQueue][client[kRunningIdx]++] = null\n\n      util.errorRequest(client, request, err)\n    }\n\n    client[kPendingIdx] = client[kRunningIdx]\n\n    assert(client[kRunning] === 0)\n\n    client.emit('disconnect', client[kUrl], [client], err)\n\n    client[kResume]()\n  })\n\n  let closed = false\n  socket.on('close', () => {\n    closed = true\n  })\n\n  return {\n    version: 'h1',\n    defaultPipelining: 1,\n    write (...args) {\n      return writeH1(client, ...args)\n    },\n    resume () {\n      resumeH1(client)\n    },\n    destroy (err, callback) {\n      if (closed) {\n        queueMicrotask(callback)\n      } else {\n        socket.destroy(err).on('close', callback)\n      }\n    },\n    get destroyed () {\n      return socket.destroyed\n    },\n    busy (request) {\n      if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n        return true\n      }\n\n      if (request) {\n        if (client[kRunning] > 0 && !request.idempotent) {\n          // Non-idempotent request cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true\n        }\n\n        if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n          // Don't dispatch an upgrade until all preceding requests have completed.\n          // A misbehaving server might upgrade the connection before all pipelined\n          // request has completed.\n          return true\n        }\n\n        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 &&\n          (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {\n          // Request with stream or iterator body can error while other requests\n          // are inflight and indirectly error those as well.\n          // Ensure this doesn't happen by waiting for inflight\n          // to complete before dispatching.\n\n          // Request with stream or iterator body cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true\n        }\n      }\n\n      return false\n    }\n  }\n}\n\nfunction resumeH1 (client) {\n  const socket = client[kSocket]\n\n  if (socket && !socket.destroyed) {\n    if (client[kSize] === 0) {\n      if (!socket[kNoRef] && socket.unref) {\n        socket.unref()\n        socket[kNoRef] = true\n      }\n    } else if (socket[kNoRef] && socket.ref) {\n      socket.ref()\n      socket[kNoRef] = false\n    }\n\n    if (client[kSize] === 0) {\n      if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) {\n        socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE)\n      }\n    } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n      if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n        const request = client[kQueue][client[kRunningIdx]]\n        const headersTimeout = request.headersTimeout != null\n          ? request.headersTimeout\n          : client[kHeadersTimeout]\n        socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n      }\n    }\n  }\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\nfunction writeH1 (client, request) {\n  const { method, path, host, upgrade, blocking, reset } = request\n\n  let { body, headers, contentLength } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH' ||\n    method === 'QUERY' ||\n    method === 'PROPFIND' ||\n    method === 'PROPPATCH'\n  )\n\n  if (util.isFormDataLike(body)) {\n    if (!extractBody) {\n      extractBody = require('../web/fetch/body.js').extractBody\n    }\n\n    const [bodyStream, contentType] = extractBody(body)\n    if (request.contentType == null) {\n      headers.push('content-type', contentType)\n    }\n    body = bodyStream.stream\n    contentLength = bodyStream.length\n  } else if (util.isBlobLike(body) && request.contentType == null && body.type) {\n    headers.push('content-type', body.type)\n  }\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  const bodyLength = util.bodyLength(body)\n\n  contentLength = bodyLength ?? contentLength\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  const abort = (err) => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    util.errorRequest(client, request, err || new RequestAbortedError())\n\n    util.destroy(body)\n    util.destroy(socket, new InformationalError('aborted'))\n  }\n\n  try {\n    request.onConnect(abort)\n  } catch (err) {\n    util.errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (reset != null) {\n    socket[kReset] = reset\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (Array.isArray(headers)) {\n    for (let n = 0; n < headers.length; n += 2) {\n      const key = headers[n + 0]\n      const val = headers[n + 1]\n\n      if (Array.isArray(val)) {\n        for (let i = 0; i < val.length; i++) {\n          header += `${key}: ${val[i]}\\r\\n`\n        }\n      } else {\n        header += `${key}: ${val}\\r\\n`\n      }\n    }\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body || bodyLength === 0) {\n    writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isBuffer(body)) {\n    writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload)\n    } else {\n      writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload)\n    }\n  } else if (util.isStream(body)) {\n    writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isIterable(body)) {\n    writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeStream (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    if (finished) {\n      return\n    }\n\n    try {\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    if (finished) {\n      return\n    }\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onClose = function () {\n    // 'close' might be emitted *before* 'error' for\n    // broken streams. Wait a tick to avoid this case.\n    queueMicrotask(() => {\n      // It's only safe to remove 'error' listener after\n      // 'close'.\n      body.removeListener('error', onFinished)\n    })\n\n    if (!finished) {\n      const err = new RequestAbortedError()\n      queueMicrotask(() => onFinished(err))\n    }\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('close', onClose)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onClose)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n\n  if (body.errorEmitted ?? body.errored) {\n    setImmediate(() => onFinished(body.errored))\n  } else if (body.endEmitted ?? body.readableEnded) {\n    setImmediate(() => onFinished(null))\n  }\n\n  if (body.closeEmitted ?? body.closed) {\n    setImmediate(onClose)\n  }\n}\n\nfunction writeBuffer (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  try {\n    if (!body) {\n      if (contentLength === 0) {\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        assert(contentLength === null, 'no body must not have content length')\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n      socket.cork()\n      socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      socket.write(body)\n      socket.uncork()\n      request.onBodySent(body)\n\n      if (!expectsPayload && request.reset !== false) {\n        socket[kReset] = true\n      }\n    }\n    request.onRequestSent()\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeBlob (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload && request.reset !== false) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeIterable (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ abort, socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n    this.abort = abort\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    socket.cork()\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload && request.reset !== false) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    socket.uncork()\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    client[kResume]()\n  }\n\n  destroy (err) {\n    const { socket, client, abort } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      abort(err)\n    }\n  }\n}\n\nmodule.exports = connectH1\n"]}}