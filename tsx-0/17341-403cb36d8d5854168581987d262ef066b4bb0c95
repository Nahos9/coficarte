{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{isUSVString,bufferToLowerCasedHeaderName}=require(\"../../core/util\");const{utf8DecodeBytes}=require(\"./util\");const{HTTP_TOKEN_CODEPOINTS,isomorphicDecode}=require(\"./data-url\");const{isFileLike}=require(\"./file\");const{makeEntry}=require(\"./formdata\");const assert=require(\"node:assert\");const{File:NodeFile}=require(\"node:buffer\");const File=globalThis.File??NodeFile;const formDataNameBuffer=Buffer.from('form-data; name=\"');const filenameBuffer=Buffer.from(\"; filename\");const dd=Buffer.from(\"--\");const ddcrlf=Buffer.from(\"--\\r\\n\");function isAsciiString(chars){for(let i=0;i<chars.length;++i){if((chars.charCodeAt(i)&~127)!==0){return false}}return true}__name(isAsciiString,\"isAsciiString\");function validateBoundary(boundary){const length=boundary.length;if(length<27||length>70){return false}for(let i=0;i<length;++i){const cp=boundary.charCodeAt(i);if(!(cp>=48&&cp<=57||cp>=65&&cp<=90||cp>=97&&cp<=122||cp===39||cp===45||cp===95)){return false}}return true}__name(validateBoundary,\"validateBoundary\");function multipartFormDataParser(input,mimeType){assert(mimeType!==\"failure\"&&mimeType.essence===\"multipart/form-data\");const boundaryString=mimeType.parameters.get(\"boundary\");if(boundaryString===void 0){return\"failure\"}const boundary=Buffer.from(`--${boundaryString}`,\"utf8\");const entryList=[];const position={position:0};while(input[position.position]===13&&input[position.position+1]===10){position.position+=2}let trailing=input.length;while(input[trailing-1]===10&&input[trailing-2]===13){trailing-=2}if(trailing!==input.length){input=input.subarray(0,trailing)}while(true){if(input.subarray(position.position,position.position+boundary.length).equals(boundary)){position.position+=boundary.length}else{return\"failure\"}if(position.position===input.length-2&&bufferStartsWith(input,dd,position)||position.position===input.length-4&&bufferStartsWith(input,ddcrlf,position)){return entryList}if(input[position.position]!==13||input[position.position+1]!==10){return\"failure\"}position.position+=2;const result=parseMultipartFormDataHeaders(input,position);if(result===\"failure\"){return\"failure\"}let{name,filename,contentType,encoding}=result;position.position+=2;let body;{const boundaryIndex=input.indexOf(boundary.subarray(2),position.position);if(boundaryIndex===-1){return\"failure\"}body=input.subarray(position.position,boundaryIndex-4);position.position+=body.length;if(encoding===\"base64\"){body=Buffer.from(body.toString(),\"base64\")}}if(input[position.position]!==13||input[position.position+1]!==10){return\"failure\"}else{position.position+=2}let value;if(filename!==null){contentType??=\"text/plain\";if(!isAsciiString(contentType)){contentType=\"\"}value=new File([body],filename,{type:contentType})}else{value=utf8DecodeBytes(Buffer.from(body))}assert(isUSVString(name));assert(typeof value===\"string\"&&isUSVString(value)||isFileLike(value));entryList.push(makeEntry(name,value,filename))}}__name(multipartFormDataParser,\"multipartFormDataParser\");function parseMultipartFormDataHeaders(input,position){let name=null;let filename=null;let contentType=null;let encoding=null;while(true){if(input[position.position]===13&&input[position.position+1]===10){if(name===null){return\"failure\"}return{name,filename,contentType,encoding}}let headerName=collectASequenceOfBytes(char=>char!==10&&char!==13&&char!==58,input,position);headerName=removeChars(headerName,true,true,char=>char===9||char===32);if(!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())){return\"failure\"}if(input[position.position]!==58){return\"failure\"}position.position++;collectASequenceOfBytes(char=>char===32||char===9,input,position);switch(bufferToLowerCasedHeaderName(headerName)){case\"content-disposition\":{name=filename=null;if(!bufferStartsWith(input,formDataNameBuffer,position)){return\"failure\"}position.position+=17;name=parseMultipartFormDataName(input,position);if(name===null){return\"failure\"}if(bufferStartsWith(input,filenameBuffer,position)){let check=position.position+filenameBuffer.length;if(input[check]===42){position.position+=1;check+=1}if(input[check]!==61||input[check+1]!==34){return\"failure\"}position.position+=12;filename=parseMultipartFormDataName(input,position);if(filename===null){return\"failure\"}}break}case\"content-type\":{let headerValue=collectASequenceOfBytes(char=>char!==10&&char!==13,input,position);headerValue=removeChars(headerValue,false,true,char=>char===9||char===32);contentType=isomorphicDecode(headerValue);break}case\"content-transfer-encoding\":{let headerValue=collectASequenceOfBytes(char=>char!==10&&char!==13,input,position);headerValue=removeChars(headerValue,false,true,char=>char===9||char===32);encoding=isomorphicDecode(headerValue);break}default:{collectASequenceOfBytes(char=>char!==10&&char!==13,input,position)}}if(input[position.position]!==13&&input[position.position+1]!==10){return\"failure\"}else{position.position+=2}}}__name(parseMultipartFormDataHeaders,\"parseMultipartFormDataHeaders\");function parseMultipartFormDataName(input,position){assert(input[position.position-1]===34);let name=collectASequenceOfBytes(char=>char!==10&&char!==13&&char!==34,input,position);if(input[position.position]!==34){return null}else{position.position++}name=new TextDecoder().decode(name).replace(/%0A/ig,\"\\n\").replace(/%0D/ig,\"\\r\").replace(/%22/g,'\"');return name}__name(parseMultipartFormDataName,\"parseMultipartFormDataName\");function collectASequenceOfBytes(condition,input,position){let start=position.position;while(start<input.length&&condition(input[start])){++start}return input.subarray(position.position,position.position=start)}__name(collectASequenceOfBytes,\"collectASequenceOfBytes\");function removeChars(buf,leading,trailing,predicate){let lead=0;let trail=buf.length-1;if(leading){while(lead<buf.length&&predicate(buf[lead]))lead++}if(trailing){while(trail>0&&predicate(buf[trail]))trail--}return lead===0&&trail===buf.length-1?buf:buf.subarray(lead,trail+1)}__name(removeChars,\"removeChars\");function bufferStartsWith(buffer,start,position){if(buffer.length<start.length){return false}for(let i=0;i<start.length;i++){if(start[i]!==buffer[position.position+i]){return false}}return true}__name(bufferStartsWith,\"bufferStartsWith\");module.exports={multipartFormDataParser,validateBoundary};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/fetch/formdata-parser.js"],"sourcesContent":["'use strict'\n\nconst { isUSVString, bufferToLowerCasedHeaderName } = require('../../core/util')\nconst { utf8DecodeBytes } = require('./util')\nconst { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = require('./data-url')\nconst { isFileLike } = require('./file')\nconst { makeEntry } = require('./formdata')\nconst assert = require('node:assert')\nconst { File: NodeFile } = require('node:buffer')\n\nconst File = globalThis.File ?? NodeFile\n\nconst formDataNameBuffer = Buffer.from('form-data; name=\"')\nconst filenameBuffer = Buffer.from('; filename')\nconst dd = Buffer.from('--')\nconst ddcrlf = Buffer.from('--\\r\\n')\n\n/**\n * @param {string} chars\n */\nfunction isAsciiString (chars) {\n  for (let i = 0; i < chars.length; ++i) {\n    if ((chars.charCodeAt(i) & ~0x7F) !== 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-boundary\n * @param {string} boundary\n */\nfunction validateBoundary (boundary) {\n  const length = boundary.length\n\n  // - its length is greater or equal to 27 and lesser or equal to 70, and\n  if (length < 27 || length > 70) {\n    return false\n  }\n\n  // - it is composed by bytes in the ranges 0x30 to 0x39, 0x41 to 0x5A, or\n  //   0x61 to 0x7A, inclusive (ASCII alphanumeric), or which are 0x27 ('),\n  //   0x2D (-) or 0x5F (_).\n  for (let i = 0; i < length; ++i) {\n    const cp = boundary.charCodeAt(i)\n\n    if (!(\n      (cp >= 0x30 && cp <= 0x39) ||\n      (cp >= 0x41 && cp <= 0x5a) ||\n      (cp >= 0x61 && cp <= 0x7a) ||\n      cp === 0x27 ||\n      cp === 0x2d ||\n      cp === 0x5f\n    )) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-parser\n * @param {Buffer} input\n * @param {ReturnType<import('./data-url')['parseMIMEType']>} mimeType\n */\nfunction multipartFormDataParser (input, mimeType) {\n  // 1. Assert: mimeType’s essence is \"multipart/form-data\".\n  assert(mimeType !== 'failure' && mimeType.essence === 'multipart/form-data')\n\n  const boundaryString = mimeType.parameters.get('boundary')\n\n  // 2. If mimeType’s parameters[\"boundary\"] does not exist, return failure.\n  //    Otherwise, let boundary be the result of UTF-8 decoding mimeType’s\n  //    parameters[\"boundary\"].\n  if (boundaryString === undefined) {\n    return 'failure'\n  }\n\n  const boundary = Buffer.from(`--${boundaryString}`, 'utf8')\n\n  // 3. Let entry list be an empty entry list.\n  const entryList = []\n\n  // 4. Let position be a pointer to a byte in input, initially pointing at\n  //    the first byte.\n  const position = { position: 0 }\n\n  // Note: undici addition, allows leading and trailing CRLFs.\n  while (input[position.position] === 0x0d && input[position.position + 1] === 0x0a) {\n    position.position += 2\n  }\n\n  let trailing = input.length\n\n  while (input[trailing - 1] === 0x0a && input[trailing - 2] === 0x0d) {\n    trailing -= 2\n  }\n\n  if (trailing !== input.length) {\n    input = input.subarray(0, trailing)\n  }\n\n  // 5. While true:\n  while (true) {\n    // 5.1. If position points to a sequence of bytes starting with 0x2D 0x2D\n    //      (`--`) followed by boundary, advance position by 2 + the length of\n    //      boundary. Otherwise, return failure.\n    // Note: boundary is padded with 2 dashes already, no need to add 2.\n    if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {\n      position.position += boundary.length\n    } else {\n      return 'failure'\n    }\n\n    // 5.2. If position points to the sequence of bytes 0x2D 0x2D 0x0D 0x0A\n    //      (`--` followed by CR LF) followed by the end of input, return entry list.\n    // Note: a body does NOT need to end with CRLF. It can end with --.\n    if (\n      (position.position === input.length - 2 && bufferStartsWith(input, dd, position)) ||\n      (position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position))\n    ) {\n      return entryList\n    }\n\n    // 5.3. If position does not point to a sequence of bytes starting with 0x0D\n    //      0x0A (CR LF), return failure.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      return 'failure'\n    }\n\n    // 5.4. Advance position by 2. (This skips past the newline.)\n    position.position += 2\n\n    // 5.5. Let name, filename and contentType be the result of parsing\n    //      multipart/form-data headers on input and position, if the result\n    //      is not failure. Otherwise, return failure.\n    const result = parseMultipartFormDataHeaders(input, position)\n\n    if (result === 'failure') {\n      return 'failure'\n    }\n\n    let { name, filename, contentType, encoding } = result\n\n    // 5.6. Advance position by 2. (This skips past the empty line that marks\n    //      the end of the headers.)\n    position.position += 2\n\n    // 5.7. Let body be the empty byte sequence.\n    let body\n\n    // 5.8. Body loop: While position is not past the end of input:\n    // TODO: the steps here are completely wrong\n    {\n      const boundaryIndex = input.indexOf(boundary.subarray(2), position.position)\n\n      if (boundaryIndex === -1) {\n        return 'failure'\n      }\n\n      body = input.subarray(position.position, boundaryIndex - 4)\n\n      position.position += body.length\n\n      // Note: position must be advanced by the body's length before being\n      // decoded, otherwise the parsing will fail.\n      if (encoding === 'base64') {\n        body = Buffer.from(body.toString(), 'base64')\n      }\n    }\n\n    // 5.9. If position does not point to a sequence of bytes starting with\n    //      0x0D 0x0A (CR LF), return failure. Otherwise, advance position by 2.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      return 'failure'\n    } else {\n      position.position += 2\n    }\n\n    // 5.10. If filename is not null:\n    let value\n\n    if (filename !== null) {\n      // 5.10.1. If contentType is null, set contentType to \"text/plain\".\n      contentType ??= 'text/plain'\n\n      // 5.10.2. If contentType is not an ASCII string, set contentType to the empty string.\n\n      // Note: `buffer.isAscii` can be used at zero-cost, but converting a string to a buffer is a high overhead.\n      // Content-Type is a relatively small string, so it is faster to use `String#charCodeAt`.\n      if (!isAsciiString(contentType)) {\n        contentType = ''\n      }\n\n      // 5.10.3. Let value be a new File object with name filename, type contentType, and body body.\n      value = new File([body], filename, { type: contentType })\n    } else {\n      // 5.11. Otherwise:\n\n      // 5.11.1. Let value be the UTF-8 decoding without BOM of body.\n      value = utf8DecodeBytes(Buffer.from(body))\n    }\n\n    // 5.12. Assert: name is a scalar value string and value is either a scalar value string or a File object.\n    assert(isUSVString(name))\n    assert((typeof value === 'string' && isUSVString(value)) || isFileLike(value))\n\n    // 5.13. Create an entry with name and value, and append it to entry list.\n    entryList.push(makeEntry(name, value, filename))\n  }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-multipart-form-data-headers\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataHeaders (input, position) {\n  // 1. Let name, filename and contentType be null.\n  let name = null\n  let filename = null\n  let contentType = null\n  let encoding = null\n\n  // 2. While true:\n  while (true) {\n    // 2.1. If position points to a sequence of bytes starting with 0x0D 0x0A (CR LF):\n    if (input[position.position] === 0x0d && input[position.position + 1] === 0x0a) {\n      // 2.1.1. If name is null, return failure.\n      if (name === null) {\n        return 'failure'\n      }\n\n      // 2.1.2. Return name, filename and contentType.\n      return { name, filename, contentType, encoding }\n    }\n\n    // 2.2. Let header name be the result of collecting a sequence of bytes that are\n    //      not 0x0A (LF), 0x0D (CR) or 0x3A (:), given position.\n    let headerName = collectASequenceOfBytes(\n      (char) => char !== 0x0a && char !== 0x0d && char !== 0x3a,\n      input,\n      position\n    )\n\n    // 2.3. Remove any HTTP tab or space bytes from the start or end of header name.\n    headerName = removeChars(headerName, true, true, (char) => char === 0x9 || char === 0x20)\n\n    // 2.4. If header name does not match the field-name token production, return failure.\n    if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {\n      return 'failure'\n    }\n\n    // 2.5. If the byte at position is not 0x3A (:), return failure.\n    if (input[position.position] !== 0x3a) {\n      return 'failure'\n    }\n\n    // 2.6. Advance position by 1.\n    position.position++\n\n    // 2.7. Collect a sequence of bytes that are HTTP tab or space bytes given position.\n    //      (Do nothing with those bytes.)\n    collectASequenceOfBytes(\n      (char) => char === 0x20 || char === 0x09,\n      input,\n      position\n    )\n\n    // 2.8. Byte-lowercase header name and switch on the result:\n    switch (bufferToLowerCasedHeaderName(headerName)) {\n      case 'content-disposition': {\n        // 1. Set name and filename to null.\n        name = filename = null\n\n        // 2. If position does not point to a sequence of bytes starting with\n        //    `form-data; name=\"`, return failure.\n        if (!bufferStartsWith(input, formDataNameBuffer, position)) {\n          return 'failure'\n        }\n\n        // 3. Advance position so it points at the byte after the next 0x22 (\")\n        //    byte (the one in the sequence of bytes matched above).\n        position.position += 17\n\n        // 4. Set name to the result of parsing a multipart/form-data name given\n        //    input and position, if the result is not failure. Otherwise, return\n        //    failure.\n        name = parseMultipartFormDataName(input, position)\n\n        if (name === null) {\n          return 'failure'\n        }\n\n        // 5. If position points to a sequence of bytes starting with `; filename=\"`:\n        if (bufferStartsWith(input, filenameBuffer, position)) {\n          // Note: undici also handles filename*\n          let check = position.position + filenameBuffer.length\n\n          if (input[check] === 0x2a) {\n            position.position += 1\n            check += 1\n          }\n\n          if (input[check] !== 0x3d || input[check + 1] !== 0x22) { // =\"\n            return 'failure'\n          }\n\n          // 1. Advance position so it points at the byte after the next 0x22 (\") byte\n          //    (the one in the sequence of bytes matched above).\n          position.position += 12\n\n          // 2. Set filename to the result of parsing a multipart/form-data name given\n          //    input and position, if the result is not failure. Otherwise, return failure.\n          filename = parseMultipartFormDataName(input, position)\n\n          if (filename === null) {\n            return 'failure'\n          }\n        }\n\n        break\n      }\n      case 'content-type': {\n        // 1. Let header value be the result of collecting a sequence of bytes that are\n        //    not 0x0A (LF) or 0x0D (CR), given position.\n        let headerValue = collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n\n        // 2. Remove any HTTP tab or space bytes from the end of header value.\n        headerValue = removeChars(headerValue, false, true, (char) => char === 0x9 || char === 0x20)\n\n        // 3. Set contentType to the isomorphic decoding of header value.\n        contentType = isomorphicDecode(headerValue)\n\n        break\n      }\n      case 'content-transfer-encoding': {\n        let headerValue = collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n\n        headerValue = removeChars(headerValue, false, true, (char) => char === 0x9 || char === 0x20)\n\n        encoding = isomorphicDecode(headerValue)\n\n        break\n      }\n      default: {\n        // Collect a sequence of bytes that are not 0x0A (LF) or 0x0D (CR), given position.\n        // (Do nothing with those bytes.)\n        collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n      }\n    }\n\n    // 2.9. If position does not point to a sequence of bytes starting with 0x0D 0x0A\n    //      (CR LF), return failure. Otherwise, advance position by 2 (past the newline).\n    if (input[position.position] !== 0x0d && input[position.position + 1] !== 0x0a) {\n      return 'failure'\n    } else {\n      position.position += 2\n    }\n  }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-a-multipart-form-data-name\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataName (input, position) {\n  // 1. Assert: The byte at (position - 1) is 0x22 (\").\n  assert(input[position.position - 1] === 0x22)\n\n  // 2. Let name be the result of collecting a sequence of bytes that are not 0x0A (LF), 0x0D (CR) or 0x22 (\"), given position.\n  /** @type {string | Buffer} */\n  let name = collectASequenceOfBytes(\n    (char) => char !== 0x0a && char !== 0x0d && char !== 0x22,\n    input,\n    position\n  )\n\n  // 3. If the byte at position is not 0x22 (\"), return failure. Otherwise, advance position by 1.\n  if (input[position.position] !== 0x22) {\n    return null // name could be 'failure'\n  } else {\n    position.position++\n  }\n\n  // 4. Replace any occurrence of the following subsequences in name with the given byte:\n  // - `%0A`: 0x0A (LF)\n  // - `%0D`: 0x0D (CR)\n  // - `%22`: 0x22 (\")\n  name = new TextDecoder().decode(name)\n    .replace(/%0A/ig, '\\n')\n    .replace(/%0D/ig, '\\r')\n    .replace(/%22/g, '\"')\n\n  // 5. Return the UTF-8 decoding without BOM of name.\n  return name\n}\n\n/**\n * @param {(char: number) => boolean} condition\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfBytes (condition, input, position) {\n  let start = position.position\n\n  while (start < input.length && condition(input[start])) {\n    ++start\n  }\n\n  return input.subarray(position.position, (position.position = start))\n}\n\n/**\n * @param {Buffer} buf\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns {Buffer}\n */\nfunction removeChars (buf, leading, trailing, predicate) {\n  let lead = 0\n  let trail = buf.length - 1\n\n  if (leading) {\n    while (lead < buf.length && predicate(buf[lead])) lead++\n  }\n\n  if (trailing) {\n    while (trail > 0 && predicate(buf[trail])) trail--\n  }\n\n  return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1)\n}\n\n/**\n * Checks if {@param buffer} starts with {@param start}\n * @param {Buffer} buffer\n * @param {Buffer} start\n * @param {{ position: number }} position\n */\nfunction bufferStartsWith (buffer, start, position) {\n  if (buffer.length < start.length) {\n    return false\n  }\n\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== buffer[position.position + i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nmodule.exports = {\n  multipartFormDataParser,\n  validateBoundary\n}\n"]}}