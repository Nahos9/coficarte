{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const assert=require(\"node:assert\");const net=require(\"node:net\");const http=require(\"node:http\");const util=require(\"../core/util.js\");const{channels}=require(\"../core/diagnostics.js\");const Request=require(\"../core/request.js\");const DispatcherBase=require(\"./dispatcher-base\");const{InvalidArgumentError,InformationalError,ClientDestroyedError}=require(\"../core/errors.js\");const buildConnector=require(\"../core/connect.js\");const{kUrl,kServerName,kClient,kBusy,kConnect,kResuming,kRunning,kPending,kSize,kQueue,kConnected,kConnecting,kNeedDrain,kKeepAliveDefaultTimeout,kHostHeader,kPendingIdx,kRunningIdx,kError,kPipelining,kKeepAliveTimeoutValue,kMaxHeadersSize,kKeepAliveMaxTimeout,kKeepAliveTimeoutThreshold,kHeadersTimeout,kBodyTimeout,kStrictContentLength,kConnector,kMaxRedirections,kMaxRequests,kCounter,kClose,kDestroy,kDispatch,kInterceptors,kLocalAddress,kMaxResponseSize,kOnError,kHTTPContext,kMaxConcurrentStreams,kResume}=require(\"../core/symbols.js\");const connectH1=require(\"./client-h1.js\");const connectH2=require(\"./client-h2.js\");let deprecatedInterceptorWarned=false;const kClosedResolve=Symbol(\"kClosedResolve\");const noop=__name(()=>{},\"noop\");function getPipelining(client){return client[kPipelining]??client[kHTTPContext]?.defaultPipelining??1}__name(getPipelining,\"getPipelining\");class Client extends DispatcherBase{static{__name(this,\"Client\")}constructor(url,{interceptors,maxHeaderSize,headersTimeout,socketTimeout,requestTimeout,connectTimeout,bodyTimeout,idleTimeout,keepAlive,keepAliveTimeout,maxKeepAliveTimeout,keepAliveMaxTimeout,keepAliveTimeoutThreshold,socketPath,pipelining,tls,strictContentLength,maxCachedSessions,maxRedirections,connect:connect2,maxRequestsPerClient,localAddress,maxResponseSize,autoSelectFamily,autoSelectFamilyAttemptTimeout,maxConcurrentStreams,allowH2}={}){super();if(keepAlive!==void 0){throw new InvalidArgumentError(\"unsupported keepAlive, use pipelining=0 instead\")}if(socketTimeout!==void 0){throw new InvalidArgumentError(\"unsupported socketTimeout, use headersTimeout & bodyTimeout instead\")}if(requestTimeout!==void 0){throw new InvalidArgumentError(\"unsupported requestTimeout, use headersTimeout & bodyTimeout instead\")}if(idleTimeout!==void 0){throw new InvalidArgumentError(\"unsupported idleTimeout, use keepAliveTimeout instead\")}if(maxKeepAliveTimeout!==void 0){throw new InvalidArgumentError(\"unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead\")}if(maxHeaderSize!=null&&!Number.isFinite(maxHeaderSize)){throw new InvalidArgumentError(\"invalid maxHeaderSize\")}if(socketPath!=null&&typeof socketPath!==\"string\"){throw new InvalidArgumentError(\"invalid socketPath\")}if(connectTimeout!=null&&(!Number.isFinite(connectTimeout)||connectTimeout<0)){throw new InvalidArgumentError(\"invalid connectTimeout\")}if(keepAliveTimeout!=null&&(!Number.isFinite(keepAliveTimeout)||keepAliveTimeout<=0)){throw new InvalidArgumentError(\"invalid keepAliveTimeout\")}if(keepAliveMaxTimeout!=null&&(!Number.isFinite(keepAliveMaxTimeout)||keepAliveMaxTimeout<=0)){throw new InvalidArgumentError(\"invalid keepAliveMaxTimeout\")}if(keepAliveTimeoutThreshold!=null&&!Number.isFinite(keepAliveTimeoutThreshold)){throw new InvalidArgumentError(\"invalid keepAliveTimeoutThreshold\")}if(headersTimeout!=null&&(!Number.isInteger(headersTimeout)||headersTimeout<0)){throw new InvalidArgumentError(\"headersTimeout must be a positive integer or zero\")}if(bodyTimeout!=null&&(!Number.isInteger(bodyTimeout)||bodyTimeout<0)){throw new InvalidArgumentError(\"bodyTimeout must be a positive integer or zero\")}if(connect2!=null&&typeof connect2!==\"function\"&&typeof connect2!==\"object\"){throw new InvalidArgumentError(\"connect must be a function or an object\")}if(maxRedirections!=null&&(!Number.isInteger(maxRedirections)||maxRedirections<0)){throw new InvalidArgumentError(\"maxRedirections must be a positive number\")}if(maxRequestsPerClient!=null&&(!Number.isInteger(maxRequestsPerClient)||maxRequestsPerClient<0)){throw new InvalidArgumentError(\"maxRequestsPerClient must be a positive number\")}if(localAddress!=null&&(typeof localAddress!==\"string\"||net.isIP(localAddress)===0)){throw new InvalidArgumentError(\"localAddress must be valid string IP address\")}if(maxResponseSize!=null&&(!Number.isInteger(maxResponseSize)||maxResponseSize<-1)){throw new InvalidArgumentError(\"maxResponseSize must be a positive number\")}if(autoSelectFamilyAttemptTimeout!=null&&(!Number.isInteger(autoSelectFamilyAttemptTimeout)||autoSelectFamilyAttemptTimeout<-1)){throw new InvalidArgumentError(\"autoSelectFamilyAttemptTimeout must be a positive number\")}if(allowH2!=null&&typeof allowH2!==\"boolean\"){throw new InvalidArgumentError(\"allowH2 must be a valid boolean value\")}if(maxConcurrentStreams!=null&&(typeof maxConcurrentStreams!==\"number\"||maxConcurrentStreams<1)){throw new InvalidArgumentError(\"maxConcurrentStreams must be a positive integer, greater than 0\")}if(typeof connect2!==\"function\"){connect2=buildConnector({...tls,maxCachedSessions,allowH2,socketPath,timeout:connectTimeout,...autoSelectFamily?{autoSelectFamily,autoSelectFamilyAttemptTimeout}:void 0,...connect2})}if(interceptors?.Client&&Array.isArray(interceptors.Client)){this[kInterceptors]=interceptors.Client;if(!deprecatedInterceptorWarned){deprecatedInterceptorWarned=true;process.emitWarning(\"Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.\",{code:\"UNDICI-CLIENT-INTERCEPTOR-DEPRECATED\"})}}else{this[kInterceptors]=[createRedirectInterceptor({maxRedirections})]}this[kUrl]=util.parseOrigin(url);this[kConnector]=connect2;this[kPipelining]=pipelining!=null?pipelining:1;this[kMaxHeadersSize]=maxHeaderSize||http.maxHeaderSize;this[kKeepAliveDefaultTimeout]=keepAliveTimeout==null?4e3:keepAliveTimeout;this[kKeepAliveMaxTimeout]=keepAliveMaxTimeout==null?6e5:keepAliveMaxTimeout;this[kKeepAliveTimeoutThreshold]=keepAliveTimeoutThreshold==null?2e3:keepAliveTimeoutThreshold;this[kKeepAliveTimeoutValue]=this[kKeepAliveDefaultTimeout];this[kServerName]=null;this[kLocalAddress]=localAddress!=null?localAddress:null;this[kResuming]=0;this[kNeedDrain]=0;this[kHostHeader]=`host: ${this[kUrl].hostname}${this[kUrl].port?`:${this[kUrl].port}`:\"\"}\\r\n`;this[kBodyTimeout]=bodyTimeout!=null?bodyTimeout:3e5;this[kHeadersTimeout]=headersTimeout!=null?headersTimeout:3e5;this[kStrictContentLength]=strictContentLength==null?true:strictContentLength;this[kMaxRedirections]=maxRedirections;this[kMaxRequests]=maxRequestsPerClient;this[kClosedResolve]=null;this[kMaxResponseSize]=maxResponseSize>-1?maxResponseSize:-1;this[kMaxConcurrentStreams]=maxConcurrentStreams!=null?maxConcurrentStreams:100;this[kHTTPContext]=null;this[kQueue]=[];this[kRunningIdx]=0;this[kPendingIdx]=0;this[kResume]=sync=>resume(this,sync);this[kOnError]=err=>onError(this,err)}get pipelining(){return this[kPipelining]}set pipelining(value){this[kPipelining]=value;this[kResume](true)}get[kPending](){return this[kQueue].length-this[kPendingIdx]}get[kRunning](){return this[kPendingIdx]-this[kRunningIdx]}get[kSize](){return this[kQueue].length-this[kRunningIdx]}get[kConnected](){return!!this[kHTTPContext]&&!this[kConnecting]&&!this[kHTTPContext].destroyed}get[kBusy](){return Boolean(this[kHTTPContext]?.busy(null)||this[kSize]>=(getPipelining(this)||1)||this[kPending]>0)}[kConnect](cb){connect(this);this.once(\"connect\",cb)}[kDispatch](opts,handler){const origin=opts.origin||this[kUrl].origin;const request=new Request(origin,opts,handler);this[kQueue].push(request);if(this[kResuming]){}else if(util.bodyLength(request.body)==null&&util.isIterable(request.body)){this[kResuming]=1;queueMicrotask(()=>resume(this))}else{this[kResume](true)}if(this[kResuming]&&this[kNeedDrain]!==2&&this[kBusy]){this[kNeedDrain]=2}return this[kNeedDrain]<2}async[kClose](){return new Promise(resolve=>{if(this[kSize]){this[kClosedResolve]=resolve}else{resolve(null)}})}async[kDestroy](err){return new Promise(resolve=>{const requests=this[kQueue].splice(this[kPendingIdx]);for(let i=0;i<requests.length;i++){const request=requests[i];util.errorRequest(this,request,err)}const callback=__name(()=>{if(this[kClosedResolve]){this[kClosedResolve]();this[kClosedResolve]=null}resolve(null)},\"callback\");if(this[kHTTPContext]){this[kHTTPContext].destroy(err,callback);this[kHTTPContext]=null}else{queueMicrotask(callback)}this[kResume]()})}}const createRedirectInterceptor=require(\"../interceptor/redirect-interceptor.js\");function onError(client,err){if(client[kRunning]===0&&err.code!==\"UND_ERR_INFO\"&&err.code!==\"UND_ERR_SOCKET\"){assert(client[kPendingIdx]===client[kRunningIdx]);const requests=client[kQueue].splice(client[kRunningIdx]);for(let i=0;i<requests.length;i++){const request=requests[i];util.errorRequest(client,request,err)}assert(client[kSize]===0)}}__name(onError,\"onError\");async function connect(client){assert(!client[kConnecting]);assert(!client[kHTTPContext]);let{host,hostname,protocol,port}=client[kUrl];if(hostname[0]===\"[\"){const idx=hostname.indexOf(\"]\");assert(idx!==-1);const ip=hostname.substring(1,idx);assert(net.isIP(ip));hostname=ip}client[kConnecting]=true;if(channels.beforeConnect.hasSubscribers){channels.beforeConnect.publish({connectParams:{host,hostname,protocol,port,version:client[kHTTPContext]?.version,servername:client[kServerName],localAddress:client[kLocalAddress]},connector:client[kConnector]})}try{const socket=await new Promise((resolve,reject)=>{client[kConnector]({host,hostname,protocol,port,servername:client[kServerName],localAddress:client[kLocalAddress]},(err,socket2)=>{if(err){reject(err)}else{resolve(socket2)}})});if(client.destroyed){util.destroy(socket.on(\"error\",noop),new ClientDestroyedError);return}assert(socket);try{client[kHTTPContext]=socket.alpnProtocol===\"h2\"?await connectH2(client,socket):await connectH1(client,socket)}catch(err){socket.destroy().on(\"error\",noop);throw err}client[kConnecting]=false;socket[kCounter]=0;socket[kMaxRequests]=client[kMaxRequests];socket[kClient]=client;socket[kError]=null;if(channels.connected.hasSubscribers){channels.connected.publish({connectParams:{host,hostname,protocol,port,version:client[kHTTPContext]?.version,servername:client[kServerName],localAddress:client[kLocalAddress]},connector:client[kConnector],socket})}client.emit(\"connect\",client[kUrl],[client])}catch(err){if(client.destroyed){return}client[kConnecting]=false;if(channels.connectError.hasSubscribers){channels.connectError.publish({connectParams:{host,hostname,protocol,port,version:client[kHTTPContext]?.version,servername:client[kServerName],localAddress:client[kLocalAddress]},connector:client[kConnector],error:err})}if(err.code===\"ERR_TLS_CERT_ALTNAME_INVALID\"){assert(client[kRunning]===0);while(client[kPending]>0&&client[kQueue][client[kPendingIdx]].servername===client[kServerName]){const request=client[kQueue][client[kPendingIdx]++];util.errorRequest(client,request,err)}}else{onError(client,err)}client.emit(\"connectionError\",client[kUrl],[client],err)}client[kResume]()}__name(connect,\"connect\");function emitDrain(client){client[kNeedDrain]=0;client.emit(\"drain\",client[kUrl],[client])}__name(emitDrain,\"emitDrain\");function resume(client,sync){if(client[kResuming]===2){return}client[kResuming]=2;_resume(client,sync);client[kResuming]=0;if(client[kRunningIdx]>256){client[kQueue].splice(0,client[kRunningIdx]);client[kPendingIdx]-=client[kRunningIdx];client[kRunningIdx]=0}}__name(resume,\"resume\");function _resume(client,sync){while(true){if(client.destroyed){assert(client[kPending]===0);return}if(client[kClosedResolve]&&!client[kSize]){client[kClosedResolve]();client[kClosedResolve]=null;return}if(client[kHTTPContext]){client[kHTTPContext].resume()}if(client[kBusy]){client[kNeedDrain]=2}else if(client[kNeedDrain]===2){if(sync){client[kNeedDrain]=1;queueMicrotask(()=>emitDrain(client))}else{emitDrain(client)}continue}if(client[kPending]===0){return}if(client[kRunning]>=(getPipelining(client)||1)){return}const request=client[kQueue][client[kPendingIdx]];if(client[kUrl].protocol===\"https:\"&&client[kServerName]!==request.servername){if(client[kRunning]>0){return}client[kServerName]=request.servername;client[kHTTPContext]?.destroy(new InformationalError(\"servername changed\"),()=>{client[kHTTPContext]=null;resume(client)})}if(client[kConnecting]){return}if(!client[kHTTPContext]){connect(client);return}if(client[kHTTPContext].destroyed){return}if(client[kHTTPContext].busy(request)){return}if(!request.aborted&&client[kHTTPContext].write(request)){client[kPendingIdx]++}else{client[kQueue].splice(client[kPendingIdx],1)}}}__name(_resume,\"_resume\");module.exports=Client;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["connect","socket"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/dispatcher/client.js"],"sourcesContent":["// @ts-check\n\n'use strict'\n\nconst assert = require('node:assert')\nconst net = require('node:net')\nconst http = require('node:http')\nconst util = require('../core/util.js')\nconst { channels } = require('../core/diagnostics.js')\nconst Request = require('../core/request.js')\nconst DispatcherBase = require('./dispatcher-base')\nconst {\n  InvalidArgumentError,\n  InformationalError,\n  ClientDestroyedError\n} = require('../core/errors.js')\nconst buildConnector = require('../core/connect.js')\nconst {\n  kUrl,\n  kServerName,\n  kClient,\n  kBusy,\n  kConnect,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize,\n  kOnError,\n  kHTTPContext,\n  kMaxConcurrentStreams,\n  kResume\n} = require('../core/symbols.js')\nconst connectH1 = require('./client-h1.js')\nconst connectH2 = require('./client-h2.js')\nlet deprecatedInterceptorWarned = false\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nconst noop = () => {}\n\nfunction getPipelining (client) {\n  return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1\n}\n\n/**\n * @type {import('../../types/client.js').default}\n */\nclass Client extends DispatcherBase {\n  /**\n   *\n   * @param {string|URL} url\n   * @param {import('../../types/client.js').Client.Options} options\n   */\n  constructor (url, {\n    interceptors,\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    // h2\n    maxConcurrentStreams,\n    allowH2\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address')\n    }\n\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number')\n    }\n\n    if (\n      autoSelectFamilyAttemptTimeout != null &&\n      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)\n    ) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')\n    }\n\n    // h2\n    if (allowH2 != null && typeof allowH2 !== 'boolean') {\n      throw new InvalidArgumentError('allowH2 must be a valid boolean value')\n    }\n\n    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {\n      throw new InvalidArgumentError('maxConcurrentStreams must be a positive integer, greater than 0')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    if (interceptors?.Client && Array.isArray(interceptors.Client)) {\n      this[kInterceptors] = interceptors.Client\n      if (!deprecatedInterceptorWarned) {\n        deprecatedInterceptorWarned = true\n        process.emitWarning('Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.', {\n          code: 'UNDICI-CLIENT-INTERCEPTOR-DEPRECATED'\n        })\n      }\n    } else {\n      this[kInterceptors] = [createRedirectInterceptor({ maxRedirections })]\n    }\n\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kLocalAddress] = localAddress != null ? localAddress : null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1\n    this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n    this[kHTTPContext] = null\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n\n    this[kResume] = (sync) => resume(this, sync)\n    this[kOnError] = (err) => onError(this, err)\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    this[kResume](true)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed\n  }\n\n  get [kBusy] () {\n    return Boolean(\n      this[kHTTPContext]?.busy(null) ||\n      (this[kSize] >= (getPipelining(this) || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const origin = opts.origin || this[kUrl].origin\n    const request = new Request(origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      queueMicrotask(() => resume(this))\n    } else {\n      this[kResume](true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  async [kClose] () {\n    // TODO: for H2 we need to gracefully flush the remaining enqueued\n    // request and close each stream.\n    return new Promise((resolve) => {\n      if (this[kSize]) {\n        this[kClosedResolve] = resolve\n      } else {\n        resolve(null)\n      }\n    })\n  }\n\n  async [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          // TODO (fix): Should we error here with ClientDestroyedError?\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve(null)\n      }\n\n      if (this[kHTTPContext]) {\n        this[kHTTPContext].destroy(err, callback)\n        this[kHTTPContext] = null\n      } else {\n        queueMicrotask(callback)\n      }\n\n      this[kResume]()\n    })\n  }\n}\n\nconst createRedirectInterceptor = require('../interceptor/redirect-interceptor.js')\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      util.errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\n/**\n * @param {Client} client\n * @returns\n */\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kHTTPContext])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substring(1, idx)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        version: client[kHTTPContext]?.version,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (client.destroyed) {\n      util.destroy(socket.on('error', noop), new ClientDestroyedError())\n      return\n    }\n\n    assert(socket)\n\n    try {\n      client[kHTTPContext] = socket.alpnProtocol === 'h2'\n        ? await connectH2(client, socket)\n        : await connectH1(client, socket)\n    } catch (err) {\n      socket.destroy().on('error', noop)\n      throw err\n    }\n\n    client[kConnecting] = false\n\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket[kClient] = client\n    socket[kError] = null\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          version: client[kHTTPContext]?.version,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    if (client.destroyed) {\n      return\n    }\n\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          version: client[kHTTPContext]?.version,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        util.errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  client[kResume]()\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client[kClosedResolve] && !client[kSize]) {\n      client[kClosedResolve]()\n      client[kClosedResolve] = null\n      return\n    }\n\n    if (client[kHTTPContext]) {\n      client[kHTTPContext].resume()\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        queueMicrotask(() => emitDrain(client))\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (getPipelining(client) || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n      client[kHTTPContext]?.destroy(new InformationalError('servername changed'), () => {\n        client[kHTTPContext] = null\n        resume(client)\n      })\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!client[kHTTPContext]) {\n      connect(client)\n      return\n    }\n\n    if (client[kHTTPContext].destroyed) {\n      return\n    }\n\n    if (client[kHTTPContext].busy(request)) {\n      return\n    }\n\n    if (!request.aborted && client[kHTTPContext].write(request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nmodule.exports = Client\n"]}}