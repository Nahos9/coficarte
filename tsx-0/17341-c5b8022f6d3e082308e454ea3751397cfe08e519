{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const net=require(\"node:net\");const assert=require(\"node:assert\");const util=require(\"./util\");const{InvalidArgumentError,ConnectTimeoutError}=require(\"./errors\");const timers=require(\"../util/timers\");function noop(){}__name(noop,\"noop\");let tls;let SessionCache;if(global.FinalizationRegistry&&!(process.env.NODE_V8_COVERAGE||process.env.UNDICI_NO_FG)){SessionCache=class WeakSessionCache{static{__name(this,\"WeakSessionCache\")}constructor(maxCachedSessions){this._maxCachedSessions=maxCachedSessions;this._sessionCache=new Map;this._sessionRegistry=new global.FinalizationRegistry(key=>{if(this._sessionCache.size<this._maxCachedSessions){return}const ref=this._sessionCache.get(key);if(ref!==void 0&&ref.deref()===void 0){this._sessionCache.delete(key)}})}get(sessionKey){const ref=this._sessionCache.get(sessionKey);return ref?ref.deref():null}set(sessionKey,session){if(this._maxCachedSessions===0){return}this._sessionCache.set(sessionKey,new WeakRef(session));this._sessionRegistry.register(session,sessionKey)}}}else{SessionCache=class SimpleSessionCache{static{__name(this,\"SimpleSessionCache\")}constructor(maxCachedSessions){this._maxCachedSessions=maxCachedSessions;this._sessionCache=new Map}get(sessionKey){return this._sessionCache.get(sessionKey)}set(sessionKey,session){if(this._maxCachedSessions===0){return}if(this._sessionCache.size>=this._maxCachedSessions){const{value:oldestKey}=this._sessionCache.keys().next();this._sessionCache.delete(oldestKey)}this._sessionCache.set(sessionKey,session)}}}function buildConnector({allowH2,maxCachedSessions,socketPath,timeout,session:customSession,...opts}){if(maxCachedSessions!=null&&(!Number.isInteger(maxCachedSessions)||maxCachedSessions<0)){throw new InvalidArgumentError(\"maxCachedSessions must be a positive integer or zero\")}const options={path:socketPath,...opts};const sessionCache=new SessionCache(maxCachedSessions==null?100:maxCachedSessions);timeout=timeout==null?1e4:timeout;allowH2=allowH2!=null?allowH2:false;return __name(function connect({hostname,host,protocol,port,servername,localAddress,httpSocket},callback){let socket;if(protocol===\"https:\"){if(!tls){tls=require(\"node:tls\")}servername=servername||options.servername||util.getServerName(host)||null;const sessionKey=servername||hostname;assert(sessionKey);const session=customSession||sessionCache.get(sessionKey)||null;port=port||443;socket=tls.connect({highWaterMark:16384,...options,servername,session,localAddress,ALPNProtocols:allowH2?[\"http/1.1\",\"h2\"]:[\"http/1.1\"],socket:httpSocket,port,host:hostname});socket.on(\"session\",function(session2){sessionCache.set(sessionKey,session2)})}else{assert(!httpSocket,\"httpSocket can only be sent on TLS update\");port=port||80;socket=net.connect({highWaterMark:64*1024,...options,localAddress,port,host:hostname})}if(options.keepAlive==null||options.keepAlive){const keepAliveInitialDelay=options.keepAliveInitialDelay===void 0?6e4:options.keepAliveInitialDelay;socket.setKeepAlive(true,keepAliveInitialDelay)}const clearConnectTimeout=setupConnectTimeout(new WeakRef(socket),{timeout,hostname,port});socket.setNoDelay(true).once(protocol===\"https:\"?\"secureConnect\":\"connect\",function(){queueMicrotask(clearConnectTimeout);if(callback){const cb=callback;callback=null;cb(null,this)}}).on(\"error\",function(err){queueMicrotask(clearConnectTimeout);if(callback){const cb=callback;callback=null;cb(err)}});return socket},\"connect\")}__name(buildConnector,\"buildConnector\");const setupConnectTimeout=process.platform===\"win32\"?(socketWeakRef,opts)=>{if(!opts.timeout){return noop}let s1=null;let s2=null;const fastTimer=timers.setFastTimeout(()=>{s1=setImmediate(()=>{s2=setImmediate(()=>onConnectTimeout(socketWeakRef.deref(),opts))})},opts.timeout);return()=>{timers.clearFastTimeout(fastTimer);clearImmediate(s1);clearImmediate(s2)}}:(socketWeakRef,opts)=>{if(!opts.timeout){return noop}let s1=null;const fastTimer=timers.setFastTimeout(()=>{s1=setImmediate(()=>{onConnectTimeout(socketWeakRef.deref(),opts)})},opts.timeout);return()=>{timers.clearFastTimeout(fastTimer);clearImmediate(s1)}};function onConnectTimeout(socket,opts){if(socket==null){return}let message=\"Connect Timeout Error\";if(Array.isArray(socket.autoSelectFamilyAttemptedAddresses)){message+=` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(\", \")},`}else{message+=` (attempted address: ${opts.hostname}:${opts.port},`}message+=` timeout: ${opts.timeout}ms)`;util.destroy(socket,new ConnectTimeoutError(message))}__name(onConnectTimeout,\"onConnectTimeout\");module.exports=buildConnector;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAEA,MAAM,IAAM,QAAQ,UAAU,EAC9B,MAAM,OAAS,QAAQ,aAAa,EACpC,MAAM,KAAO,QAAQ,QAAQ,EAC7B,KAAM,CAAE,qBAAsB,mBAAoB,EAAI,QAAQ,UAAU,EACxE,MAAM,OAAS,QAAQ,gBAAgB,EAEvC,SAAS,MAAQ,CAAC,CAAT,oBAET,IAAI,IAOJ,IAAI,aAGJ,GAAI,OAAO,sBAAwB,EAAE,QAAQ,IAAI,kBAAoB,QAAQ,IAAI,cAAe,CAC9F,aAAe,MAAM,gBAAiB,CArBxC,MAqBwC,iCACpC,YAAa,kBAAmB,CAC9B,KAAK,mBAAqB,kBAC1B,KAAK,cAAgB,IAAI,IACzB,KAAK,iBAAmB,IAAI,OAAO,qBAAsB,KAAQ,CAC/D,GAAI,KAAK,cAAc,KAAO,KAAK,mBAAoB,CACrD,MACF,CAEA,MAAM,IAAM,KAAK,cAAc,IAAI,GAAG,EACtC,GAAI,MAAQ,QAAa,IAAI,MAAM,IAAM,OAAW,CAClD,KAAK,cAAc,OAAO,GAAG,CAC/B,CACF,CAAC,CACH,CAEA,IAAK,WAAY,CACf,MAAM,IAAM,KAAK,cAAc,IAAI,UAAU,EAC7C,OAAO,IAAM,IAAI,MAAM,EAAI,IAC7B,CAEA,IAAK,WAAY,QAAS,CACxB,GAAI,KAAK,qBAAuB,EAAG,CACjC,MACF,CAEA,KAAK,cAAc,IAAI,WAAY,IAAI,QAAQ,OAAO,CAAC,EACvD,KAAK,iBAAiB,SAAS,QAAS,UAAU,CACpD,CACF,CACF,KAAO,CACL,aAAe,MAAM,kBAAmB,CApD1C,MAoD0C,mCACtC,YAAa,kBAAmB,CAC9B,KAAK,mBAAqB,kBAC1B,KAAK,cAAgB,IAAI,GAC3B,CAEA,IAAK,WAAY,CACf,OAAO,KAAK,cAAc,IAAI,UAAU,CAC1C,CAEA,IAAK,WAAY,QAAS,CACxB,GAAI,KAAK,qBAAuB,EAAG,CACjC,MACF,CAEA,GAAI,KAAK,cAAc,MAAQ,KAAK,mBAAoB,CAEtD,KAAM,CAAE,MAAO,SAAU,EAAI,KAAK,cAAc,KAAK,EAAE,KAAK,EAC5D,KAAK,cAAc,OAAO,SAAS,CACrC,CAEA,KAAK,cAAc,IAAI,WAAY,OAAO,CAC5C,CACF,CACF,CAEA,SAAS,eAAgB,CAAE,QAAS,kBAAmB,WAAY,QAAS,QAAS,cAAe,GAAG,IAAK,EAAG,CAC7G,GAAI,mBAAqB,OAAS,CAAC,OAAO,UAAU,iBAAiB,GAAK,kBAAoB,GAAI,CAChG,MAAM,IAAI,qBAAqB,sDAAsD,CACvF,CAEA,MAAM,QAAU,CAAE,KAAM,WAAY,GAAG,IAAK,EAC5C,MAAM,aAAe,IAAI,aAAa,mBAAqB,KAAO,IAAM,iBAAiB,EACzF,QAAU,SAAW,KAAO,IAAO,QACnC,QAAU,SAAW,KAAO,QAAU,MACtC,OAAO,gBAAS,QAAS,CAAE,SAAU,KAAM,SAAU,KAAM,WAAY,aAAc,UAAW,EAAG,SAAU,CAC3G,IAAI,OACJ,GAAI,WAAa,SAAU,CACzB,GAAI,CAAC,IAAK,CACR,IAAM,QAAQ,UAAU,CAC1B,CACA,WAAa,YAAc,QAAQ,YAAc,KAAK,cAAc,IAAI,GAAK,KAE7E,MAAM,WAAa,YAAc,SACjC,OAAO,UAAU,EAEjB,MAAM,QAAU,eAAiB,aAAa,IAAI,UAAU,GAAK,KAEjE,KAAO,MAAQ,IAEf,OAAS,IAAI,QAAQ,CACnB,cAAe,MACf,GAAG,QACH,WACA,QACA,aAEA,cAAe,QAAU,CAAC,WAAY,IAAI,EAAI,CAAC,UAAU,EACzD,OAAQ,WACR,KACA,KAAM,QACR,CAAC,EAED,OACG,GAAG,UAAW,SAAUA,SAAS,CAEhC,aAAa,IAAI,WAAYA,QAAO,CACtC,CAAC,CACL,KAAO,CACL,OAAO,CAAC,WAAY,2CAA2C,EAE/D,KAAO,MAAQ,GAEf,OAAS,IAAI,QAAQ,CACnB,cAAe,GAAK,KACpB,GAAG,QACH,aACA,KACA,KAAM,QACR,CAAC,CACH,CAGA,GAAI,QAAQ,WAAa,MAAQ,QAAQ,UAAW,CAClD,MAAM,sBAAwB,QAAQ,wBAA0B,OAAY,IAAO,QAAQ,sBAC3F,OAAO,aAAa,KAAM,qBAAqB,CACjD,CAEA,MAAM,oBAAsB,oBAAoB,IAAI,QAAQ,MAAM,EAAG,CAAE,QAAS,SAAU,IAAK,CAAC,EAEhG,OACG,WAAW,IAAI,EACf,KAAK,WAAa,SAAW,gBAAkB,UAAW,UAAY,CACrE,eAAe,mBAAmB,EAElC,GAAI,SAAU,CACZ,MAAM,GAAK,SACX,SAAW,KACX,GAAG,KAAM,IAAI,CACf,CACF,CAAC,EACA,GAAG,QAAS,SAAU,IAAK,CAC1B,eAAe,mBAAmB,EAElC,GAAI,SAAU,CACZ,MAAM,GAAK,SACX,SAAW,KACX,GAAG,GAAG,CACR,CACF,CAAC,EAEH,OAAO,MACT,EA7EO,UA8ET,CAvFS,wCAiGT,MAAM,oBAAsB,QAAQ,WAAa,QAC7C,CAAC,cAAe,OAAS,CACvB,GAAI,CAAC,KAAK,QAAS,CACjB,OAAO,IACT,CAEA,IAAI,GAAK,KACT,IAAI,GAAK,KACT,MAAM,UAAY,OAAO,eAAe,IAAM,CAE5C,GAAK,aAAa,IAAM,CAEtB,GAAK,aAAa,IAAM,iBAAiB,cAAc,MAAM,EAAG,IAAI,CAAC,CACvE,CAAC,CACH,EAAG,KAAK,OAAO,EACf,MAAO,IAAM,CACX,OAAO,iBAAiB,SAAS,EACjC,eAAe,EAAE,EACjB,eAAe,EAAE,CACnB,CACF,EACA,CAAC,cAAe,OAAS,CACvB,GAAI,CAAC,KAAK,QAAS,CACjB,OAAO,IACT,CAEA,IAAI,GAAK,KACT,MAAM,UAAY,OAAO,eAAe,IAAM,CAE5C,GAAK,aAAa,IAAM,CACtB,iBAAiB,cAAc,MAAM,EAAG,IAAI,CAC9C,CAAC,CACH,EAAG,KAAK,OAAO,EACf,MAAO,IAAM,CACX,OAAO,iBAAiB,SAAS,EACjC,eAAe,EAAE,CACnB,CACF,EASJ,SAAS,iBAAkB,OAAQ,KAAM,CAEvC,GAAI,QAAU,KAAM,CAClB,MACF,CAEA,IAAI,QAAU,wBACd,GAAI,MAAM,QAAQ,OAAO,kCAAkC,EAAG,CAC5D,SAAW,0BAA0B,OAAO,mCAAmC,KAAK,IAAI,CAAC,GAC3F,KAAO,CACL,SAAW,wBAAwB,KAAK,QAAQ,IAAI,KAAK,IAAI,GAC/D,CAEA,SAAW,aAAa,KAAK,OAAO,MAEpC,KAAK,QAAQ,OAAQ,IAAI,oBAAoB,OAAO,CAAC,CACvD,CAhBS,4CAkBT,OAAO,QAAU","names":["session"],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/core/connect.js"],"sourcesContent":["'use strict'\n\nconst net = require('node:net')\nconst assert = require('node:assert')\nconst util = require('./util')\nconst { InvalidArgumentError, ConnectTimeoutError } = require('./errors')\nconst timers = require('../util/timers')\n\nfunction noop () {}\n\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nlet SessionCache\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif (global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {\n  SessionCache = class WeakSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n      this._sessionRegistry = new global.FinalizationRegistry((key) => {\n        if (this._sessionCache.size < this._maxCachedSessions) {\n          return\n        }\n\n        const ref = this._sessionCache.get(key)\n        if (ref !== undefined && ref.deref() === undefined) {\n          this._sessionCache.delete(key)\n        }\n      })\n    }\n\n    get (sessionKey) {\n      const ref = this._sessionCache.get(sessionKey)\n      return ref ? ref.deref() : null\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      this._sessionCache.set(sessionKey, new WeakRef(session))\n      this._sessionRegistry.register(session, sessionKey)\n    }\n  }\n} else {\n  SessionCache = class SimpleSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n    }\n\n    get (sessionKey) {\n      return this._sessionCache.get(sessionKey)\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      if (this._sessionCache.size >= this._maxCachedSessions) {\n        // remove the oldest session\n        const { value: oldestKey } = this._sessionCache.keys().next()\n        this._sessionCache.delete(oldestKey)\n      }\n\n      this._sessionCache.set(sessionKey, session)\n    }\n  }\n}\n\nfunction buildConnector ({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions)\n  timeout = timeout == null ? 10e3 : timeout\n  allowH2 = allowH2 != null ? allowH2 : false\n  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('node:tls')\n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      assert(sessionKey)\n\n      const session = customSession || sessionCache.get(sessionKey) || null\n\n      port = port || 443\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        localAddress,\n        // TODO(HTTP/2): Add support for h2c\n        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],\n        socket: httpSocket, // upgrade socket connection\n        port,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // TODO (fix): Can a session become invalid once established? Don't think so?\n          sessionCache.set(sessionKey, session)\n        })\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update')\n\n      port = port || 80\n\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        localAddress,\n        port,\n        host: hostname\n      })\n    }\n\n    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n    if (options.keepAlive == null || options.keepAlive) {\n      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay\n      socket.setKeepAlive(true, keepAliveInitialDelay)\n    }\n\n    const clearConnectTimeout = setupConnectTimeout(new WeakRef(socket), { timeout, hostname, port })\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        queueMicrotask(clearConnectTimeout)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        queueMicrotask(clearConnectTimeout)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\n/**\n * @param {WeakRef<net.Socket>} socketWeakRef\n * @param {object} opts\n * @param {number} opts.timeout\n * @param {string} opts.hostname\n * @param {number} opts.port\n * @returns {() => void}\n */\nconst setupConnectTimeout = process.platform === 'win32'\n  ? (socketWeakRef, opts) => {\n      if (!opts.timeout) {\n        return noop\n      }\n\n      let s1 = null\n      let s2 = null\n      const fastTimer = timers.setFastTimeout(() => {\n      // setImmediate is added to make sure that we prioritize socket error events over timeouts\n        s1 = setImmediate(() => {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n          s2 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts))\n        })\n      }, opts.timeout)\n      return () => {\n        timers.clearFastTimeout(fastTimer)\n        clearImmediate(s1)\n        clearImmediate(s2)\n      }\n    }\n  : (socketWeakRef, opts) => {\n      if (!opts.timeout) {\n        return noop\n      }\n\n      let s1 = null\n      const fastTimer = timers.setFastTimeout(() => {\n      // setImmediate is added to make sure that we prioritize socket error events over timeouts\n        s1 = setImmediate(() => {\n          onConnectTimeout(socketWeakRef.deref(), opts)\n        })\n      }, opts.timeout)\n      return () => {\n        timers.clearFastTimeout(fastTimer)\n        clearImmediate(s1)\n      }\n    }\n\n/**\n * @param {net.Socket} socket\n * @param {object} opts\n * @param {number} opts.timeout\n * @param {string} opts.hostname\n * @param {number} opts.port\n */\nfunction onConnectTimeout (socket, opts) {\n  // The socket could be already garbage collected\n  if (socket == null) {\n    return\n  }\n\n  let message = 'Connect Timeout Error'\n  if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {\n    message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(', ')},`\n  } else {\n    message += ` (attempted address: ${opts.hostname}:${opts.port},`\n  }\n\n  message += ` timeout: ${opts.timeout}ms)`\n\n  util.destroy(socket, new ConnectTimeoutError(message))\n}\n\nmodule.exports = buildConnector\n"]}}