{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{InvalidArgumentError}=require(\"../core/errors\");const{kClients,kRunning,kClose,kDestroy,kDispatch,kInterceptors}=require(\"../core/symbols\");const DispatcherBase=require(\"./dispatcher-base\");const Pool=require(\"./pool\");const Client=require(\"./client\");const util=require(\"../core/util\");const createRedirectInterceptor=require(\"../interceptor/redirect-interceptor\");const kOnConnect=Symbol(\"onConnect\");const kOnDisconnect=Symbol(\"onDisconnect\");const kOnConnectionError=Symbol(\"onConnectionError\");const kMaxRedirections=Symbol(\"maxRedirections\");const kOnDrain=Symbol(\"onDrain\");const kFactory=Symbol(\"factory\");const kOptions=Symbol(\"options\");function defaultFactory(origin,opts){return opts&&opts.connections===1?new Client(origin,opts):new Pool(origin,opts)}__name(defaultFactory,\"defaultFactory\");class Agent extends DispatcherBase{static{__name(this,\"Agent\")}constructor({factory=defaultFactory,maxRedirections=0,connect,...options}={}){super();if(typeof factory!==\"function\"){throw new InvalidArgumentError(\"factory must be a function.\")}if(connect!=null&&typeof connect!==\"function\"&&typeof connect!==\"object\"){throw new InvalidArgumentError(\"connect must be a function or an object\")}if(!Number.isInteger(maxRedirections)||maxRedirections<0){throw new InvalidArgumentError(\"maxRedirections must be a positive number\")}if(connect&&typeof connect!==\"function\"){connect={...connect}}this[kInterceptors]=options.interceptors?.Agent&&Array.isArray(options.interceptors.Agent)?options.interceptors.Agent:[createRedirectInterceptor({maxRedirections})];this[kOptions]={...util.deepClone(options),connect};this[kOptions].interceptors=options.interceptors?{...options.interceptors}:void 0;this[kMaxRedirections]=maxRedirections;this[kFactory]=factory;this[kClients]=new Map;this[kOnDrain]=(origin,targets)=>{this.emit(\"drain\",origin,[this,...targets])};this[kOnConnect]=(origin,targets)=>{this.emit(\"connect\",origin,[this,...targets])};this[kOnDisconnect]=(origin,targets,err)=>{this.emit(\"disconnect\",origin,[this,...targets],err)};this[kOnConnectionError]=(origin,targets,err)=>{this.emit(\"connectionError\",origin,[this,...targets],err)}}get[kRunning](){let ret=0;for(const client of this[kClients].values()){ret+=client[kRunning]}return ret}[kDispatch](opts,handler){let key;if(opts.origin&&(typeof opts.origin===\"string\"||opts.origin instanceof URL)){key=String(opts.origin)}else{throw new InvalidArgumentError(\"opts.origin must be a non-empty string or URL.\")}let dispatcher=this[kClients].get(key);if(!dispatcher){dispatcher=this[kFactory](opts.origin,this[kOptions]).on(\"drain\",this[kOnDrain]).on(\"connect\",this[kOnConnect]).on(\"disconnect\",this[kOnDisconnect]).on(\"connectionError\",this[kOnConnectionError]);this[kClients].set(key,dispatcher)}return dispatcher.dispatch(opts,handler)}async[kClose](){const closePromises=[];for(const client of this[kClients].values()){closePromises.push(client.close())}this[kClients].clear();await Promise.all(closePromises)}async[kDestroy](err){const destroyPromises=[];for(const client of this[kClients].values()){destroyPromises.push(client.destroy(err))}this[kClients].clear();await Promise.all(destroyPromises)}}module.exports=Agent;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/dispatcher/agent.js"],"sourcesContent":["'use strict'\n\nconst { InvalidArgumentError } = require('../core/errors')\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require('../core/symbols')\nconst DispatcherBase = require('./dispatcher-base')\nconst Pool = require('./pool')\nconst Client = require('./client')\nconst util = require('../core/util')\nconst createRedirectInterceptor = require('../interceptor/redirect-interceptor')\n\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kMaxRedirections = Symbol('maxRedirections')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kOptions = Symbol('options')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends DispatcherBase {\n  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {\n    super()\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kInterceptors] = options.interceptors?.Agent && Array.isArray(options.interceptors.Agent)\n      ? options.interceptors.Agent\n      : [createRedirectInterceptor({ maxRedirections })]\n\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kOptions].interceptors = options.interceptors\n      ? { ...options.interceptors }\n      : undefined\n    this[kMaxRedirections] = maxRedirections\n    this[kFactory] = factory\n    this[kClients] = new Map()\n\n    this[kOnDrain] = (origin, targets) => {\n      this.emit('drain', origin, [this, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      this.emit('connect', origin, [this, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      this.emit('disconnect', origin, [this, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      this.emit('connectionError', origin, [this, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const client of this[kClients].values()) {\n      ret += client[kRunning]\n    }\n    return ret\n  }\n\n  [kDispatch] (opts, handler) {\n    let key\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin)\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n    }\n\n    let dispatcher = this[kClients].get(key)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](opts.origin, this[kOptions])\n        .on('drain', this[kOnDrain])\n        .on('connect', this[kOnConnect])\n        .on('disconnect', this[kOnDisconnect])\n        .on('connectionError', this[kOnConnectionError])\n\n      // This introduces a tiny memory leak, as dispatchers are never removed from the map.\n      // TODO(mcollina): remove te timer when the client/pool do not have any more\n      // active connections.\n      this[kClients].set(key, dispatcher)\n    }\n\n    return dispatcher.dispatch(opts, handler)\n  }\n\n  async [kClose] () {\n    const closePromises = []\n    for (const client of this[kClients].values()) {\n      closePromises.push(client.close())\n    }\n    this[kClients].clear()\n\n    await Promise.all(closePromises)\n  }\n\n  async [kDestroy] (err) {\n    const destroyPromises = []\n    for (const client of this[kClients].values()) {\n      destroyPromises.push(client.destroy(err))\n    }\n    this[kClients].clear()\n\n    await Promise.all(destroyPromises)\n  }\n}\n\nmodule.exports = Agent\n"]}}