{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{makeNetworkError,makeAppropriateNetworkError,filterResponse,makeResponse,fromInnerResponse}=require(\"./response\");const{HeadersList}=require(\"./headers\");const{Request,cloneRequest}=require(\"./request\");const zlib=require(\"node:zlib\");const{bytesMatch,makePolicyContainer,clonePolicyContainer,requestBadPort,TAOCheck,appendRequestOriginHeader,responseLocationURL,requestCurrentURL,setRequestReferrerPolicyOnRedirect,tryUpgradeRequestToAPotentiallyTrustworthyURL,createOpaqueTimingInfo,appendFetchMetadata,corsCheck,crossOriginResourcePolicyCheck,determineRequestsReferrer,coarsenedSharedCurrentTime,createDeferredPromise,isBlobLike,sameOrigin,isCancelled,isAborted,isErrorLike,fullyReadBody,readableStreamClose,isomorphicEncode,urlIsLocal,urlIsHttpHttpsScheme,urlHasHttpsScheme,clampAndCoarsenConnectionTimingInfo,simpleRangeHeaderValue,buildContentRange,createInflate,extractMimeType}=require(\"./util\");const{kState,kDispatcher}=require(\"./symbols\");const assert=require(\"node:assert\");const{safelyExtractBody,extractBody}=require(\"./body\");const{redirectStatusSet,nullBodyStatus,safeMethodsSet,requestBodyHeader,subresourceSet}=require(\"./constants\");const EE=require(\"node:events\");const{Readable,pipeline,finished}=require(\"node:stream\");const{addAbortListener,isErrored,isReadable,bufferToLowerCasedHeaderName}=require(\"../../core/util\");const{dataURLProcessor,serializeAMimeType,minimizeSupportedMimeType}=require(\"./data-url\");const{getGlobalDispatcher}=require(\"../../global\");const{webidl}=require(\"./webidl\");const{STATUS_CODES}=require(\"node:http\");const GET_OR_HEAD=[\"GET\",\"HEAD\"];const defaultUserAgent=typeof __UNDICI_IS_NODE__!==\"undefined\"||typeof esbuildDetection!==\"undefined\"?\"node\":\"undici\";let resolveObjectURL;class Fetch extends EE{static{__name(this,\"Fetch\")}constructor(dispatcher){super();this.dispatcher=dispatcher;this.connection=null;this.dump=false;this.state=\"ongoing\"}terminate(reason){if(this.state!==\"ongoing\"){return}this.state=\"terminated\";this.connection?.destroy(reason);this.emit(\"terminated\",reason)}abort(error){if(this.state!==\"ongoing\"){return}this.state=\"aborted\";if(!error){error=new DOMException(\"The operation was aborted.\",\"AbortError\")}this.serializedAbortReason=error;this.connection?.destroy(error);this.emit(\"terminated\",error)}}function handleFetchDone(response){finalizeAndReportTiming(response,\"fetch\")}__name(handleFetchDone,\"handleFetchDone\");function fetch(input,init=void 0){webidl.argumentLengthCheck(arguments,1,\"globalThis.fetch\");let p=createDeferredPromise();let requestObject;try{requestObject=new Request(input,init)}catch(e){p.reject(e);return p.promise}const request=requestObject[kState];if(requestObject.signal.aborted){abortFetch(p,request,null,requestObject.signal.reason);return p.promise}const globalObject=request.client.globalObject;if(globalObject?.constructor?.name===\"ServiceWorkerGlobalScope\"){request.serviceWorkers=\"none\"}let responseObject=null;let locallyAborted=false;let controller=null;addAbortListener(requestObject.signal,()=>{locallyAborted=true;assert(controller!=null);controller.abort(requestObject.signal.reason);const realResponse=responseObject?.deref();abortFetch(p,request,realResponse,requestObject.signal.reason)});const processResponse=__name(response=>{if(locallyAborted){return}if(response.aborted){abortFetch(p,request,responseObject,controller.serializedAbortReason);return}if(response.type===\"error\"){p.reject(new TypeError(\"fetch failed\",{cause:response.error}));return}responseObject=new WeakRef(fromInnerResponse(response,\"immutable\"));p.resolve(responseObject.deref());p=null},\"processResponse\");controller=fetching({request,processResponseEndOfBody:handleFetchDone,processResponse,dispatcher:requestObject[kDispatcher]});return p.promise}__name(fetch,\"fetch\");function finalizeAndReportTiming(response,initiatorType=\"other\"){if(response.type===\"error\"&&response.aborted){return}if(!response.urlList?.length){return}const originalURL=response.urlList[0];let timingInfo=response.timingInfo;let cacheState=response.cacheState;if(!urlIsHttpHttpsScheme(originalURL)){return}if(timingInfo===null){return}if(!response.timingAllowPassed){timingInfo=createOpaqueTimingInfo({startTime:timingInfo.startTime});cacheState=\"\"}timingInfo.endTime=coarsenedSharedCurrentTime();response.timingInfo=timingInfo;markResourceTiming(timingInfo,originalURL.href,initiatorType,globalThis,cacheState)}__name(finalizeAndReportTiming,\"finalizeAndReportTiming\");const markResourceTiming=performance.markResourceTiming;function abortFetch(p,request,responseObject,error){if(p){p.reject(error)}if(request.body!=null&&isReadable(request.body?.stream)){request.body.stream.cancel(error).catch(err=>{if(err.code===\"ERR_INVALID_STATE\"){return}throw err})}if(responseObject==null){return}const response=responseObject[kState];if(response.body!=null&&isReadable(response.body?.stream)){response.body.stream.cancel(error).catch(err=>{if(err.code===\"ERR_INVALID_STATE\"){return}throw err})}}__name(abortFetch,\"abortFetch\");function fetching({request,processRequestBodyChunkLength,processRequestEndOfBody,processResponse,processResponseEndOfBody,processResponseConsumeBody,useParallelQueue=false,dispatcher=getGlobalDispatcher()}){assert(dispatcher);let taskDestination=null;let crossOriginIsolatedCapability=false;if(request.client!=null){taskDestination=request.client.globalObject;crossOriginIsolatedCapability=request.client.crossOriginIsolatedCapability}const currentTime=coarsenedSharedCurrentTime(crossOriginIsolatedCapability);const timingInfo=createOpaqueTimingInfo({startTime:currentTime});const fetchParams={controller:new Fetch(dispatcher),request,timingInfo,processRequestBodyChunkLength,processRequestEndOfBody,processResponse,processResponseConsumeBody,processResponseEndOfBody,taskDestination,crossOriginIsolatedCapability};assert(!request.body||request.body.stream);if(request.window===\"client\"){request.window=request.client?.globalObject?.constructor?.name===\"Window\"?request.client:\"no-window\"}if(request.origin===\"client\"){request.origin=request.client.origin}if(request.policyContainer===\"client\"){if(request.client!=null){request.policyContainer=clonePolicyContainer(request.client.policyContainer)}else{request.policyContainer=makePolicyContainer()}}if(!request.headersList.contains(\"accept\",true)){const value=\"*/*\";request.headersList.append(\"accept\",value,true)}if(!request.headersList.contains(\"accept-language\",true)){request.headersList.append(\"accept-language\",\"*\",true)}if(request.priority===null){}if(subresourceSet.has(request.destination)){}mainFetch(fetchParams).catch(err=>{fetchParams.controller.terminate(err)});return fetchParams.controller}__name(fetching,\"fetching\");async function mainFetch(fetchParams,recursive=false){const request=fetchParams.request;let response=null;if(request.localURLsOnly&&!urlIsLocal(requestCurrentURL(request))){response=makeNetworkError(\"local URLs only\")}tryUpgradeRequestToAPotentiallyTrustworthyURL(request);if(requestBadPort(request)===\"blocked\"){response=makeNetworkError(\"bad port\")}if(request.referrerPolicy===\"\"){request.referrerPolicy=request.policyContainer.referrerPolicy}if(request.referrer!==\"no-referrer\"){request.referrer=determineRequestsReferrer(request)}if(response===null){response=await(async()=>{const currentURL=requestCurrentURL(request);if(sameOrigin(currentURL,request.url)&&request.responseTainting===\"basic\"||currentURL.protocol===\"data:\"||(request.mode===\"navigate\"||request.mode===\"websocket\")){request.responseTainting=\"basic\";return await schemeFetch(fetchParams)}if(request.mode===\"same-origin\"){return makeNetworkError('request mode cannot be \"same-origin\"')}if(request.mode===\"no-cors\"){if(request.redirect!==\"follow\"){return makeNetworkError('redirect mode cannot be \"follow\" for \"no-cors\" request')}request.responseTainting=\"opaque\";return await schemeFetch(fetchParams)}if(!urlIsHttpHttpsScheme(requestCurrentURL(request))){return makeNetworkError(\"URL scheme must be a HTTP(S) scheme\")}request.responseTainting=\"cors\";return await httpFetch(fetchParams)})()}if(recursive){return response}if(response.status!==0&&!response.internalResponse){if(request.responseTainting===\"cors\"){}if(request.responseTainting===\"basic\"){response=filterResponse(response,\"basic\")}else if(request.responseTainting===\"cors\"){response=filterResponse(response,\"cors\")}else if(request.responseTainting===\"opaque\"){response=filterResponse(response,\"opaque\")}else{assert(false)}}let internalResponse=response.status===0?response:response.internalResponse;if(internalResponse.urlList.length===0){internalResponse.urlList.push(...request.urlList)}if(!request.timingAllowFailed){response.timingAllowPassed=true}if(response.type===\"opaque\"&&internalResponse.status===206&&internalResponse.rangeRequested&&!request.headers.contains(\"range\",true)){response=internalResponse=makeNetworkError()}if(response.status!==0&&(request.method===\"HEAD\"||request.method===\"CONNECT\"||nullBodyStatus.includes(internalResponse.status))){internalResponse.body=null;fetchParams.controller.dump=true}if(request.integrity){const processBodyError=__name(reason=>fetchFinale(fetchParams,makeNetworkError(reason)),\"processBodyError\");if(request.responseTainting===\"opaque\"||response.body==null){processBodyError(response.error);return}const processBody=__name(bytes=>{if(!bytesMatch(bytes,request.integrity)){processBodyError(\"integrity mismatch\");return}response.body=safelyExtractBody(bytes)[0];fetchFinale(fetchParams,response)},\"processBody\");await fullyReadBody(response.body,processBody,processBodyError)}else{fetchFinale(fetchParams,response)}}__name(mainFetch,\"mainFetch\");function schemeFetch(fetchParams){if(isCancelled(fetchParams)&&fetchParams.request.redirectCount===0){return Promise.resolve(makeAppropriateNetworkError(fetchParams))}const{request}=fetchParams;const{protocol:scheme}=requestCurrentURL(request);switch(scheme){case\"about:\":{return Promise.resolve(makeNetworkError(\"about scheme is not supported\"))}case\"blob:\":{if(!resolveObjectURL){resolveObjectURL=require(\"node:buffer\").resolveObjectURL}const blobURLEntry=requestCurrentURL(request);if(blobURLEntry.search.length!==0){return Promise.resolve(makeNetworkError(\"NetworkError when attempting to fetch resource.\"))}const blob=resolveObjectURL(blobURLEntry.toString());if(request.method!==\"GET\"||!isBlobLike(blob)){return Promise.resolve(makeNetworkError(\"invalid method\"))}const response=makeResponse();const fullLength=blob.size;const serializedFullLength=isomorphicEncode(`${fullLength}`);const type=blob.type;if(!request.headersList.contains(\"range\",true)){const bodyWithType=extractBody(blob);response.statusText=\"OK\";response.body=bodyWithType[0];response.headersList.set(\"content-length\",serializedFullLength,true);response.headersList.set(\"content-type\",type,true)}else{response.rangeRequested=true;const rangeHeader=request.headersList.get(\"range\",true);const rangeValue=simpleRangeHeaderValue(rangeHeader,true);if(rangeValue===\"failure\"){return Promise.resolve(makeNetworkError(\"failed to fetch the data URL\"))}let{rangeStartValue:rangeStart,rangeEndValue:rangeEnd}=rangeValue;if(rangeStart===null){rangeStart=fullLength-rangeEnd;rangeEnd=rangeStart+rangeEnd-1}else{if(rangeStart>=fullLength){return Promise.resolve(makeNetworkError(\"Range start is greater than the blob's size.\"))}if(rangeEnd===null||rangeEnd>=fullLength){rangeEnd=fullLength-1}}const slicedBlob=blob.slice(rangeStart,rangeEnd,type);const slicedBodyWithType=extractBody(slicedBlob);response.body=slicedBodyWithType[0];const serializedSlicedLength=isomorphicEncode(`${slicedBlob.size}`);const contentRange=buildContentRange(rangeStart,rangeEnd,fullLength);response.status=206;response.statusText=\"Partial Content\";response.headersList.set(\"content-length\",serializedSlicedLength,true);response.headersList.set(\"content-type\",type,true);response.headersList.set(\"content-range\",contentRange,true)}return Promise.resolve(response)}case\"data:\":{const currentURL=requestCurrentURL(request);const dataURLStruct=dataURLProcessor(currentURL);if(dataURLStruct===\"failure\"){return Promise.resolve(makeNetworkError(\"failed to fetch the data URL\"))}const mimeType=serializeAMimeType(dataURLStruct.mimeType);return Promise.resolve(makeResponse({statusText:\"OK\",headersList:[[\"content-type\",{name:\"Content-Type\",value:mimeType}]],body:safelyExtractBody(dataURLStruct.body)[0]}))}case\"file:\":{return Promise.resolve(makeNetworkError(\"not implemented... yet...\"))}case\"http:\":case\"https:\":{return httpFetch(fetchParams).catch(err=>makeNetworkError(err))}default:{return Promise.resolve(makeNetworkError(\"unknown scheme\"))}}}__name(schemeFetch,\"schemeFetch\");function finalizeResponse(fetchParams,response){fetchParams.request.done=true;if(fetchParams.processResponseDone!=null){queueMicrotask(()=>fetchParams.processResponseDone(response))}}__name(finalizeResponse,\"finalizeResponse\");function fetchFinale(fetchParams,response){let timingInfo=fetchParams.timingInfo;const processResponseEndOfBody=__name(()=>{const unsafeEndTime=Date.now();if(fetchParams.request.destination===\"document\"){fetchParams.controller.fullTimingInfo=timingInfo}fetchParams.controller.reportTimingSteps=()=>{if(fetchParams.request.url.protocol!==\"https:\"){return}timingInfo.endTime=unsafeEndTime;let cacheState=response.cacheState;const bodyInfo=response.bodyInfo;if(!response.timingAllowPassed){timingInfo=createOpaqueTimingInfo(timingInfo);cacheState=\"\"}let responseStatus=0;if(fetchParams.request.mode!==\"navigator\"||!response.hasCrossOriginRedirects){responseStatus=response.status;const mimeType=extractMimeType(response.headersList);if(mimeType!==\"failure\"){bodyInfo.contentType=minimizeSupportedMimeType(mimeType)}}if(fetchParams.request.initiatorType!=null){markResourceTiming(timingInfo,fetchParams.request.url.href,fetchParams.request.initiatorType,globalThis,cacheState,bodyInfo,responseStatus)}};const processResponseEndOfBodyTask=__name(()=>{fetchParams.request.done=true;if(fetchParams.processResponseEndOfBody!=null){queueMicrotask(()=>fetchParams.processResponseEndOfBody(response))}if(fetchParams.request.initiatorType!=null){fetchParams.controller.reportTimingSteps()}},\"processResponseEndOfBodyTask\");queueMicrotask(()=>processResponseEndOfBodyTask())},\"processResponseEndOfBody\");if(fetchParams.processResponse!=null){queueMicrotask(()=>{fetchParams.processResponse(response);fetchParams.processResponse=null})}const internalResponse=response.type===\"error\"?response:response.internalResponse??response;if(internalResponse.body==null){processResponseEndOfBody()}else{finished(internalResponse.body.stream,()=>{processResponseEndOfBody()})}}__name(fetchFinale,\"fetchFinale\");async function httpFetch(fetchParams){const request=fetchParams.request;let response=null;let actualResponse=null;const timingInfo=fetchParams.timingInfo;if(request.serviceWorkers===\"all\"){}if(response===null){if(request.redirect===\"follow\"){request.serviceWorkers=\"none\"}actualResponse=response=await httpNetworkOrCacheFetch(fetchParams);if(request.responseTainting===\"cors\"&&corsCheck(request,response)===\"failure\"){return makeNetworkError(\"cors failure\")}if(TAOCheck(request,response)===\"failure\"){request.timingAllowFailed=true}}if((request.responseTainting===\"opaque\"||response.type===\"opaque\")&&crossOriginResourcePolicyCheck(request.origin,request.client,request.destination,actualResponse)===\"blocked\"){return makeNetworkError(\"blocked\")}if(redirectStatusSet.has(actualResponse.status)){if(request.redirect!==\"manual\"){fetchParams.controller.connection.destroy(void 0,false)}if(request.redirect===\"error\"){response=makeNetworkError(\"unexpected redirect\")}else if(request.redirect===\"manual\"){response=actualResponse}else if(request.redirect===\"follow\"){response=await httpRedirectFetch(fetchParams,response)}else{assert(false)}}response.timingInfo=timingInfo;return response}__name(httpFetch,\"httpFetch\");function httpRedirectFetch(fetchParams,response){const request=fetchParams.request;const actualResponse=response.internalResponse?response.internalResponse:response;let locationURL;try{locationURL=responseLocationURL(actualResponse,requestCurrentURL(request).hash);if(locationURL==null){return response}}catch(err){return Promise.resolve(makeNetworkError(err))}if(!urlIsHttpHttpsScheme(locationURL)){return Promise.resolve(makeNetworkError(\"URL scheme must be a HTTP(S) scheme\"))}if(request.redirectCount===20){return Promise.resolve(makeNetworkError(\"redirect count exceeded\"))}request.redirectCount+=1;if(request.mode===\"cors\"&&(locationURL.username||locationURL.password)&&!sameOrigin(request,locationURL)){return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'))}if(request.responseTainting===\"cors\"&&(locationURL.username||locationURL.password)){return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode \"cors\"'))}if(actualResponse.status!==303&&request.body!=null&&request.body.source==null){return Promise.resolve(makeNetworkError())}if([301,302].includes(actualResponse.status)&&request.method===\"POST\"||actualResponse.status===303&&!GET_OR_HEAD.includes(request.method)){request.method=\"GET\";request.body=null;for(const headerName of requestBodyHeader){request.headersList.delete(headerName)}}if(!sameOrigin(requestCurrentURL(request),locationURL)){request.headersList.delete(\"authorization\",true);request.headersList.delete(\"proxy-authorization\",true);request.headersList.delete(\"cookie\",true);request.headersList.delete(\"host\",true)}if(request.body!=null){assert(request.body.source!=null);request.body=safelyExtractBody(request.body.source)[0]}const timingInfo=fetchParams.timingInfo;timingInfo.redirectEndTime=timingInfo.postRedirectStartTime=coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);if(timingInfo.redirectStartTime===0){timingInfo.redirectStartTime=timingInfo.startTime}request.urlList.push(locationURL);setRequestReferrerPolicyOnRedirect(request,actualResponse);return mainFetch(fetchParams,true)}__name(httpRedirectFetch,\"httpRedirectFetch\");async function httpNetworkOrCacheFetch(fetchParams,isAuthenticationFetch=false,isNewConnectionFetch=false){const request=fetchParams.request;let httpFetchParams=null;let httpRequest=null;let response=null;const httpCache=null;const revalidatingFlag=false;if(request.window===\"no-window\"&&request.redirect===\"error\"){httpFetchParams=fetchParams;httpRequest=request}else{httpRequest=cloneRequest(request);httpFetchParams={...fetchParams};httpFetchParams.request=httpRequest}const includeCredentials=request.credentials===\"include\"||request.credentials===\"same-origin\"&&request.responseTainting===\"basic\";const contentLength=httpRequest.body?httpRequest.body.length:null;let contentLengthHeaderValue=null;if(httpRequest.body==null&&[\"POST\",\"PUT\"].includes(httpRequest.method)){contentLengthHeaderValue=\"0\"}if(contentLength!=null){contentLengthHeaderValue=isomorphicEncode(`${contentLength}`)}if(contentLengthHeaderValue!=null){httpRequest.headersList.append(\"content-length\",contentLengthHeaderValue,true)}if(contentLength!=null&&httpRequest.keepalive){}if(httpRequest.referrer instanceof URL){httpRequest.headersList.append(\"referer\",isomorphicEncode(httpRequest.referrer.href),true)}appendRequestOriginHeader(httpRequest);appendFetchMetadata(httpRequest);if(!httpRequest.headersList.contains(\"user-agent\",true)){httpRequest.headersList.append(\"user-agent\",defaultUserAgent)}if(httpRequest.cache===\"default\"&&(httpRequest.headersList.contains(\"if-modified-since\",true)||httpRequest.headersList.contains(\"if-none-match\",true)||httpRequest.headersList.contains(\"if-unmodified-since\",true)||httpRequest.headersList.contains(\"if-match\",true)||httpRequest.headersList.contains(\"if-range\",true))){httpRequest.cache=\"no-store\"}if(httpRequest.cache===\"no-cache\"&&!httpRequest.preventNoCacheCacheControlHeaderModification&&!httpRequest.headersList.contains(\"cache-control\",true)){httpRequest.headersList.append(\"cache-control\",\"max-age=0\",true)}if(httpRequest.cache===\"no-store\"||httpRequest.cache===\"reload\"){if(!httpRequest.headersList.contains(\"pragma\",true)){httpRequest.headersList.append(\"pragma\",\"no-cache\",true)}if(!httpRequest.headersList.contains(\"cache-control\",true)){httpRequest.headersList.append(\"cache-control\",\"no-cache\",true)}}if(httpRequest.headersList.contains(\"range\",true)){httpRequest.headersList.append(\"accept-encoding\",\"identity\",true)}if(!httpRequest.headersList.contains(\"accept-encoding\",true)){if(urlHasHttpsScheme(requestCurrentURL(httpRequest))){httpRequest.headersList.append(\"accept-encoding\",\"br, gzip, deflate\",true)}else{httpRequest.headersList.append(\"accept-encoding\",\"gzip, deflate\",true)}}httpRequest.headersList.delete(\"host\",true);if(includeCredentials){}if(httpCache==null){httpRequest.cache=\"no-store\"}if(httpRequest.cache!==\"no-store\"&&httpRequest.cache!==\"reload\"){}if(response==null){if(httpRequest.cache===\"only-if-cached\"){return makeNetworkError(\"only if cached\")}const forwardResponse=await httpNetworkFetch(httpFetchParams,includeCredentials,isNewConnectionFetch);if(!safeMethodsSet.has(httpRequest.method)&&forwardResponse.status>=200&&forwardResponse.status<=399){}if(revalidatingFlag&&forwardResponse.status===304){}if(response==null){response=forwardResponse}}response.urlList=[...httpRequest.urlList];if(httpRequest.headersList.contains(\"range\",true)){response.rangeRequested=true}response.requestIncludesCredentials=includeCredentials;if(response.status===407){if(request.window===\"no-window\"){return makeNetworkError()}if(isCancelled(fetchParams)){return makeAppropriateNetworkError(fetchParams)}return makeNetworkError(\"proxy authentication required\")}if(response.status===421&&!isNewConnectionFetch&&(request.body==null||request.body.source!=null)){if(isCancelled(fetchParams)){return makeAppropriateNetworkError(fetchParams)}fetchParams.controller.connection.destroy();response=await httpNetworkOrCacheFetch(fetchParams,isAuthenticationFetch,true)}if(isAuthenticationFetch){}return response}__name(httpNetworkOrCacheFetch,\"httpNetworkOrCacheFetch\");async function httpNetworkFetch(fetchParams,includeCredentials=false,forceNewConnection=false){assert(!fetchParams.controller.connection||fetchParams.controller.connection.destroyed);fetchParams.controller.connection={abort:null,destroyed:false,destroy(err,abort=true){if(!this.destroyed){this.destroyed=true;if(abort){this.abort?.(err??new DOMException(\"The operation was aborted.\",\"AbortError\"))}}}};const request=fetchParams.request;let response=null;const timingInfo=fetchParams.timingInfo;const httpCache=null;if(httpCache==null){request.cache=\"no-store\"}const newConnection=forceNewConnection?\"yes\":\"no\";if(request.mode===\"websocket\"){}else{}let requestBody=null;if(request.body==null&&fetchParams.processRequestEndOfBody){queueMicrotask(()=>fetchParams.processRequestEndOfBody())}else if(request.body!=null){const processBodyChunk=__name(async function*(bytes){if(isCancelled(fetchParams)){return}yield bytes;fetchParams.processRequestBodyChunkLength?.(bytes.byteLength)},\"processBodyChunk\");const processEndOfBody=__name(()=>{if(isCancelled(fetchParams)){return}if(fetchParams.processRequestEndOfBody){fetchParams.processRequestEndOfBody()}},\"processEndOfBody\");const processBodyError=__name(e=>{if(isCancelled(fetchParams)){return}if(e.name===\"AbortError\"){fetchParams.controller.abort()}else{fetchParams.controller.terminate(e)}},\"processBodyError\");requestBody=async function*(){try{for await(const bytes of request.body.stream){yield*processBodyChunk(bytes)}processEndOfBody()}catch(err){processBodyError(err)}}()}try{const{body,status,statusText,headersList,socket}=await dispatch({body:requestBody});if(socket){response=makeResponse({status,statusText,headersList,socket})}else{const iterator=body[Symbol.asyncIterator]();fetchParams.controller.next=()=>iterator.next();response=makeResponse({status,statusText,headersList})}}catch(err){if(err.name===\"AbortError\"){fetchParams.controller.connection.destroy();return makeAppropriateNetworkError(fetchParams,err)}return makeNetworkError(err)}const pullAlgorithm=__name(async()=>{await fetchParams.controller.resume()},\"pullAlgorithm\");const cancelAlgorithm=__name(reason=>{if(!isCancelled(fetchParams)){fetchParams.controller.abort(reason)}},\"cancelAlgorithm\");const stream=new ReadableStream({async start(controller){fetchParams.controller.controller=controller},async pull(controller){await pullAlgorithm(controller)},async cancel(reason){await cancelAlgorithm(reason)},type:\"bytes\"});response.body={stream,source:null,length:null};fetchParams.controller.onAborted=onAborted;fetchParams.controller.on(\"terminated\",onAborted);fetchParams.controller.resume=async()=>{while(true){let bytes;let isFailure;try{const{done,value}=await fetchParams.controller.next();if(isAborted(fetchParams)){break}bytes=done?void 0:value}catch(err){if(fetchParams.controller.ended&&!timingInfo.encodedBodySize){bytes=void 0}else{bytes=err;isFailure=true}}if(bytes===void 0){readableStreamClose(fetchParams.controller.controller);finalizeResponse(fetchParams,response);return}timingInfo.decodedBodySize+=bytes?.byteLength??0;if(isFailure){fetchParams.controller.terminate(bytes);return}const buffer=new Uint8Array(bytes);if(buffer.byteLength){fetchParams.controller.controller.enqueue(buffer)}if(isErrored(stream)){fetchParams.controller.terminate();return}if(fetchParams.controller.controller.desiredSize<=0){return}}};function onAborted(reason){if(isAborted(fetchParams)){response.aborted=true;if(isReadable(stream)){fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason)}}else{if(isReadable(stream)){fetchParams.controller.controller.error(new TypeError(\"terminated\",{cause:isErrorLike(reason)?reason:void 0}))}}fetchParams.controller.connection.destroy()}__name(onAborted,\"onAborted\");return response;function dispatch({body}){const url=requestCurrentURL(request);const agent=fetchParams.controller.dispatcher;return new Promise((resolve,reject)=>agent.dispatch({path:url.pathname+url.search,origin:url.origin,method:request.method,body:agent.isMockActive?request.body&&(request.body.source||request.body.stream):body,headers:request.headersList.entries,maxRedirections:0,upgrade:request.mode===\"websocket\"?\"websocket\":void 0},{body:null,abort:null,onConnect(abort){const{connection}=fetchParams.controller;timingInfo.finalConnectionTimingInfo=clampAndCoarsenConnectionTimingInfo(void 0,timingInfo.postRedirectStartTime,fetchParams.crossOriginIsolatedCapability);if(connection.destroyed){abort(new DOMException(\"The operation was aborted.\",\"AbortError\"))}else{fetchParams.controller.on(\"terminated\",abort);this.abort=connection.abort=abort}timingInfo.finalNetworkRequestStartTime=coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)},onResponseStarted(){timingInfo.finalNetworkResponseStartTime=coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)},onHeaders(status,rawHeaders,resume,statusText){if(status<200){return}let codings=[];let location=\"\";const headersList=new HeadersList;for(let i=0;i<rawHeaders.length;i+=2){headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]),rawHeaders[i+1].toString(\"latin1\"),true)}const contentEncoding=headersList.get(\"content-encoding\",true);if(contentEncoding){codings=contentEncoding.toLowerCase().split(\",\").map(x=>x.trim())}location=headersList.get(\"location\",true);this.body=new Readable({read:resume});const decoders=[];const willFollow=location&&request.redirect===\"follow\"&&redirectStatusSet.has(status);if(codings.length!==0&&request.method!==\"HEAD\"&&request.method!==\"CONNECT\"&&!nullBodyStatus.includes(status)&&!willFollow){for(let i=codings.length-1;i>=0;--i){const coding=codings[i];if(coding===\"x-gzip\"||coding===\"gzip\"){decoders.push(zlib.createGunzip({flush:zlib.constants.Z_SYNC_FLUSH,finishFlush:zlib.constants.Z_SYNC_FLUSH}))}else if(coding===\"deflate\"){decoders.push(createInflate({flush:zlib.constants.Z_SYNC_FLUSH,finishFlush:zlib.constants.Z_SYNC_FLUSH}))}else if(coding===\"br\"){decoders.push(zlib.createBrotliDecompress({flush:zlib.constants.BROTLI_OPERATION_FLUSH,finishFlush:zlib.constants.BROTLI_OPERATION_FLUSH}))}else{decoders.length=0;break}}}const onError=this.onError.bind(this);resolve({status,statusText,headersList,body:decoders.length?pipeline(this.body,...decoders,err=>{if(err){this.onError(err)}}).on(\"error\",onError):this.body.on(\"error\",onError)});return true},onData(chunk){if(fetchParams.controller.dump){return}const bytes=chunk;timingInfo.encodedBodySize+=bytes.byteLength;return this.body.push(bytes)},onComplete(){if(this.abort){fetchParams.controller.off(\"terminated\",this.abort)}if(fetchParams.controller.onAborted){fetchParams.controller.off(\"terminated\",fetchParams.controller.onAborted)}fetchParams.controller.ended=true;this.body.push(null)},onError(error){if(this.abort){fetchParams.controller.off(\"terminated\",this.abort)}this.body?.destroy(error);fetchParams.controller.terminate(error);reject(error)},onUpgrade(status,rawHeaders,socket){if(status!==101){return}const headersList=new HeadersList;for(let i=0;i<rawHeaders.length;i+=2){headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]),rawHeaders[i+1].toString(\"latin1\"),true)}resolve({status,statusText:STATUS_CODES[status],headersList,socket});return true}}))}__name(dispatch,\"dispatch\")}__name(httpNetworkFetch,\"httpNetworkFetch\");module.exports={fetch,Fetch,fetching,finalizeAndReportTiming};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/home/creditga/CofiCarte/node_modules/.pnpm/undici@6.21.0/node_modules/undici/lib/web/fetch/index.js"],"sourcesContent":["// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst {\n  makeNetworkError,\n  makeAppropriateNetworkError,\n  filterResponse,\n  makeResponse,\n  fromInnerResponse\n} = require('./response')\nconst { HeadersList } = require('./headers')\nconst { Request, cloneRequest } = require('./request')\nconst zlib = require('node:zlib')\nconst {\n  bytesMatch,\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  createDeferredPromise,\n  isBlobLike,\n  sameOrigin,\n  isCancelled,\n  isAborted,\n  isErrorLike,\n  fullyReadBody,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlIsHttpHttpsScheme,\n  urlHasHttpsScheme,\n  clampAndCoarsenConnectionTimingInfo,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  createInflate,\n  extractMimeType\n} = require('./util')\nconst { kState, kDispatcher } = require('./symbols')\nconst assert = require('node:assert')\nconst { safelyExtractBody, extractBody } = require('./body')\nconst {\n  redirectStatusSet,\n  nullBodyStatus,\n  safeMethodsSet,\n  requestBodyHeader,\n  subresourceSet\n} = require('./constants')\nconst EE = require('node:events')\nconst { Readable, pipeline, finished } = require('node:stream')\nconst { addAbortListener, isErrored, isReadable, bufferToLowerCasedHeaderName } = require('../../core/util')\nconst { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = require('./data-url')\nconst { getGlobalDispatcher } = require('../../global')\nconst { webidl } = require('./webidl')\nconst { STATUS_CODES } = require('node:http')\nconst GET_OR_HEAD = ['GET', 'HEAD']\n\nconst defaultUserAgent = typeof __UNDICI_IS_NODE__ !== 'undefined' || typeof esbuildDetection !== 'undefined'\n  ? 'node'\n  : 'undici'\n\n/** @type {import('buffer').resolveObjectURL} */\nlet resolveObjectURL\n\nclass Fetch extends EE {\n  constructor (dispatcher) {\n    super()\n\n    this.dispatcher = dispatcher\n    this.connection = null\n    this.dump = false\n    this.state = 'ongoing'\n  }\n\n  terminate (reason) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    this.state = 'terminated'\n    this.connection?.destroy(reason)\n    this.emit('terminated', reason)\n  }\n\n  // https://fetch.spec.whatwg.org/#fetch-controller-abort\n  abort (error) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    // 1. Set controller’s state to \"aborted\".\n    this.state = 'aborted'\n\n    // 2. Let fallbackError be an \"AbortError\" DOMException.\n    // 3. Set error to fallbackError if it is not given.\n    if (!error) {\n      error = new DOMException('The operation was aborted.', 'AbortError')\n    }\n\n    // 4. Let serializedError be StructuredSerialize(error).\n    //    If that threw an exception, catch it, and let\n    //    serializedError be StructuredSerialize(fallbackError).\n\n    // 5. Set controller’s serialized abort reason to serializedError.\n    this.serializedAbortReason = error\n\n    this.connection?.destroy(error)\n    this.emit('terminated', error)\n  }\n}\n\nfunction handleFetchDone (response) {\n  finalizeAndReportTiming(response, 'fetch')\n}\n\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch (input, init = undefined) {\n  webidl.argumentLengthCheck(arguments, 1, 'globalThis.fetch')\n\n  // 1. Let p be a new promise.\n  let p = createDeferredPromise()\n\n  // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n  let requestObject\n\n  try {\n    requestObject = new Request(input, init)\n  } catch (e) {\n    p.reject(e)\n    return p.promise\n  }\n\n  // 3. Let request be requestObject’s request.\n  const request = requestObject[kState]\n\n  // 4. If requestObject’s signal’s aborted flag is set, then:\n  if (requestObject.signal.aborted) {\n    // 1. Abort the fetch() call with p, request, null, and\n    //    requestObject’s signal’s abort reason.\n    abortFetch(p, request, null, requestObject.signal.reason)\n\n    // 2. Return p.\n    return p.promise\n  }\n\n  // 5. Let globalObject be request’s client’s global object.\n  const globalObject = request.client.globalObject\n\n  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // request’s service-workers mode to \"none\".\n  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {\n    request.serviceWorkers = 'none'\n  }\n\n  // 7. Let responseObject be null.\n  let responseObject = null\n\n  // 8. Let relevantRealm be this’s relevant Realm.\n\n  // 9. Let locallyAborted be false.\n  let locallyAborted = false\n\n  // 10. Let controller be null.\n  let controller = null\n\n  // 11. Add the following abort steps to requestObject’s signal:\n  addAbortListener(\n    requestObject.signal,\n    () => {\n      // 1. Set locallyAborted to true.\n      locallyAborted = true\n\n      // 2. Assert: controller is non-null.\n      assert(controller != null)\n\n      // 3. Abort controller with requestObject’s signal’s abort reason.\n      controller.abort(requestObject.signal.reason)\n\n      const realResponse = responseObject?.deref()\n\n      // 4. Abort the fetch() call with p, request, responseObject,\n      //    and requestObject’s signal’s abort reason.\n      abortFetch(p, request, realResponse, requestObject.signal.reason)\n    }\n  )\n\n  // 12. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n  // see function handleFetchDone\n\n  // 13. Set controller to the result of calling fetch given request,\n  // with processResponseEndOfBody set to handleFetchDone, and processResponse\n  // given response being these substeps:\n\n  const processResponse = (response) => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return\n    }\n\n    // 2. If response’s aborted flag is set, then:\n    if (response.aborted) {\n      // 1. Let deserializedError be the result of deserialize a serialized\n      //    abort reason given controller’s serialized abort reason and\n      //    relevantRealm.\n\n      // 2. Abort the fetch() call with p, request, responseObject, and\n      //    deserializedError.\n\n      abortFetch(p, request, responseObject, controller.serializedAbortReason)\n      return\n    }\n\n    // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n    if (response.type === 'error') {\n      p.reject(new TypeError('fetch failed', { cause: response.error }))\n      return\n    }\n\n    // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n    responseObject = new WeakRef(fromInnerResponse(response, 'immutable'))\n\n    // 5. Resolve p with responseObject.\n    p.resolve(responseObject.deref())\n    p = null\n  }\n\n  controller = fetching({\n    request,\n    processResponseEndOfBody: handleFetchDone,\n    processResponse,\n    dispatcher: requestObject[kDispatcher] // undici\n  })\n\n  // 14. Return p.\n  return p.promise\n}\n\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming (response, initiatorType = 'other') {\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return\n  }\n\n  // 2. If response’s URL list is null or empty, then return.\n  if (!response.urlList?.length) {\n    return\n  }\n\n  // 3. Let originalURL be response’s URL list[0].\n  const originalURL = response.urlList[0]\n\n  // 4. Let timingInfo be response’s timing info.\n  let timingInfo = response.timingInfo\n\n  // 5. Let cacheState be response’s cache state.\n  let cacheState = response.cacheState\n\n  // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n  if (!urlIsHttpHttpsScheme(originalURL)) {\n    return\n  }\n\n  // 7. If timingInfo is null, then return.\n  if (timingInfo === null) {\n    return\n  }\n\n  // 8. If response’s timing allow passed flag is not set, then:\n  if (!response.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    })\n\n    //  2. Set cacheState to the empty string.\n    cacheState = ''\n  }\n\n  // 9. Set timingInfo’s end time to the coarsened shared current time\n  // given global’s relevant settings object’s cross-origin isolated\n  // capability.\n  // TODO: given global’s relevant settings object’s cross-origin isolated\n  // capability?\n  timingInfo.endTime = coarsenedSharedCurrentTime()\n\n  // 10. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n  markResourceTiming(\n    timingInfo,\n    originalURL.href,\n    initiatorType,\n    globalThis,\n    cacheState\n  )\n}\n\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nconst markResourceTiming = performance.markResourceTiming\n\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch (p, request, responseObject, error) {\n  // 1. Reject promise with error.\n  if (p) {\n    // We might have already resolved the promise at this stage\n    p.reject(error)\n  }\n\n  // 2. If request’s body is not null and is readable, then cancel request’s\n  // body with error.\n  if (request.body != null && isReadable(request.body?.stream)) {\n    request.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n\n  // 3. If responseObject is null, then return.\n  if (responseObject == null) {\n    return\n  }\n\n  // 4. Let response be responseObject’s response.\n  const response = responseObject[kState]\n\n  // 5. If response’s body is not null and is readable, then error response’s\n  // body with error.\n  if (response.body != null && isReadable(response.body?.stream)) {\n    response.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching ({\n  request,\n  processRequestBodyChunkLength,\n  processRequestEndOfBody,\n  processResponse,\n  processResponseEndOfBody,\n  processResponseConsumeBody,\n  useParallelQueue = false,\n  dispatcher = getGlobalDispatcher() // undici\n}) {\n  // Ensure that the dispatcher is set accordingly\n  assert(dispatcher)\n\n  // 1. Let taskDestination be null.\n  let taskDestination = null\n\n  // 2. Let crossOriginIsolatedCapability be false.\n  let crossOriginIsolatedCapability = false\n\n  // 3. If request’s client is non-null, then:\n  if (request.client != null) {\n    // 1. Set taskDestination to request’s client’s global object.\n    taskDestination = request.client.globalObject\n\n    // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n    // isolated capability.\n    crossOriginIsolatedCapability =\n      request.client.crossOriginIsolatedCapability\n  }\n\n  // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n  const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currentTime\n  })\n\n  // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n  const fetchParams = {\n    controller: new Fetch(dispatcher),\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }\n\n  // 7. If request’s body is a byte sequence, then set request’s body to\n  //    request’s body as a body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n  assert(!request.body || request.body.stream)\n\n  // 8. If request’s window is \"client\", then set request’s window to request’s\n  // client, if request’s client’s global object is a Window object; otherwise\n  // \"no-window\".\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window =\n      request.client?.globalObject?.constructor?.name === 'Window'\n        ? request.client\n        : 'no-window'\n  }\n\n  // 9. If request’s origin is \"client\", then set request’s origin to request’s\n  // client’s origin.\n  if (request.origin === 'client') {\n    request.origin = request.client.origin\n  }\n\n  // 10. If all of the following conditions are true:\n  // TODO\n\n  // 11. If request’s policy container is \"client\", then:\n  if (request.policyContainer === 'client') {\n    // 1. If request’s client is non-null, then set request’s policy\n    // container to a clone of request’s client’s policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(\n        request.client.policyContainer\n      )\n    } else {\n      // 2. Otherwise, set request’s policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer()\n    }\n  }\n\n  // 12. If request’s header list does not contain `Accept`, then:\n  if (!request.headersList.contains('accept', true)) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'\n\n    // 2. A user agent should set value to the first matching statement, if\n    // any, switching on request’s destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n\n    // 3. Append `Accept`/value to request’s header list.\n    request.headersList.append('accept', value, true)\n  }\n\n  // 13. If request’s header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // request’s header list.\n  if (!request.headersList.contains('accept-language', true)) {\n    request.headersList.append('accept-language', '*', true)\n  }\n\n  // 14. If request’s priority is null, then use request’s initiator and\n  // destination appropriately in setting request’s priority to a\n  // user-agent-defined object.\n  if (request.priority === null) {\n    // TODO\n  }\n\n  // 15. If request is a subresource request, then:\n  if (subresourceSet.has(request.destination)) {\n    // TODO\n  }\n\n  // 16. Run main fetch given fetchParams.\n  mainFetch(fetchParams)\n    .catch(err => {\n      fetchParams.controller.terminate(err)\n    })\n\n  // 17. Return fetchParam's controller\n  return fetchParams.controller\n}\n\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch (fetchParams, recursive = false) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. If request’s local-URLs-only flag is set and request’s current URL is\n  // not local, then set response to a network error.\n  if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n    response = makeNetworkError('local URLs only')\n  }\n\n  // 4. Run report Content Security Policy violations for request.\n  // TODO\n\n  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n  tryUpgradeRequestToAPotentiallyTrustworthyURL(request)\n\n  // 6. If should request be blocked due to a bad port, should fetching request\n  // be blocked as mixed content, or should request be blocked by Content\n  // Security Policy returns blocked, then set response to a network error.\n  if (requestBadPort(request) === 'blocked') {\n    response = makeNetworkError('bad port')\n  }\n  // TODO: should fetching request be blocked as mixed content?\n  // TODO: should request be blocked by Content Security Policy?\n\n  // 7. If request’s referrer policy is the empty string, then set request’s\n  // referrer policy to request’s policy container’s referrer policy.\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = request.policyContainer.referrerPolicy\n  }\n\n  // 8. If request’s referrer is not \"no-referrer\", then set request’s\n  // referrer to the result of invoking determine request’s referrer.\n  if (request.referrer !== 'no-referrer') {\n    request.referrer = determineRequestsReferrer(request)\n  }\n\n  // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n  // conditions are true:\n  // - request’s current URL’s scheme is \"http\"\n  // - request’s current URL’s host is a domain\n  // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n  //   Matching results in either a superdomain match with an asserted\n  //   includeSubDomains directive or a congruent match (with or without an\n  //   asserted includeSubDomains directive). [HSTS]\n  // TODO\n\n  // 10. If recursive is false, then run the remaining steps in parallel.\n  // TODO\n\n  // 11. If response is null, then set response to the result of running\n  // the steps corresponding to the first matching statement:\n  if (response === null) {\n    response = await (async () => {\n      const currentURL = requestCurrentURL(request)\n\n      if (\n        // - request’s current URL’s origin is same origin with request’s origin,\n        //   and request’s response tainting is \"basic\"\n        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||\n        // request’s current URL’s scheme is \"data\"\n        (currentURL.protocol === 'data:') ||\n        // - request’s mode is \"navigate\" or \"websocket\"\n        (request.mode === 'navigate' || request.mode === 'websocket')\n      ) {\n        // 1. Set request’s response tainting to \"basic\".\n        request.responseTainting = 'basic'\n\n        // 2. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams)\n      }\n\n      // request’s mode is \"same-origin\"\n      if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        return makeNetworkError('request mode cannot be \"same-origin\"')\n      }\n\n      // request’s mode is \"no-cors\"\n      if (request.mode === 'no-cors') {\n        // 1. If request’s redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          return makeNetworkError(\n            'redirect mode cannot be \"follow\" for \"no-cors\" request'\n          )\n        }\n\n        // 2. Set request’s response tainting to \"opaque\".\n        request.responseTainting = 'opaque'\n\n        // 3. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams)\n      }\n\n      // request’s current URL’s scheme is not an HTTP(S) scheme\n      if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n        // Return a network error.\n        return makeNetworkError('URL scheme must be a HTTP(S) scheme')\n      }\n\n      // - request’s use-CORS-preflight flag is set\n      // - request’s unsafe-request flag is set and either request’s method is\n      //   not a CORS-safelisted method or CORS-unsafe request-header names with\n      //   request’s header list is not empty\n      //    1. Set request’s response tainting to \"cors\".\n      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n      //    given fetchParams and true.\n      //    3. If corsWithPreflightResponse is a network error, then clear cache\n      //    entries using request.\n      //    4. Return corsWithPreflightResponse.\n      // TODO\n\n      // Otherwise\n      //    1. Set request’s response tainting to \"cors\".\n      request.responseTainting = 'cors'\n\n      //    2. Return the result of running HTTP fetch given fetchParams.\n      return await httpFetch(fetchParams)\n    })()\n  }\n\n  // 12. If recursive is true, then return response.\n  if (recursive) {\n    return response\n  }\n\n  // 13. If response is not a network error and response is not a filtered\n  // response, then:\n  if (response.status !== 0 && !response.internalResponse) {\n    // If request’s response tainting is \"cors\", then:\n    if (request.responseTainting === 'cors') {\n      // 1. Let headerNames be the result of extracting header list values\n      // given `Access-Control-Expose-Headers` and response’s header list.\n      // TODO\n      // 2. If request’s credentials mode is not \"include\" and headerNames\n      // contains `*`, then set response’s CORS-exposed header-name list to\n      // all unique header names in response’s header list.\n      // TODO\n      // 3. Otherwise, if headerNames is not null or failure, then set\n      // response’s CORS-exposed header-name list to headerNames.\n      // TODO\n    }\n\n    // Set response to the following filtered response with response as its\n    // internal response, depending on request’s response tainting:\n    if (request.responseTainting === 'basic') {\n      response = filterResponse(response, 'basic')\n    } else if (request.responseTainting === 'cors') {\n      response = filterResponse(response, 'cors')\n    } else if (request.responseTainting === 'opaque') {\n      response = filterResponse(response, 'opaque')\n    } else {\n      assert(false)\n    }\n  }\n\n  // 14. Let internalResponse be response, if response is a network error,\n  // and response’s internal response otherwise.\n  let internalResponse =\n    response.status === 0 ? response : response.internalResponse\n\n  // 15. If internalResponse’s URL list is empty, then set it to a clone of\n  // request’s URL list.\n  if (internalResponse.urlList.length === 0) {\n    internalResponse.urlList.push(...request.urlList)\n  }\n\n  // 16. If request’s timing allow failed flag is unset, then set\n  // internalResponse’s timing allow passed flag.\n  if (!request.timingAllowFailed) {\n    response.timingAllowPassed = true\n  }\n\n  // 17. If response is not a network error and any of the following returns\n  // blocked\n  // - should internalResponse to request be blocked as mixed content\n  // - should internalResponse to request be blocked by Content Security Policy\n  // - should internalResponse to request be blocked due to its MIME type\n  // - should internalResponse to request be blocked due to nosniff\n  // TODO\n\n  // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n  // internalResponse’s range-requested flag is set, and request’s header\n  // list does not contain `Range`, then set response and internalResponse\n  // to a network error.\n  if (\n    response.type === 'opaque' &&\n    internalResponse.status === 206 &&\n    internalResponse.rangeRequested &&\n    !request.headers.contains('range', true)\n  ) {\n    response = internalResponse = makeNetworkError()\n  }\n\n  // 19. If response is not a network error and either request’s method is\n  // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n  // set internalResponse’s body to null and disregard any enqueuing toward\n  // it (if any).\n  if (\n    response.status !== 0 &&\n    (request.method === 'HEAD' ||\n      request.method === 'CONNECT' ||\n      nullBodyStatus.includes(internalResponse.status))\n  ) {\n    internalResponse.body = null\n    fetchParams.controller.dump = true\n  }\n\n  // 20. If request’s integrity metadata is not the empty string, then:\n  if (request.integrity) {\n    // 1. Let processBodyError be this step: run fetch finale given fetchParams\n    // and a network error.\n    const processBodyError = (reason) =>\n      fetchFinale(fetchParams, makeNetworkError(reason))\n\n    // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n    // then run processBodyError and abort these steps.\n    if (request.responseTainting === 'opaque' || response.body == null) {\n      processBodyError(response.error)\n      return\n    }\n\n    // 3. Let processBody given bytes be these steps:\n    const processBody = (bytes) => {\n      // 1. If bytes do not match request’s integrity metadata,\n      // then run processBodyError and abort these steps. [SRI]\n      if (!bytesMatch(bytes, request.integrity)) {\n        processBodyError('integrity mismatch')\n        return\n      }\n\n      // 2. Set response’s body to bytes as a body.\n      response.body = safelyExtractBody(bytes)[0]\n\n      // 3. Run fetch finale given fetchParams and response.\n      fetchFinale(fetchParams, response)\n    }\n\n    // 4. Fully read response’s body given processBody and processBodyError.\n    await fullyReadBody(response.body, processBody, processBodyError)\n  } else {\n    // 21. Otherwise, run fetch finale given fetchParams and response.\n    fetchFinale(fetchParams, response)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch (fetchParams) {\n  // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n  // cancelled state, we do not want this condition to trigger *unless* there have been\n  // no redirects. See https://github.com/nodejs/undici/issues/1776\n  // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n  if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n    return Promise.resolve(makeAppropriateNetworkError(fetchParams))\n  }\n\n  // 2. Let request be fetchParams’s request.\n  const { request } = fetchParams\n\n  const { protocol: scheme } = requestCurrentURL(request)\n\n  // 3. Switch on request’s current URL’s scheme and run the associated steps:\n  switch (scheme) {\n    case 'about:': {\n      // If request’s current URL’s path is the string \"blank\", then return a new response\n      // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,\n      // and body is the empty byte sequence as a body.\n\n      // Otherwise, return a network error.\n      return Promise.resolve(makeNetworkError('about scheme is not supported'))\n    }\n    case 'blob:': {\n      if (!resolveObjectURL) {\n        resolveObjectURL = require('node:buffer').resolveObjectURL\n      }\n\n      // 1. Let blobURLEntry be request’s current URL’s blob URL entry.\n      const blobURLEntry = requestCurrentURL(request)\n\n      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n      // Buffer.resolveObjectURL does not ignore URL queries.\n      if (blobURLEntry.search.length !== 0) {\n        return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'))\n      }\n\n      const blob = resolveObjectURL(blobURLEntry.toString())\n\n      // 2. If request’s method is not `GET`, blobURLEntry is null, or blobURLEntry’s\n      //    object is not a Blob object, then return a network error.\n      if (request.method !== 'GET' || !isBlobLike(blob)) {\n        return Promise.resolve(makeNetworkError('invalid method'))\n      }\n\n      // 3. Let blob be blobURLEntry’s object.\n      // Note: done above\n\n      // 4. Let response be a new response.\n      const response = makeResponse()\n\n      // 5. Let fullLength be blob’s size.\n      const fullLength = blob.size\n\n      // 6. Let serializedFullLength be fullLength, serialized and isomorphic encoded.\n      const serializedFullLength = isomorphicEncode(`${fullLength}`)\n\n      // 7. Let type be blob’s type.\n      const type = blob.type\n\n      // 8. If request’s header list does not contain `Range`:\n      // 9. Otherwise:\n      if (!request.headersList.contains('range', true)) {\n        // 1. Let bodyWithType be the result of safely extracting blob.\n        // Note: in the FileAPI a blob \"object\" is a Blob *or* a MediaSource.\n        // In node, this can only ever be a Blob. Therefore we can safely\n        // use extractBody directly.\n        const bodyWithType = extractBody(blob)\n\n        // 2. Set response’s status message to `OK`.\n        response.statusText = 'OK'\n\n        // 3. Set response’s body to bodyWithType’s body.\n        response.body = bodyWithType[0]\n\n        // 4. Set response’s header list to « (`Content-Length`, serializedFullLength), (`Content-Type`, type) ».\n        response.headersList.set('content-length', serializedFullLength, true)\n        response.headersList.set('content-type', type, true)\n      } else {\n        // 1. Set response’s range-requested flag.\n        response.rangeRequested = true\n\n        // 2. Let rangeHeader be the result of getting `Range` from request’s header list.\n        const rangeHeader = request.headersList.get('range', true)\n\n        // 3. Let rangeValue be the result of parsing a single range header value given rangeHeader and true.\n        const rangeValue = simpleRangeHeaderValue(rangeHeader, true)\n\n        // 4. If rangeValue is failure, then return a network error.\n        if (rangeValue === 'failure') {\n          return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n        }\n\n        // 5. Let (rangeStart, rangeEnd) be rangeValue.\n        let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue\n\n        // 6. If rangeStart is null:\n        // 7. Otherwise:\n        if (rangeStart === null) {\n          // 1. Set rangeStart to fullLength − rangeEnd.\n          rangeStart = fullLength - rangeEnd\n\n          // 2. Set rangeEnd to rangeStart + rangeEnd − 1.\n          rangeEnd = rangeStart + rangeEnd - 1\n        } else {\n          // 1. If rangeStart is greater than or equal to fullLength, then return a network error.\n          if (rangeStart >= fullLength) {\n            return Promise.resolve(makeNetworkError('Range start is greater than the blob\\'s size.'))\n          }\n\n          // 2. If rangeEnd is null or rangeEnd is greater than or equal to fullLength, then set\n          //    rangeEnd to fullLength − 1.\n          if (rangeEnd === null || rangeEnd >= fullLength) {\n            rangeEnd = fullLength - 1\n          }\n        }\n\n        // 8. Let slicedBlob be the result of invoking slice blob given blob, rangeStart,\n        //    rangeEnd + 1, and type.\n        const slicedBlob = blob.slice(rangeStart, rangeEnd, type)\n\n        // 9. Let slicedBodyWithType be the result of safely extracting slicedBlob.\n        // Note: same reason as mentioned above as to why we use extractBody\n        const slicedBodyWithType = extractBody(slicedBlob)\n\n        // 10. Set response’s body to slicedBodyWithType’s body.\n        response.body = slicedBodyWithType[0]\n\n        // 11. Let serializedSlicedLength be slicedBlob’s size, serialized and isomorphic encoded.\n        const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`)\n\n        // 12. Let contentRange be the result of invoking build a content range given rangeStart,\n        //     rangeEnd, and fullLength.\n        const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength)\n\n        // 13. Set response’s status to 206.\n        response.status = 206\n\n        // 14. Set response’s status message to `Partial Content`.\n        response.statusText = 'Partial Content'\n\n        // 15. Set response’s header list to « (`Content-Length`, serializedSlicedLength),\n        //     (`Content-Type`, type), (`Content-Range`, contentRange) ».\n        response.headersList.set('content-length', serializedSlicedLength, true)\n        response.headersList.set('content-type', type, true)\n        response.headersList.set('content-range', contentRange, true)\n      }\n\n      // 10. Return response.\n      return Promise.resolve(response)\n    }\n    case 'data:': {\n      // 1. Let dataURLStruct be the result of running the\n      //    data: URL processor on request’s current URL.\n      const currentURL = requestCurrentURL(request)\n      const dataURLStruct = dataURLProcessor(currentURL)\n\n      // 2. If dataURLStruct is failure, then return a\n      //    network error.\n      if (dataURLStruct === 'failure') {\n        return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n      }\n\n      // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n      const mimeType = serializeAMimeType(dataURLStruct.mimeType)\n\n      // 4. Return a response whose status message is `OK`,\n      //    header list is « (`Content-Type`, mimeType) »,\n      //    and body is dataURLStruct’s body as a body.\n      return Promise.resolve(makeResponse({\n        statusText: 'OK',\n        headersList: [\n          ['content-type', { name: 'Content-Type', value: mimeType }]\n        ],\n        body: safelyExtractBody(dataURLStruct.body)[0]\n      }))\n    }\n    case 'file:': {\n      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n      // When in doubt, return a network error.\n      return Promise.resolve(makeNetworkError('not implemented... yet...'))\n    }\n    case 'http:':\n    case 'https:': {\n      // Return the result of running HTTP fetch given fetchParams.\n\n      return httpFetch(fetchParams)\n        .catch((err) => makeNetworkError(err))\n    }\n    default: {\n      return Promise.resolve(makeNetworkError('unknown scheme'))\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse (fetchParams, response) {\n  // 1. Set fetchParams’s request’s done flag.\n  fetchParams.request.done = true\n\n  // 2, If fetchParams’s process response done is not null, then queue a fetch\n  // task to run fetchParams’s process response done given response, with\n  // fetchParams’s task destination.\n  if (fetchParams.processResponseDone != null) {\n    queueMicrotask(() => fetchParams.processResponseDone(response))\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale (fetchParams, response) {\n  // 1. Let timingInfo be fetchParams’s timing info.\n  let timingInfo = fetchParams.timingInfo\n\n  // 2. If response is not a network error and fetchParams’s request’s client is a secure context,\n  //    then set timingInfo’s server-timing headers to the result of getting, decoding, and splitting\n  //    `Server-Timing` from response’s internal response’s header list.\n  // TODO\n\n  // 3. Let processResponseEndOfBody be the following steps:\n  const processResponseEndOfBody = () => {\n    // 1. Let unsafeEndTime be the unsafe shared current time.\n    const unsafeEndTime = Date.now() // ?\n\n    // 2. If fetchParams’s request’s destination is \"document\", then set fetchParams’s controller’s\n    //    full timing info to fetchParams’s timing info.\n    if (fetchParams.request.destination === 'document') {\n      fetchParams.controller.fullTimingInfo = timingInfo\n    }\n\n    // 3. Set fetchParams’s controller’s report timing steps to the following steps given a global object global:\n    fetchParams.controller.reportTimingSteps = () => {\n      // 1. If fetchParams’s request’s URL’s scheme is not an HTTP(S) scheme, then return.\n      if (fetchParams.request.url.protocol !== 'https:') {\n        return\n      }\n\n      // 2. Set timingInfo’s end time to the relative high resolution time given unsafeEndTime and global.\n      timingInfo.endTime = unsafeEndTime\n\n      // 3. Let cacheState be response’s cache state.\n      let cacheState = response.cacheState\n\n      // 4. Let bodyInfo be response’s body info.\n      const bodyInfo = response.bodyInfo\n\n      // 5. If response’s timing allow passed flag is not set, then set timingInfo to the result of creating an\n      //    opaque timing info for timingInfo and set cacheState to the empty string.\n      if (!response.timingAllowPassed) {\n        timingInfo = createOpaqueTimingInfo(timingInfo)\n\n        cacheState = ''\n      }\n\n      // 6. Let responseStatus be 0.\n      let responseStatus = 0\n\n      // 7. If fetchParams’s request’s mode is not \"navigate\" or response’s has-cross-origin-redirects is false:\n      if (fetchParams.request.mode !== 'navigator' || !response.hasCrossOriginRedirects) {\n        // 1. Set responseStatus to response’s status.\n        responseStatus = response.status\n\n        // 2. Let mimeType be the result of extracting a MIME type from response’s header list.\n        const mimeType = extractMimeType(response.headersList)\n\n        // 3. If mimeType is not failure, then set bodyInfo’s content type to the result of minimizing a supported MIME type given mimeType.\n        if (mimeType !== 'failure') {\n          bodyInfo.contentType = minimizeSupportedMimeType(mimeType)\n        }\n      }\n\n      // 8. If fetchParams’s request’s initiator type is non-null, then mark resource timing given timingInfo,\n      //    fetchParams’s request’s URL, fetchParams’s request’s initiator type, global, cacheState, bodyInfo,\n      //    and responseStatus.\n      if (fetchParams.request.initiatorType != null) {\n        // TODO: update markresourcetiming\n        markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus)\n      }\n    }\n\n    // 4. Let processResponseEndOfBodyTask be the following steps:\n    const processResponseEndOfBodyTask = () => {\n      // 1. Set fetchParams’s request’s done flag.\n      fetchParams.request.done = true\n\n      // 2. If fetchParams’s process response end-of-body is non-null, then run fetchParams’s process\n      //    response end-of-body given response.\n      if (fetchParams.processResponseEndOfBody != null) {\n        queueMicrotask(() => fetchParams.processResponseEndOfBody(response))\n      }\n\n      // 3. If fetchParams’s request’s initiator type is non-null and fetchParams’s request’s client’s\n      //    global object is fetchParams’s task destination, then run fetchParams’s controller’s report\n      //    timing steps given fetchParams’s request’s client’s global object.\n      if (fetchParams.request.initiatorType != null) {\n        fetchParams.controller.reportTimingSteps()\n      }\n    }\n\n    // 5. Queue a fetch task to run processResponseEndOfBodyTask with fetchParams’s task destination\n    queueMicrotask(() => processResponseEndOfBodyTask())\n  }\n\n  // 4. If fetchParams’s process response is non-null, then queue a fetch task to run fetchParams’s\n  //    process response given response, with fetchParams’s task destination.\n  if (fetchParams.processResponse != null) {\n    queueMicrotask(() => {\n      fetchParams.processResponse(response)\n      fetchParams.processResponse = null\n    })\n  }\n\n  // 5. Let internalResponse be response, if response is a network error; otherwise response’s internal response.\n  const internalResponse = response.type === 'error' ? response : (response.internalResponse ?? response)\n\n  // 6. If internalResponse’s body is null, then run processResponseEndOfBody.\n  // 7. Otherwise:\n  if (internalResponse.body == null) {\n    processResponseEndOfBody()\n  } else {\n    // mcollina: all the following steps of the specs are skipped.\n    // The internal transform stream is not needed.\n    // See https://github.com/nodejs/undici/pull/3093#issuecomment-2050198541\n\n    // 1. Let transformStream be a new TransformStream.\n    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk, enqueues chunk in transformStream.\n    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm and flushAlgorithm\n    //    set to processResponseEndOfBody.\n    // 4. Set internalResponse’s body’s stream to the result of internalResponse’s body’s stream piped through transformStream.\n\n    finished(internalResponse.body.stream, () => {\n      processResponseEndOfBody()\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch (fetchParams) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let actualResponse be null.\n  let actualResponse = null\n\n  // 4. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 5. If request’s service-workers mode is \"all\", then:\n  if (request.serviceWorkers === 'all') {\n    // TODO\n  }\n\n  // 6. If response is null, then:\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n\n    // 2. If request’s redirect mode is \"follow\", then set request’s\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none'\n    }\n\n    // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams)\n\n    // 4. If request’s response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n    if (\n      request.responseTainting === 'cors' &&\n      corsCheck(request, response) === 'failure'\n    ) {\n      return makeNetworkError('cors failure')\n    }\n\n    // 5. If the TAO check for request and response returns failure, then set\n    // request’s timing allow failed flag.\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true\n    }\n  }\n\n  // 7. If either request’s response tainting or response’s type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // request’s origin, request’s client, request’s destination,\n  // and actualResponse returns blocked, then return a network error.\n  if (\n    (request.responseTainting === 'opaque' || response.type === 'opaque') &&\n    crossOriginResourcePolicyCheck(\n      request.origin,\n      request.client,\n      request.destination,\n      actualResponse\n    ) === 'blocked'\n  ) {\n    return makeNetworkError('blocked')\n  }\n\n  // 8. If actualResponse’s status is a redirect status, then:\n  if (redirectStatusSet.has(actualResponse.status)) {\n    // 1. If actualResponse’s status is not 303, request’s body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    if (request.redirect !== 'manual') {\n      fetchParams.controller.connection.destroy(undefined, false)\n    }\n\n    // 2. Switch on request’s redirect mode:\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError('unexpected redirect')\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch(fetchParams, response)\n    } else {\n      assert(false)\n    }\n  }\n\n  // 9. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 10. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch (fetchParams, response) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let actualResponse be response, if response is not a filtered response,\n  // and response’s internal response otherwise.\n  const actualResponse = response.internalResponse\n    ? response.internalResponse\n    : response\n\n  // 3. Let locationURL be actualResponse’s location URL given request’s current\n  // URL’s fragment.\n  let locationURL\n\n  try {\n    locationURL = responseLocationURL(\n      actualResponse,\n      requestCurrentURL(request).hash\n    )\n\n    // 4. If locationURL is null, then return response.\n    if (locationURL == null) {\n      return response\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return Promise.resolve(makeNetworkError(err))\n  }\n\n  // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n  // error.\n  if (!urlIsHttpHttpsScheme(locationURL)) {\n    return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'))\n  }\n\n  // 7. If request’s redirect count is 20, then return a network error.\n  if (request.redirectCount === 20) {\n    return Promise.resolve(makeNetworkError('redirect count exceeded'))\n  }\n\n  // 8. Increase request’s redirect count by 1.\n  request.redirectCount += 1\n\n  // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n  // request’s origin is not same origin with locationURL’s origin, then return\n  //  a network error.\n  if (\n    request.mode === 'cors' &&\n    (locationURL.username || locationURL.password) &&\n    !sameOrigin(request, locationURL)\n  ) {\n    return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'))\n  }\n\n  // 10. If request’s response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n  if (\n    request.responseTainting === 'cors' &&\n    (locationURL.username || locationURL.password)\n  ) {\n    return Promise.resolve(makeNetworkError(\n      'URL cannot contain credentials for request mode \"cors\"'\n    ))\n  }\n\n  // 11. If actualResponse’s status is not 303, request’s body is non-null,\n  // and request’s body’s source is null, then return a network error.\n  if (\n    actualResponse.status !== 303 &&\n    request.body != null &&\n    request.body.source == null\n  ) {\n    return Promise.resolve(makeNetworkError())\n  }\n\n  // 12. If one of the following is true\n  // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n  if (\n    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||\n    (actualResponse.status === 303 &&\n      !GET_OR_HEAD.includes(request.method))\n  ) {\n    // then:\n    // 1. Set request’s method to `GET` and request’s body to null.\n    request.method = 'GET'\n    request.body = null\n\n    // 2. For each headerName of request-body-header name, delete headerName from\n    // request’s header list.\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName)\n    }\n  }\n\n  // 13. If request’s current URL’s origin is not same origin with locationURL’s\n  //     origin, then for each headerName of CORS non-wildcard request-header name,\n  //     delete headerName from request’s header list.\n  if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n    // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n    request.headersList.delete('authorization', true)\n\n    // https://fetch.spec.whatwg.org/#authentication-entries\n    request.headersList.delete('proxy-authorization', true)\n\n    // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n    request.headersList.delete('cookie', true)\n    request.headersList.delete('host', true)\n  }\n\n  // 14. If request’s body is non-null, then set request’s body to the first return\n  // value of safely extracting request’s body’s source.\n  if (request.body != null) {\n    assert(request.body.source != null)\n    request.body = safelyExtractBody(request.body.source)[0]\n  }\n\n  // 15. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 16. Set timingInfo’s redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParams’s cross-origin isolated\n  // capability.\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =\n    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n\n  // 17. If timingInfo’s redirect start time is 0, then set timingInfo’s\n  //  redirect start time to timingInfo’s start time.\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime\n  }\n\n  // 18. Append locationURL to request’s URL list.\n  request.urlList.push(locationURL)\n\n  // 19. Invoke set request’s referrer policy on redirect on request and\n  // actualResponse.\n  setRequestReferrerPolicyOnRedirect(request, actualResponse)\n\n  // 20. Return the result of running main fetch given fetchParams and true.\n  return mainFetch(fetchParams, true)\n}\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch (\n  fetchParams,\n  isAuthenticationFetch = false,\n  isNewConnectionFetch = false\n) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let httpFetchParams be null.\n  let httpFetchParams = null\n\n  // 3. Let httpRequest be null.\n  let httpRequest = null\n\n  // 4. Let response be null.\n  let response = null\n\n  // 5. Let storedResponse be null.\n  // TODO: cache\n\n  // 6. Let httpCache be null.\n  const httpCache = null\n\n  // 7. Let the revalidatingFlag be unset.\n  const revalidatingFlag = false\n\n  // 8. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If request’s window is \"no-window\" and request’s redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams\n    httpRequest = request\n  } else {\n    // Otherwise:\n\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = cloneRequest(request)\n\n    // 2. Set httpFetchParams to a copy of fetchParams.\n    httpFetchParams = { ...fetchParams }\n\n    // 3. Set httpFetchParams’s request to httpRequest.\n    httpFetchParams.request = httpRequest\n  }\n\n  //    3. Let includeCredentials be true if one of\n  const includeCredentials =\n    request.credentials === 'include' ||\n    (request.credentials === 'same-origin' &&\n      request.responseTainting === 'basic')\n\n  //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n  //    body is non-null; otherwise null.\n  const contentLength = httpRequest.body ? httpRequest.body.length : null\n\n  //    5. Let contentLengthHeaderValue be null.\n  let contentLengthHeaderValue = null\n\n  //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n  if (\n    httpRequest.body == null &&\n    ['POST', 'PUT'].includes(httpRequest.method)\n  ) {\n    contentLengthHeaderValue = '0'\n  }\n\n  //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n  if (contentLength != null) {\n    contentLengthHeaderValue = isomorphicEncode(`${contentLength}`)\n  }\n\n  //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n  //    list.\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue, true)\n  }\n\n  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n  //    contentLengthHeaderValue) to httpRequest’s header list.\n\n  //    10. If contentLength is non-null and httpRequest’s keepalive is true,\n  //    then:\n  if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n  }\n\n  //    11. If httpRequest’s referrer is a URL, then append\n  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n  //     to httpRequest’s header list.\n  if (httpRequest.referrer instanceof URL) {\n    httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href), true)\n  }\n\n  //    12. Append a request `Origin` header for httpRequest.\n  appendRequestOriginHeader(httpRequest)\n\n  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n  appendFetchMetadata(httpRequest)\n\n  //    14. If httpRequest’s header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequest’s header list.\n  if (!httpRequest.headersList.contains('user-agent', true)) {\n    httpRequest.headersList.append('user-agent', defaultUserAgent)\n  }\n\n  //    15. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequest’s cache mode to \"no-store\".\n  if (\n    httpRequest.cache === 'default' &&\n    (httpRequest.headersList.contains('if-modified-since', true) ||\n      httpRequest.headersList.contains('if-none-match', true) ||\n      httpRequest.headersList.contains('if-unmodified-since', true) ||\n      httpRequest.headersList.contains('if-match', true) ||\n      httpRequest.headersList.contains('if-range', true))\n  ) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    16. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequest’s header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n  if (\n    httpRequest.cache === 'no-cache' &&\n    !httpRequest.preventNoCacheCacheControlHeaderModification &&\n    !httpRequest.headersList.contains('cache-control', true)\n  ) {\n    httpRequest.headersList.append('cache-control', 'max-age=0', true)\n  }\n\n  //    17. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequest’s header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.contains('pragma', true)) {\n      httpRequest.headersList.append('pragma', 'no-cache', true)\n    }\n\n    // 2. If httpRequest’s header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.contains('cache-control', true)) {\n      httpRequest.headersList.append('cache-control', 'no-cache', true)\n    }\n  }\n\n  //    18. If httpRequest’s header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n  if (httpRequest.headersList.contains('range', true)) {\n    httpRequest.headersList.append('accept-encoding', 'identity', true)\n  }\n\n  //    19. Modify httpRequest’s header list per HTTP. Do not append a given\n  //    header if httpRequest’s header list contains that header’s name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n  if (!httpRequest.headersList.contains('accept-encoding', true)) {\n    if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate', true)\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate', true)\n    }\n  }\n\n  httpRequest.headersList.delete('host', true)\n\n  //    20. If includeCredentials is true, then:\n  if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n  }\n\n  //    21. If there’s a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n\n  //    22. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n\n  //    23. If httpCache is null, then set httpRequest’s cache mode to\n  //    \"no-store\".\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    24. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n  if (httpRequest.cache !== 'no-store' && httpRequest.cache !== 'reload') {\n    // TODO: cache\n  }\n\n  // 9. If aborted, then return the appropriate network error for fetchParams.\n  // TODO\n\n  // 10. If response is null, then:\n  if (response == null) {\n    // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.cache === 'only-if-cached') {\n      return makeNetworkError('only if cached')\n    }\n\n    // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n    const forwardResponse = await httpNetworkFetch(\n      httpFetchParams,\n      includeCredentials,\n      isNewConnectionFetch\n    )\n\n    // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n    if (\n      !safeMethodsSet.has(httpRequest.method) &&\n      forwardResponse.status >= 200 &&\n      forwardResponse.status <= 399\n    ) {\n      // TODO: cache\n    }\n\n    // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n    // then:\n    if (revalidatingFlag && forwardResponse.status === 304) {\n      // TODO: cache\n    }\n\n    // 5. If response is null, then:\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse\n\n      // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  }\n\n  // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n  response.urlList = [...httpRequest.urlList]\n\n  // 12. If httpRequest’s header list contains `Range`, then set response’s\n  // range-requested flag.\n  if (httpRequest.headersList.contains('range', true)) {\n    response.rangeRequested = true\n  }\n\n  // 13. Set response’s request-includes-credentials to includeCredentials.\n  response.requestIncludesCredentials = includeCredentials\n\n  // 14. If response’s status is 401, httpRequest’s response tainting is not\n  // \"cors\", includeCredentials is true, and request’s window is an environment\n  // settings object, then:\n  // TODO\n\n  // 15. If response’s status is 407, then:\n  if (response.status === 407) {\n    // 1. If request’s window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError()\n    }\n\n    // 2. ???\n\n    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 4. Prompt the end user as appropriate in request’s window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n    return makeNetworkError('proxy authentication required')\n  }\n\n  // 16. If all of the following are true\n  if (\n    // response’s status is 421\n    response.status === 421 &&\n    // isNewConnectionFetch is false\n    !isNewConnectionFetch &&\n    // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n    (request.body == null || request.body.source != null)\n  ) {\n    // then:\n\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n    fetchParams.controller.connection.destroy()\n\n    response = await httpNetworkOrCacheFetch(\n      fetchParams,\n      isAuthenticationFetch,\n      true\n    )\n  }\n\n  // 17. If isAuthenticationFetch is true, then create an authentication entry\n  if (isAuthenticationFetch) {\n    // TODO\n  }\n\n  // 18. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch (\n  fetchParams,\n  includeCredentials = false,\n  forceNewConnection = false\n) {\n  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed)\n\n  fetchParams.controller.connection = {\n    abort: null,\n    destroyed: false,\n    destroy (err, abort = true) {\n      if (!this.destroyed) {\n        this.destroyed = true\n        if (abort) {\n          this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'))\n        }\n      }\n    }\n  }\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 4. Let httpCache be the result of determining the HTTP cache partition,\n  // given request.\n  // TODO: cache\n  const httpCache = null\n\n  // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n  if (httpCache == null) {\n    request.cache = 'no-store'\n  }\n\n  // 6. Let networkPartitionKey be the result of determining the network\n  // partition key given request.\n  // TODO\n\n  // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n  // \"no\".\n  const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars\n\n  // 8. Switch on request’s mode:\n  if (request.mode === 'websocket') {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given request’s current URL.\n    // TODO\n  } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, request’s current URL’s origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n  }\n\n  // 9. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If connection is failure, then return a network error.\n\n  //    2. Set timingInfo’s final connection timing info to the result of\n  //    calling clamp and coarsen connection timing info with connection’s\n  //    timing info, timingInfo’s post-redirect start time, and fetchParams’s\n  //    cross-origin isolated capability.\n\n  //    3. If connection is not an HTTP/2 connection, request’s body is non-null,\n  //    and request’s body’s source is null, then append (`Transfer-Encoding`,\n  //    `chunked`) to request’s header list.\n\n  //    4. Set timingInfo’s final network-request start time to the coarsened\n  //    shared current time given fetchParams’s cross-origin isolated\n  //    capability.\n\n  //    5. Set response to the result of making an HTTP request over connection\n  //    using request with the following caveats:\n\n  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n\n  //        - If request’s body is non-null, and request’s body’s source is null,\n  //        then the user agent may have a buffer of up to 64 kibibytes and store\n  //        a part of request’s body in that buffer. If the user agent reads from\n  //        request’s body beyond that buffer’s size and the user agent needs to\n  //        resend request, then instead return a network error.\n\n  //        - Set timingInfo’s final network-response start time to the coarsened\n  //        shared current time given fetchParams’s cross-origin isolated capability,\n  //        immediately after the user agent’s HTTP parser receives the first byte\n  //        of the response (e.g., frame header bytes for HTTP/2 or response status\n  //        line for HTTP/1.x).\n\n  //        - Wait until all the headers are transmitted.\n\n  //        - Any responses whose status is in the range 100 to 199, inclusive,\n  //        and is not 101, are to be ignored, except for the purposes of setting\n  //        timingInfo’s final network-response start time above.\n\n  //    - If request’s header list contains `Transfer-Encoding`/`chunked` and\n  //    response is transferred via HTTP/1.0 or older, then return a network\n  //    error.\n\n  //    - If the HTTP request results in a TLS client certificate dialog, then:\n\n  //        1. If request’s window is an environment settings object, make the\n  //        dialog available in request’s window.\n\n  //        2. Otherwise, return a network error.\n\n  // To transmit request’s body body, run these steps:\n  let requestBody = null\n  // 1. If body is null and fetchParams’s process request end-of-body is\n  // non-null, then queue a fetch task given fetchParams’s process request\n  // end-of-body and fetchParams’s task destination.\n  if (request.body == null && fetchParams.processRequestEndOfBody) {\n    queueMicrotask(() => fetchParams.processRequestEndOfBody())\n  } else if (request.body != null) {\n    // 2. Otherwise, if body is non-null:\n\n    //    1. Let processBodyChunk given bytes be these steps:\n    const processBodyChunk = async function * (bytes) {\n      // 1. If the ongoing fetch is terminated, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. Run this step in parallel: transmit bytes.\n      yield bytes\n\n      // 3. If fetchParams’s process request body is non-null, then run\n      // fetchParams’s process request body given bytes’s length.\n      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength)\n    }\n\n    // 2. Let processEndOfBody be these steps:\n    const processEndOfBody = () => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If fetchParams’s process request end-of-body is non-null,\n      // then run fetchParams’s process request end-of-body.\n      if (fetchParams.processRequestEndOfBody) {\n        fetchParams.processRequestEndOfBody()\n      }\n    }\n\n    // 3. Let processBodyError given e be these steps:\n    const processBodyError = (e) => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If e is an \"AbortError\" DOMException, then abort fetchParams’s controller.\n      if (e.name === 'AbortError') {\n        fetchParams.controller.abort()\n      } else {\n        fetchParams.controller.terminate(e)\n      }\n    }\n\n    // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,\n    // processBodyError, and fetchParams’s task destination.\n    requestBody = (async function * () {\n      try {\n        for await (const bytes of request.body.stream) {\n          yield * processBodyChunk(bytes)\n        }\n        processEndOfBody()\n      } catch (err) {\n        processBodyError(err)\n      }\n    })()\n  }\n\n  try {\n    // socket is only provided for websockets\n    const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody })\n\n    if (socket) {\n      response = makeResponse({ status, statusText, headersList, socket })\n    } else {\n      const iterator = body[Symbol.asyncIterator]()\n      fetchParams.controller.next = () => iterator.next()\n\n      response = makeResponse({ status, statusText, headersList })\n    }\n  } catch (err) {\n    // 10. If aborted, then:\n    if (err.name === 'AbortError') {\n      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      fetchParams.controller.connection.destroy()\n\n      // 2. Return the appropriate network error for fetchParams.\n      return makeAppropriateNetworkError(fetchParams, err)\n    }\n\n    return makeNetworkError(err)\n  }\n\n  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n  // if it is suspended.\n  const pullAlgorithm = async () => {\n    await fetchParams.controller.resume()\n  }\n\n  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s\n  // controller with reason, given reason.\n  const cancelAlgorithm = (reason) => {\n    // If the aborted fetch was already terminated, then we do not\n    // need to do anything.\n    if (!isCancelled(fetchParams)) {\n      fetchParams.controller.abort(reason)\n    }\n  }\n\n  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n  // the user agent.\n  // TODO\n\n  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n  // TODO\n\n  // 15. Let stream be a new ReadableStream.\n  // 16. Set up stream with byte reading support with pullAlgorithm set to pullAlgorithm,\n  //     cancelAlgorithm set to cancelAlgorithm.\n  const stream = new ReadableStream(\n    {\n      async start (controller) {\n        fetchParams.controller.controller = controller\n      },\n      async pull (controller) {\n        await pullAlgorithm(controller)\n      },\n      async cancel (reason) {\n        await cancelAlgorithm(reason)\n      },\n      type: 'bytes'\n    }\n  )\n\n  // 17. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. Set response’s body to a new body whose stream is stream.\n  response.body = { stream, source: null, length: null }\n\n  //    2. If response is not a network error and request’s cache mode is\n  //    not \"no-store\", then update response in httpCache for request.\n  //    TODO\n\n  //    3. If includeCredentials is true and the user agent is not configured\n  //    to block cookies for request (see section 7 of [COOKIES]), then run the\n  //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n  //    the value of each header whose name is a byte-case-insensitive match for\n  //    `Set-Cookie` in response’s header list, if any, and request’s current URL.\n  //    TODO\n\n  // 18. If aborted, then:\n  // TODO\n\n  // 19. Run these steps in parallel:\n\n  //    1. Run these steps, but abort when fetchParams is canceled:\n  fetchParams.controller.onAborted = onAborted\n  fetchParams.controller.on('terminated', onAborted)\n  fetchParams.controller.resume = async () => {\n    // 1. While true\n    while (true) {\n      // 1-3. See onData...\n\n      // 4. Set bytes to the result of handling content codings given\n      // codings and bytes.\n      let bytes\n      let isFailure\n      try {\n        const { done, value } = await fetchParams.controller.next()\n\n        if (isAborted(fetchParams)) {\n          break\n        }\n\n        bytes = done ? undefined : value\n      } catch (err) {\n        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n          // zlib doesn't like empty streams.\n          bytes = undefined\n        } else {\n          bytes = err\n\n          // err may be propagated from the result of calling readablestream.cancel,\n          // which might not be an error. https://github.com/nodejs/undici/issues/2009\n          isFailure = true\n        }\n      }\n\n      if (bytes === undefined) {\n        // 2. Otherwise, if the bytes transmission for response’s message\n        // body is done normally and stream is readable, then close\n        // stream, finalize response for fetchParams and response, and\n        // abort these in-parallel steps.\n        readableStreamClose(fetchParams.controller.controller)\n\n        finalizeResponse(fetchParams, response)\n\n        return\n      }\n\n      // 5. Increase timingInfo’s decoded body size by bytes’s length.\n      timingInfo.decodedBodySize += bytes?.byteLength ?? 0\n\n      // 6. If bytes is failure, then terminate fetchParams’s controller.\n      if (isFailure) {\n        fetchParams.controller.terminate(bytes)\n        return\n      }\n\n      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n      // into stream.\n      const buffer = new Uint8Array(bytes)\n      if (buffer.byteLength) {\n        fetchParams.controller.controller.enqueue(buffer)\n      }\n\n      // 8. If stream is errored, then terminate the ongoing fetch.\n      if (isErrored(stream)) {\n        fetchParams.controller.terminate()\n        return\n      }\n\n      // 9. If stream doesn’t need more data ask the user agent to suspend\n      // the ongoing fetch.\n      if (fetchParams.controller.controller.desiredSize <= 0) {\n        return\n      }\n    }\n  }\n\n  //    2. If aborted, then:\n  function onAborted (reason) {\n    // 2. If fetchParams is aborted, then:\n    if (isAborted(fetchParams)) {\n      // 1. Set response’s aborted flag.\n      response.aborted = true\n\n      // 2. If stream is readable, then error stream with the result of\n      //    deserialize a serialized abort reason given fetchParams’s\n      //    controller’s serialized abort reason and an\n      //    implementation-defined realm.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(\n          fetchParams.controller.serializedAbortReason\n        )\n      }\n    } else {\n      // 3. Otherwise, if stream is readable, error stream with a TypeError.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(new TypeError('terminated', {\n          cause: isErrorLike(reason) ? reason : undefined\n        }))\n      }\n    }\n\n    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n    fetchParams.controller.connection.destroy()\n  }\n\n  // 20. Return response.\n  return response\n\n  function dispatch ({ body }) {\n    const url = requestCurrentURL(request)\n    /** @type {import('../..').Agent} */\n    const agent = fetchParams.controller.dispatcher\n\n    return new Promise((resolve, reject) => agent.dispatch(\n      {\n        path: url.pathname + url.search,\n        origin: url.origin,\n        method: request.method,\n        body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,\n        headers: request.headersList.entries,\n        maxRedirections: 0,\n        upgrade: request.mode === 'websocket' ? 'websocket' : undefined\n      },\n      {\n        body: null,\n        abort: null,\n\n        onConnect (abort) {\n          // TODO (fix): Do we need connection here?\n          const { connection } = fetchParams.controller\n\n          // Set timingInfo’s final connection timing info to the result of calling clamp and coarsen\n          // connection timing info with connection’s timing info, timingInfo’s post-redirect start\n          // time, and fetchParams’s cross-origin isolated capability.\n          // TODO: implement connection timing\n          timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability)\n\n          if (connection.destroyed) {\n            abort(new DOMException('The operation was aborted.', 'AbortError'))\n          } else {\n            fetchParams.controller.on('terminated', abort)\n            this.abort = connection.abort = abort\n          }\n\n          // Set timingInfo’s final network-request start time to the coarsened shared current time given\n          // fetchParams’s cross-origin isolated capability.\n          timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n        },\n\n        onResponseStarted () {\n          // Set timingInfo’s final network-response start time to the coarsened shared current\n          // time given fetchParams’s cross-origin isolated capability, immediately after the\n          // user agent’s HTTP parser receives the first byte of the response (e.g., frame header\n          // bytes for HTTP/2 or response status line for HTTP/1.x).\n          timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n        },\n\n        onHeaders (status, rawHeaders, resume, statusText) {\n          if (status < 200) {\n            return\n          }\n\n          /** @type {string[]} */\n          let codings = []\n          let location = ''\n\n          const headersList = new HeadersList()\n\n          for (let i = 0; i < rawHeaders.length; i += 2) {\n            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)\n          }\n          const contentEncoding = headersList.get('content-encoding', true)\n          if (contentEncoding) {\n            // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n            // \"All content-coding values are case-insensitive...\"\n            codings = contentEncoding.toLowerCase().split(',').map((x) => x.trim())\n          }\n          location = headersList.get('location', true)\n\n          this.body = new Readable({ read: resume })\n\n          const decoders = []\n\n          const willFollow = location && request.redirect === 'follow' &&\n            redirectStatusSet.has(status)\n\n          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n          if (codings.length !== 0 && request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {\n            for (let i = codings.length - 1; i >= 0; --i) {\n              const coding = codings[i]\n              // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n              if (coding === 'x-gzip' || coding === 'gzip') {\n                decoders.push(zlib.createGunzip({\n                  // Be less strict when decoding compressed responses, since sometimes\n                  // servers send slightly invalid responses that are still accepted\n                  // by common browsers.\n                  // Always using Z_SYNC_FLUSH is what cURL does.\n                  flush: zlib.constants.Z_SYNC_FLUSH,\n                  finishFlush: zlib.constants.Z_SYNC_FLUSH\n                }))\n              } else if (coding === 'deflate') {\n                decoders.push(createInflate({\n                  flush: zlib.constants.Z_SYNC_FLUSH,\n                  finishFlush: zlib.constants.Z_SYNC_FLUSH\n                }))\n              } else if (coding === 'br') {\n                decoders.push(zlib.createBrotliDecompress({\n                  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n                  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n                }))\n              } else {\n                decoders.length = 0\n                break\n              }\n            }\n          }\n\n          const onError = this.onError.bind(this)\n\n          resolve({\n            status,\n            statusText,\n            headersList,\n            body: decoders.length\n              ? pipeline(this.body, ...decoders, (err) => {\n                if (err) {\n                  this.onError(err)\n                }\n              }).on('error', onError)\n              : this.body.on('error', onError)\n          })\n\n          return true\n        },\n\n        onData (chunk) {\n          if (fetchParams.controller.dump) {\n            return\n          }\n\n          // 1. If one or more bytes have been transmitted from response’s\n          // message body, then:\n\n          //  1. Let bytes be the transmitted bytes.\n          const bytes = chunk\n\n          //  2. Let codings be the result of extracting header list values\n          //  given `Content-Encoding` and response’s header list.\n          //  See pullAlgorithm.\n\n          //  3. Increase timingInfo’s encoded body size by bytes’s length.\n          timingInfo.encodedBodySize += bytes.byteLength\n\n          //  4. See pullAlgorithm...\n\n          return this.body.push(bytes)\n        },\n\n        onComplete () {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          if (fetchParams.controller.onAborted) {\n            fetchParams.controller.off('terminated', fetchParams.controller.onAborted)\n          }\n\n          fetchParams.controller.ended = true\n\n          this.body.push(null)\n        },\n\n        onError (error) {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          this.body?.destroy(error)\n\n          fetchParams.controller.terminate(error)\n\n          reject(error)\n        },\n\n        onUpgrade (status, rawHeaders, socket) {\n          if (status !== 101) {\n            return\n          }\n\n          const headersList = new HeadersList()\n\n          for (let i = 0; i < rawHeaders.length; i += 2) {\n            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)\n          }\n\n          resolve({\n            status,\n            statusText: STATUS_CODES[status],\n            headersList,\n            socket\n          })\n\n          return true\n        }\n      }\n    ))\n  }\n}\n\nmodule.exports = {\n  fetch,\n  Fetch,\n  fetching,\n  finalizeAndReportTiming\n}\n"]}}